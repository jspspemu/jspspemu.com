///<reference path="./array.ts" />
///<reference path="./math.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
if (typeof global != 'undefined')
    window = global;
if (typeof self != 'undefined')
    window = self;
if (typeof self == 'undefined')
    window = self = global;
if (typeof navigator == 'undefined')
    navigator = {};
function sprintf() {
    //  discuss at: http://phpjs.org/functions/sprintf/
    // original by: Ash Searle (http://hexmen.com/blog/)
    // improved by: Michael White (http://getsprink.com)
    // improved by: Jack
    // improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
    // improved by: Dj
    // improved by: Allidylls
    //    input by: Paulo Freitas
    //    input by: Brett Zamir (http://brett-zamir.me)
    //   example 1: sprintf("%01.2f", 123.1);
    //   returns 1: 123.10
    //   example 2: sprintf("[%10s]", 'monkey');
    //   returns 2: '[    monkey]'
    //   example 3: sprintf("[%'#10s]", 'monkey');
    //   returns 3: '[####monkey]'
    //   example 4: sprintf("%d", 123456789012345);
    //   returns 4: '123456789012345'
    //   example 5: sprintf('%-03s', 'E');
    //   returns 5: 'E00'
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    var regex = /%%|%(\d+\$)?([-+\'#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuideEfFgG])/g;
    var a = arguments;
    var i = 0;
    var format = a[i++];
    var pad = function (str, len, chr, leftJustify) {
        if (!chr) {
            chr = ' ';
        }
        var padding = (str.length >= len) ? '' : new Array(1 + len - str.length >>> 0)
            .join(chr);
        return leftJustify ? str + padding : padding + str;
    };
    var justify = function (value, prefix, leftJustify, minWidth, zeroPad, customPadChar) {
        if (customPadChar === void 0) { customPadChar = undefined; }
        var diff = minWidth - value.length;
        if (diff > 0) {
            if (leftJustify || !zeroPad) {
                value = pad(value, minWidth, customPadChar, leftJustify);
            }
            else {
                value = value.slice(0, prefix.length) + pad('', diff, '0', true) + value.slice(prefix.length);
            }
        }
        return value;
    };
    var formatBaseX = function (value, base, prefix, leftJustify, minWidth, precision, zeroPad) {
        var number = value >>> 0;
        prefix = prefix && number && {
            '2': '0b',
            '8': '0',
            '16': '0x'
        }[base] || '';
        var valueStr = prefix + pad(number.toString(base), precision || 0, '0', false);
        return justify(valueStr, prefix, leftJustify, minWidth, zeroPad);
    };
    var formatString = function (value, leftJustify, minWidth, precision, zeroPad, customPadChar) {
        if (customPadChar === void 0) { customPadChar = undefined; }
        if (precision != null) {
            value = value.slice(0, precision);
        }
        return justify(value, '', leftJustify, minWidth, zeroPad, customPadChar);
    };
    var doFormat = function (substring, valueIndex, flags, minWidth, _, precision, type) {
        var number, prefix, method, textTransform, value;
        if (substring === '%%') {
            return '%';
        }
        var leftJustify = false;
        var positivePrefix = '';
        var zeroPad = false;
        var prefixBaseX = false;
        var customPadChar = ' ';
        var flagsl = flags.length;
        for (var j = 0; flags && j < flagsl; j++) {
            switch (flags.charAt(j)) {
                case ' ':
                    positivePrefix = ' ';
                    break;
                case '+':
                    positivePrefix = '+';
                    break;
                case '-':
                    leftJustify = true;
                    break;
                case "'":
                    customPadChar = flags.charAt(j + 1);
                    break;
                case '0':
                    zeroPad = true;
                    customPadChar = '0';
                    break;
                case '#':
                    prefixBaseX = true;
                    break;
            }
        }
        if (!minWidth) {
            minWidth = 0;
        }
        else if (minWidth === '*') {
            minWidth = +a[i++];
        }
        else if (minWidth.charAt(0) == '*') {
            minWidth = +a[minWidth.slice(1, -1)];
        }
        else {
            minWidth = +minWidth;
        }
        if (minWidth < 0) {
            minWidth = -minWidth;
            leftJustify = true;
        }
        if (!isFinite(minWidth)) {
            throw new Error('sprintf: (minimum-)width must be finite');
        }
        if (!precision) {
            precision = 'fFeE'.indexOf(type) > -1 ? 6 : (type === 'd') ? 0 : undefined;
        }
        else if (precision === '*') {
            precision = +a[i++];
        }
        else if (precision.charAt(0) == '*') {
            precision = +a[precision.slice(1, -1)];
        }
        else {
            precision = +precision;
        }
        value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];
        switch (type) {
            case 's':
                return formatString(String(value), leftJustify, minWidth, precision, zeroPad, customPadChar);
            case 'c':
                return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad);
            case 'b':
                return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'o':
                return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'x':
                return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'X':
                return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad)
                    .toUpperCase();
            case 'u':
                return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad);
            case 'i':
            case 'd':
                number = +value || 0;
                number = Math.round(number - number % 1);
                prefix = number < 0 ? '-' : positivePrefix;
                value = prefix + pad(String(Math.abs(number)), precision, '0', false);
                return justify(value, prefix, leftJustify, minWidth, zeroPad);
            case 'e':
            case 'E':
            case 'f':
            case 'F':
            case 'g':
            case 'G':
                number = +value;
                prefix = number < 0 ? '-' : positivePrefix;
                method = ['toExponential', 'toFixed', 'toPrecision']['efg'.indexOf(type.toLowerCase())];
                textTransform = ['toString', 'toUpperCase']['eEfFgG'.indexOf(type) % 2];
                value = prefix + Math.abs(number)[method](precision);
                return justify(value, prefix, leftJustify, minWidth, zeroPad)[textTransform]();
            default:
                return substring;
        }
    };
    return format.replace(regex, doFormat);
}
function printf() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    console.log(sprintf.apply(sprintf, arguments));
}
function String_repeat(str, num) {
    return new Array(num + 1).join(str);
}
var Endian;
(function (Endian) {
    Endian[Endian["LITTLE"] = 0] = "LITTLE";
    Endian[Endian["BIG"] = 1] = "BIG";
})(Endian || (Endian = {}));
var AsyncEntry = (function () {
    function AsyncEntry(id, size, usageCount, value, lastUsedTime) {
        this.id = id;
        this.size = size;
        this.usageCount = usageCount;
        this.value = value;
        this.lastUsedTime = lastUsedTime;
    }
    return AsyncEntry;
})();
var AsyncCache = (function () {
    function AsyncCache(maxSize, measure) {
        if (maxSize === void 0) { maxSize = 16; }
        this.maxSize = maxSize;
        this.measure = measure;
        this.itemsMap = {};
        if (!measure)
            measure = (function (item) { return 1; });
    }
    Object.defineProperty(AsyncCache.prototype, "items", {
        get: function () {
            var items = [];
            for (var key in this.itemsMap) {
                var item = this.itemsMap[key];
                if (item instanceof AsyncEntry)
                    items.push(item);
            }
            return items;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AsyncCache.prototype, "usedSize", {
        get: function () {
            return this.items.sum(function (item) { return item.size; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AsyncCache.prototype, "availableSize", {
        get: function () {
            return this.maxSize - this.usedSize;
        },
        enumerable: true,
        configurable: true
    });
    AsyncCache.prototype.freeUntilAvailable = function (size) {
        if (size > this.maxSize)
            throw (new Error("Element too big"));
        while (this.availableSize < size) {
            var itemToDelete = this.items.min(function (item) { return item.lastUsedTime; });
            delete this.itemsMap[itemToDelete.id];
        }
    };
    AsyncCache.prototype.getOrGenerateAsync = function (id, generator) {
        var _this = this;
        var item = this.itemsMap[id];
        if (item) {
            item.lastUsedTime = Date.now();
            return Promise2.resolve(item.value);
        }
        else {
            return generator().then(function (value) {
                var size = _this.measure(value);
                _this.freeUntilAvailable(size);
                _this.itemsMap[id] = new AsyncEntry(id, size, 1, value, Date.now());
                return value;
            });
        }
    };
    return AsyncCache;
})();
var SortedSet = (function () {
    function SortedSet() {
        this.elements = [];
    }
    SortedSet.prototype.has = function (element) {
        return this.elements.indexOf(element) >= 0;
    };
    SortedSet.prototype.add = function (element) {
        if (!this.has(element))
            this.elements.push(element);
        return element;
    };
    Object.defineProperty(SortedSet.prototype, "length", {
        get: function () { return this.elements.length; },
        enumerable: true,
        configurable: true
    });
    SortedSet.prototype.delete = function (element) {
        this.elements.remove(element);
    };
    SortedSet.prototype.filter = function (callback) {
        return this.elements.filter(callback);
    };
    SortedSet.prototype.forEach = function (callback) {
        this.elements.forEach(callback);
    };
    return SortedSet;
})();
var DSet = (function (_super) {
    __extends(DSet, _super);
    function DSet() {
        _super.apply(this, arguments);
    }
    return DSet;
})(SortedSet);
var Pool = (function () {
    function Pool() {
    }
    return Pool;
})();
var UidCollection = (function () {
    function UidCollection(lastId) {
        if (lastId === void 0) { lastId = 1; }
        this.lastId = lastId;
        this.items = {};
    }
    UidCollection.prototype.allocate = function (item) {
        var id = this.lastId++;
        this.items[id] = item;
        return id;
    };
    UidCollection.prototype.has = function (id) {
        return (this.items[id] !== undefined);
    };
    UidCollection.prototype.get = function (id) {
        return this.items[id];
    };
    UidCollection.prototype.list = function () {
        var out = [];
        for (var key in this.items)
            out.push(this.items[key]);
        return out;
    };
    UidCollection.prototype.remove = function (id) {
        delete this.items[id];
    };
    return UidCollection;
})();
String.prototype.startsWith = function (value) {
    var string = this;
    return string.substr(0, value.length) == value;
};
String.prototype.endsWith = function (value) {
    var string = this;
    return string.substr(-value.length) == value;
};
String.prototype.rstrip = function () {
    var string = this;
    return string.replace(/\s+$/, '');
};
String.prototype.contains = function (value) {
    var string = this;
    return string.indexOf(value) >= 0;
};
var Microtask = (function () {
    function Microtask() {
    }
    Microtask.queue = function (callback) {
        Microtask.callbacks.push(callback);
        if (!Microtask.queued) {
            Microtask.queued = true;
            setTimeout(Microtask.execute, 0);
        }
    };
    Microtask.execute = function () {
        var start = performance.now();
        while (Microtask.callbacks.length > 0) {
            var callback = Microtask.callbacks.shift();
            callback();
            var end = performance.now();
            if ((end - start) >= 20) {
                setTimeout(Microtask.execute, 0);
                return;
            }
        }
        Microtask.queued = false;
    };
    Microtask.queued = false;
    Microtask.callbacks = [];
    return Microtask;
})();
var _self = self;
_self['polyfills'] = _self['polyfills'] || {};
_self['polyfills']['ArrayBuffer_slice'] = !ArrayBuffer.prototype.slice;
_self['polyfills']['performance'] = !self.performance;
if (!self['performance']) {
    self['performance'] = {};
    self['performance']['now'] = function () {
        return Date.now();
    };
}
var Utf8 = (function () {
    function Utf8() {
    }
    Utf8.decode = function (input) {
        try {
            return decodeURIComponent(escape(input));
        }
        catch (e) {
            console.error(e);
            return input;
        }
    };
    Utf8.encode = function (input) {
        return unescape(encodeURIComponent(input));
    };
    return Utf8;
})();
if (!ArrayBuffer.prototype.slice) {
    ArrayBuffer.prototype.slice = function (begin, end) {
        var that = new Uint8Array(this);
        if (end == undefined)
            end = that.length;
        var result = new ArrayBuffer(end - begin);
        var resultArray = new Uint8Array(result);
        for (var i = 0; i < resultArray.length; i++)
            resultArray[i] = that[i + begin];
        return result;
    };
}
var _self = (typeof window != 'undefined') ? window : self;
_self['AudioContext'] = _self['AudioContext'] || _self['webkitAudioContext'];
_self.navigator['getGamepads'] = _self.navigator['getGamepads'] || _self.navigator['webkitGetGamepads'];
if (!_self.requestAnimationFrame) {
    _self.requestAnimationFrame = function (callback) {
        var start = Date.now();
        return setTimeout(function () {
            callback(Date.now());
        }, 20);
    };
    _self.cancelAnimationFrame = function (id) {
        clearTimeout(id);
    };
}
var ArrayBufferUtils = (function () {
    function ArrayBufferUtils() {
    }
    ArrayBufferUtils.fromUInt8Array = function (input) {
        return input.buffer.slice(input.byteOffset, input.byteOffset + input.byteLength);
    };
    ArrayBufferUtils.uint8ToUint32 = function (input, offset, length) {
        if (offset === void 0) { offset = 0; }
        if (length === undefined)
            length = ((input.length >>> 2) - (offset >>> 2));
        return new Uint32Array(input.buffer, input.byteOffset + offset, length);
    };
    ArrayBufferUtils.uint8ToUint8 = function (input, offset, length) {
        if (offset === void 0) { offset = 0; }
        if (length === undefined)
            length = (input.length - offset);
        return new Uint8Array(input.buffer, input.byteOffset + offset, length);
    };
    ArrayBufferUtils.copy = function (input, inputPosition, output, outputPosition, length) {
        output.subarray(outputPosition, outputPosition + length).set(input.subarray(inputPosition, inputPosition + length));
    };
    ArrayBufferUtils.cloneBytes = function (input) {
        var out = new Uint8Array(input.length);
        out.set(input);
        return out;
    };
    ArrayBufferUtils.concat = function (chunks) {
        var tmp = new Uint8Array(chunks.sum(function (chunk) { return chunk.byteLength; }));
        var offset = 0;
        chunks.forEach(function (chunk) {
            tmp.set(new Uint8Array(chunk), offset);
            offset += chunk.byteLength;
        });
        return tmp.buffer;
    };
    return ArrayBufferUtils;
})();
var PromiseUtils = (function () {
    function PromiseUtils() {
    }
    PromiseUtils.sequence = function (generators) {
        return new Promise2(function (resolve, reject) {
            generators = generators.slice(0);
            function step() {
                if (generators.length > 0) {
                    var generator = generators.shift();
                    var promise = generator();
                    promise.then(step);
                }
                else {
                    resolve();
                }
            }
            step();
        });
    };
    PromiseUtils.delayAsync = function (ms) {
        if (ms <= 0)
            return Promise2.resolve(null);
        return new Promise2(function (resolve, reject) { return setTimeout(resolve, ms); });
    };
    PromiseUtils.delaySecondsAsync = function (seconds) {
        return PromiseUtils.delayAsync(seconds * 1000);
    };
    return PromiseUtils;
})();
_self['requestFileSystem'] = _self['requestFileSystem'] || _self['webkitRequestFileSystem'];
function setToString(Enum, value) {
    var items = [];
    for (var key in Enum) {
        if (Enum[key] & value && (Enum[key] & value) == Enum[key]) {
            items.push(key);
        }
    }
    return items.join(' | ');
}
var AcceptCallbacks;
(function (AcceptCallbacks) {
    AcceptCallbacks[AcceptCallbacks["NO"] = 0] = "NO";
    AcceptCallbacks[AcceptCallbacks["YES"] = 1] = "YES";
})(AcceptCallbacks || (AcceptCallbacks = {}));
var Compensate;
(function (Compensate) {
    Compensate[Compensate["NO"] = 0] = "NO";
    Compensate[Compensate["YES"] = 1] = "YES";
})(Compensate || (Compensate = {}));
var WaitingThreadInfo = (function () {
    function WaitingThreadInfo(name, object, promise, callbacks, compensate) {
        if (compensate === void 0) { compensate = Compensate.YES; }
        this.name = name;
        this.object = object;
        this.promise = promise;
        this.callbacks = callbacks;
        this.compensate = compensate;
    }
    return WaitingThreadInfo;
})();
window.WaitingThreadInfo = WaitingThreadInfo;
var DebugOnceArray = {};
function DebugOnce(name, times) {
    if (times === void 0) { times = 1; }
    if (DebugOnceArray[name] >= times)
        return false;
    if (DebugOnceArray[name]) {
        DebugOnceArray[name]++;
    }
    else {
        DebugOnceArray[name] = 1;
    }
    return true;
}
function isTouchDevice() {
    return 'ontouchstart' in window;
}
var HalfFloat = (function () {
    function HalfFloat() {
    }
    HalfFloat.fromFloat = function (Float) {
        var i = MathFloat.reinterpretFloatAsInt(Float);
        var s = ((i >> 16) & 0x00008000);
        var e = ((i >> 23) & 0x000000ff) - (127 - 15);
        var f = ((i >> 0) & 0x007fffff);
        if (e <= 0) {
            if (e < -10) {
                if (s != 0) {
                    return 0x8000;
                }
                return 0;
            }
            f = (f | 0x00800000) >> (1 - e);
            return s | (f >> 13);
        }
        else if (e == 0xff - (127 - 15)) {
            if (f == 0) {
                return s | 0x7c00;
            }
            f >>= 13;
            return s | 0x7c00 | f | ((f == 0) ? 1 : 0);
        }
        if (e > 30) {
            return s | 0x7c00;
        }
        return s | (e << 10) | (f >> 13);
    };
    HalfFloat.toFloat = function (imm16) {
        var s = (imm16 >> 15) & 0x00000001;
        var e = (imm16 >> 10) & 0x0000001f;
        var f = (imm16 >> 0) & 0x000003ff;
        if (e == 0) {
            if (f == 0) {
                return MathFloat.reinterpretIntAsFloat(s << 31);
            }
            while ((f & 0x00000400) == 0) {
                f <<= 1;
                e -= 1;
            }
            e += 1;
            f &= ~0x00000400;
        }
        else if (e == 31) {
            if (f == 0) {
                return MathFloat.reinterpretIntAsFloat((s << 31) | 0x7f800000);
            }
            return MathFloat.reinterpretIntAsFloat((s << 31) | 0x7f800000 | (f << 13));
        }
        e = e + (127 - 15);
        f = f << 13;
        return MathFloat.reinterpretIntAsFloat((s << 31) | (e << 23) | f);
    };
    return HalfFloat;
})();
function htmlspecialchars(str) {
    return str.replace(/[&<>]/g, function (tag) {
        switch (tag) {
            case '&': return '&amp;';
            case '<': return '&lt;';
            case '>': return '&gt;';
        }
        return tag;
    });
}
function mac2string(mac) {
    return sprintf("%02x:%02x:%02x:%02x:%02x:%02x", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
}
function string2mac(string) {
    var array = String(string).split(':').map(function (item) { return parseInt(item, 16); });
    while (array.length < 6)
        array.push(0);
    return new Uint8Array(array);
}
var SignalCancelable = (function () {
    function SignalCancelable(signal, callback) {
        this.signal = signal;
        this.callback = callback;
    }
    SignalCancelable.prototype.cancel = function () {
        this.signal.remove(this.callback);
    };
    return SignalCancelable;
})();
var Signal = (function () {
    function Signal() {
        this.callbacks = [];
    }
    Object.defineProperty(Signal.prototype, "length", {
        get: function () {
            return this.callbacks.length;
        },
        enumerable: true,
        configurable: true
    });
    Signal.prototype.add = function (callback) {
        this.callbacks.push(callback);
        return new SignalCancelable(this, callback);
    };
    Signal.prototype.remove = function (callback) {
        var index = this.callbacks.indexOf(callback);
        if (index >= 0) {
            this.callbacks.splice(index, 1);
        }
    };
    Signal.prototype.once = function (callback) {
        var _this = this;
        var once = function () {
            _this.remove(once);
            callback();
        };
        this.add(once);
        return new SignalCancelable(this, once);
    };
    Signal.prototype.dispatch = function (value) {
        this.callbacks.forEach(function (callback) {
            callback(value);
        });
    };
    return Signal;
})();
var Logger = (function () {
    function Logger(policy, console, name) {
        this.policy = policy;
        this.console = console;
        this.name = name;
    }
    Logger.prototype.named = function (name) {
        return new Logger(this.policy, this.console, (this.name + '.' + name).replace(/^\.+/, ''));
    };
    Logger.prototype._log = function (type, level, args) {
        if (this.policy.canLog(this.name, level)) {
            args.unshift(this.name + ':');
            if (this.console[type])
                this.console[type].apply(this.console, args);
        }
    };
    Logger.prototype.debug = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        this._log('debug', 0, args);
    };
    Logger.prototype.log = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        this._log('log', 1, args);
    };
    Logger.prototype.info = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        this._log('info', 2, args);
    };
    Logger.prototype.warn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        this._log('warn', 3, args);
    };
    Logger.prototype.error = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        this._log('error', 4, args);
    };
    Logger.prototype.groupCollapsed = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        this._log('groupCollapsed', 5, args);
    };
    Logger.prototype.groupEnd = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        this._log('groupEnd', 5, args);
    };
    return Logger;
})();
var LoggerPolicies = (function () {
    function LoggerPolicies() {
        this.disableAll = false;
        this.minLogLevel = 1;
    }
    LoggerPolicies.prototype.canLog = function (name, level) {
        if (this.disableAll)
            return false;
        if (level < this.minLogLevel)
            return false;
        return true;
    };
    return LoggerPolicies;
})();
if (typeof global == 'undefined')
    global = window;
var loggerPolicies = new LoggerPolicies();
var logger = new Logger(loggerPolicies, console, '');
global.loggerPolicies = loggerPolicies;
global.logger = logger;
if (typeof window.document != 'undefined') {
    var workers = [];
    var workersJobs = [];
    var lastRequestId = 0;
    var resolvers = {};
    [0, 1].forEach(function (index) {
        var ww = workers[index] = new Worker('jspspemu.js');
        workersJobs[index] = 0;
        console.log('created worker!');
        ww.onmessage = function (event) {
            var requestId = event.data.requestId;
            workersJobs[index]--;
            resolvers[requestId](event.data.args);
            delete resolvers[requestId];
        };
    });
    executeCommandAsync = function (code, args) {
        return new Promise2(function (resolve, reject) {
            var requestId = lastRequestId++;
            resolvers[requestId] = resolve;
            if (workersJobs[0] <= workersJobs[1]) {
                workersJobs[0]++;
                workers[0].postMessage({ code: code, args: args, requestId: requestId }, args);
            }
            else {
                workersJobs[1]++;
                workers[1].postMessage({ code: code, args: args, requestId: requestId }, args);
            }
        });
    };
}
else {
    this.onmessage = function (event) {
        var requestId = event.data.requestId;
        var args = event.data.args;
        try {
            eval(event.data.code);
        }
        catch (e) {
            console.error(e);
            args = [];
        }
        this.postMessage({ requestId: requestId, args: args }, args);
    };
    executeCommandAsync = function (code, args) {
        return new Promise2(function (resolve, reject) {
            try {
                eval(code);
            }
            catch (e) {
                console.error(e);
                args = [];
            }
            resolve(args);
        });
    };
}
function inflateRawArrayBufferAsync(data) {
    return inflateRawAsync(new Uint8Array(data)).then(function (data) { return data.buffer; });
}
function inflateRawAsync(data) {
    return executeCommandAsync("\n\t\tvar zlib = require(\"src/format/zlib\");\n\t\targs[0] = ArrayBufferUtils.fromUInt8Array(zlib.inflate_raw(new Uint8Array(args[0])));\n\t", [ArrayBufferUtils.fromUInt8Array(data)]).then(function (args) {
        if (args.length == 0)
            throw new Error("Can't decode");
        return new Uint8Array(args[0]);
    });
}
function addressToHex(address) {
    return '0x' + addressToHex2(address);
}
function addressToHex2(address) {
    return ('00000000' + (address >>> 0).toString(16)).substr(-8);
}
var Promise2 = (function () {
    function Promise2(callback) {
        this._resolvedValue = null;
        this._rejectedValue = null;
        this._solved = false;
        this._resolvedCallbacks = [];
        this._rejectedCallbacks = [];
        this._rejectedPropagated = false;
        callback(this._resolve.bind(this), this._reject.bind(this));
    }
    Promise2.resolve = function (value) {
        if (value instanceof Promise2)
            return value;
        return new Promise2(function (resolve, reject) { return resolve(value); });
    };
    Promise2.reject = function (error) { return new Promise2(function (resolve, reject) { return reject(error); }); };
    Promise2.all = function (promises) {
        return new Promise2(function (resolve, reject) {
            if (promises.length == 0)
                return resolve();
            var total = promises.length;
            var one = function () {
                total--;
                if (total <= 0)
                    resolve();
            };
            var oneError = function (e) {
                reject(e);
            };
            for (var _i = 0; _i < promises.length; _i++) {
                var p = promises[_i];
                if (p instanceof Promise2) {
                    p.then(one, oneError);
                }
                else {
                    one();
                }
            }
        });
    };
    Promise2.race = function (promises) {
        return new Promise2(function (resolve, reject) {
            if (promises.length == 0)
                return resolve();
            for (var _i = 0; _i < promises.length; _i++) {
                var p = promises[_i];
                if (p instanceof Promise2) {
                    p.then(resolve, reject);
                }
                else {
                    resolve();
                    return;
                }
            }
        });
    };
    Promise2.prototype._resolve = function (value) {
        if (this._solved)
            return;
        this._resolvedValue = value;
        this._solved = true;
        this._queueCheck();
    };
    Promise2.prototype._reject = function (error) {
        if (this._solved)
            return;
        this._rejectedValue = error;
        this._solved = true;
        this._queueCheck();
    };
    Promise2.prototype.then = function (resolved, rejected) {
        var _this = this;
        var promise = new Promise2(function (resolve, reject) {
            if (resolved) {
                _this._resolvedCallbacks.push(function (a) {
                    try {
                        var result = resolved(a);
                        if (result instanceof Promise2) {
                            result.then(resolve, reject);
                        }
                        else {
                            resolve(result);
                        }
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            }
            else {
                _this._resolvedCallbacks.push(resolve);
            }
            if (rejected) {
                _this._rejectedCallbacks.push(function (a) {
                    try {
                        var result = rejected(a);
                        if (result instanceof Promise2) {
                            result.then(resolve, reject);
                        }
                        else {
                            resolve(result);
                        }
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            }
            else {
                _this._rejectedCallbacks.push(reject);
            }
        });
        this._queueCheck();
        return promise;
    };
    Promise2.prototype.catch = function (rejected) {
        return this.then(null, rejected);
    };
    Promise2.prototype._queueCheck = function () {
        var _this = this;
        Microtask.queue(function () { return _this._check(); });
    };
    Promise2.prototype._check = function () {
        if (!this._solved)
            return;
        if (this._rejectedValue != null) {
            while (this._rejectedCallbacks.length > 0) {
                this._rejectedPropagated = true;
                this._rejectedCallbacks.shift()(this._rejectedValue);
            }
            if (!this._rejectedPropagated) {
            }
        }
        else {
            while (this._resolvedCallbacks.length > 0)
                this._resolvedCallbacks.shift()(this._resolvedValue);
        }
    };
    return Promise2;
})();
window.Promise2 = Promise2;

///<reference path="./math.ts" />
if (typeof global != 'undefined')
    window = global;
if (typeof self != 'undefined')
    window = self;
function identity(a) { return a; }
function funcTrue(a) { return true; }
function compareNumbers(a, b) {
    if (a < b)
        return -1;
    if (a > b)
        return +1;
    return 0;
}
Array.prototype.contains = function (item) {
    return this.indexOf(item) >= 0;
};
Array.prototype.binarySearchValue = function (selector) {
    var array = this;
    var index = array.binarySearchIndex(selector);
    if (index < 0)
        return null;
    return array[index];
};
Array.prototype.binarySearchIndex = function (selector) {
    var array = this;
    var min = 0;
    var max = array.length - 1;
    var step = 0;
    if (array.length == 0)
        return -1;
    while (true) {
        var current = Math.floor((min + max) / 2);
        var item = array[current];
        var result = selector(item);
        if (result == 0) {
            return current;
        }
        if (((current == min) || (current == max))) {
            if (min != max) {
                min = max = current = (current != min) ? min : max;
            }
            else {
                break;
            }
        }
        else {
            if (result < 0) {
                max = current;
            }
            else if (result > 0) {
                min = current;
            }
        }
        step++;
        if (step >= 64)
            throw (new Error("Too much steps"));
    }
    return -1;
};
Array.prototype.min = (function (selector) {
    var array = this;
    if (!selector)
        selector = function (a) { return a; };
    if (array.length == 0)
        return null;
    return array.reduce(function (previous, current) { return (selector(previous) < selector(current) ? previous : current); }, array[0]);
});
Array.prototype.max = (function (selector) {
    var array = this;
    if (!selector)
        selector = function (a) { return a; };
    if (array.length == 0)
        return null;
    return array.reduce(function (previous, current) { return (selector(previous) > selector(current) ? previous : current); }, array[0]);
});
Array.prototype.sortBy = function (selector) {
    return this.slice(0).sort(function (a, b) { return compare(selector(a), selector(b)); });
};
Array.prototype.cast = (function () {
    return this;
});
Array.prototype.count = (function (selector) {
    var array = this;
    if (!selector)
        selector = funcTrue;
    var result = 0;
    for (var n = 0; n < array.length; n++)
        if (selector(array[n]))
            result++;
    return result;
});
Array.prototype.any = (function (selector) {
    var array = this;
    if (!selector)
        selector = funcTrue;
    for (var n = 0; n < array.length; n++)
        if (selector(array[n]))
            return true;
    return false;
});
Array.prototype.first = (function (selector) {
    var array = this;
    if (!selector)
        selector = identity;
    for (var n = 0; n < array.length; n++)
        if (selector(array[n]))
            return array[n];
    return undefined;
});
Array.prototype.sum = (function (selector) {
    var array = this;
    if (!selector)
        selector = function (a) { return a; };
    return array.reduce(function (previous, current) { return previous + selector(current); }, 0);
});
Array.prototype.remove = function (item) {
    var array = this;
    var index = array.indexOf(item);
    if (index >= 0)
        array.splice(index, 1);
};
Array.prototype.toLookupMap = function () {
    var array = this;
    var lookup = {};
    for (var n = 0; n < array.length; n++) {
        lookup[array[n]] = n;
    }
    return lookup;
};
Object.defineProperty(Array.prototype, "contains", { enumerable: false });
Object.defineProperty(Array.prototype, "toLookupMap", { enumerable: false });
Object.defineProperty(Array.prototype, "cast", { enumerable: false });
Object.defineProperty(Array.prototype, "count", { enumerable: false });
Object.defineProperty(Array.prototype, "any", { enumerable: false });
Object.defineProperty(Array.prototype, "sum", { enumerable: false });
Object.defineProperty(Array.prototype, "min", { enumerable: false });
Object.defineProperty(Array.prototype, "max", { enumerable: false });
Object.defineProperty(Array.prototype, "sortBy", { enumerable: false });
Object.defineProperty(Array.prototype, "first", { enumerable: false });
Object.defineProperty(Array.prototype, "remove", { enumerable: false });
Object.defineProperty(Array.prototype, "binarySearchValue", { enumerable: false });
Object.defineProperty(Array.prototype, "binarySearchIndex", { enumerable: false });

if (typeof global != 'undefined')
    window = global;
if (typeof self != 'undefined')
    window = self;
function waitAsync(timems) {
    return new Promise2(function (resolve, reject) {
        setTimeout(resolve, timems);
    });
}
function immediateAsync() {
    return new Promise2(function (resolve, reject) {
        Microtask.queue(resolve);
    });
}
function _downloadFileAsync(method, url, headers) {
    return new Promise2(function (resolve, reject) {
        var request = new XMLHttpRequest();
        request.open(method, url, true);
        request.overrideMimeType("text/plain; charset=x-user-defined");
        if (headers) {
            for (var headerKey in headers) {
                request.setRequestHeader(headerKey, headers[headerKey]);
            }
        }
        request.responseType = "arraybuffer";
        request.onerror = function (e) { reject(e['error']); };
        request.onload = function (e) {
            if (request.status < 400) {
                resolve(request);
            }
            else {
                reject(new Error("HTTP " + request.status));
            }
        };
        request.send();
    });
}
function toArrayBuffer(buffer) {
    var ab = new ArrayBuffer(buffer.length);
    var view = new Uint8Array(ab);
    for (var i = 0; i < buffer.length; ++i) {
        view[i] = buffer[i];
    }
    return ab;
}
function downloadFileAsync(url, headers) {
    if (typeof XMLHttpRequest == 'undefined') {
        return new Promise2(function (resolve, reject) {
            fs.readFile(url, function (err, data) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(toArrayBuffer(data));
                }
            });
        });
    }
    else {
        return _downloadFileAsync('GET', url, headers).then(function (request) {
            var arraybuffer = request.response;
            return arraybuffer;
        });
    }
}
function downloadFileChunkAsync(url, from, count) {
    var to = (from + count) - 1;
    return downloadFileAsync(url, {
        'Range': 'bytes=' + from + '-' + to
    });
}
function statFileAsync(url) {
    return _downloadFileAsync('HEAD', url).then(function (request) {
        //console.error('content-type', request.getResponseHeader('content-type'));
        //console.log(request.getAllResponseHeaders());
        var size = parseInt(request.getResponseHeader('content-length'));
        var date = new Date(Date.parse(request.getResponseHeader('last-modified')));
        return { size: size, date: date };
    });
}

var Integer64 = (function () {
    function Integer64(low, high) {
        this._low = low | 0;
        this._high = high | 0;
    }
    Integer64.fromInt = function (value) {
        return new Integer64(value | 0, value < 0 ? -1 : 0);
    };
    Integer64.fromUnsignedInt = function (value) {
        return new Integer64(value | 0, 0);
    };
    Integer64.fromBits = function (low, high) {
        return new Integer64(low, high);
    };
    Integer64.fromNumber = function (value) {
        if (isNaN(value) || !isFinite(value)) {
            return Integer64.ZERO;
        }
        else if (value <= -Integer64._TWO_PWR_63_DBL) {
            return Integer64.MIN_VALUE;
        }
        else if (value + 1 >= Integer64._TWO_PWR_63_DBL) {
            return Integer64.MAX_VALUE;
        }
        else if (value < 0) {
            return Integer64.fromNumber(-value).negate();
        }
        else {
            return new Integer64((value % Integer64._TWO_PWR_32_DBL) | 0, (value / Integer64._TWO_PWR_32_DBL) | 0);
        }
    };
    Object.defineProperty(Integer64.prototype, "low", {
        get: function () { return this._low; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Integer64.prototype, "lowUnsigned", {
        get: function () { return (this._low >= 0) ? (this._low) : (Integer64._TWO_PWR_32_DBL + this._low); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Integer64.prototype, "high", {
        get: function () { return this._high; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Integer64.prototype, "number", {
        get: function () {
            return this._high * Integer64._TWO_PWR_32_DBL + this.lowUnsigned;
        },
        enumerable: true,
        configurable: true
    });
    Integer64.prototype.getNumber = function () {
        return this._high * Integer64._TWO_PWR_32_DBL + this.lowUnsigned;
    };
    Integer64.prototype.equals = function (other) {
        return (this._high == other._high) && (this._low == other._low);
    };
    Integer64.prototype.negate = function () {
        if (this.equals(Integer64.MIN_VALUE))
            return Integer64.MIN_VALUE;
        return this.not().add(Integer64.ONE);
    };
    Integer64.prototype.not = function () {
        return Integer64.fromBits(~this._low, ~this._high);
    };
    Integer64.prototype.isZero = function () {
        return this._high == 0 && this._low == 0;
    };
    Integer64.prototype.isNegative = function () {
        return this._high < 0;
    };
    Integer64.prototype.isOdd = function () {
        return (this._low & 1) == 1;
    };
    Integer64.prototype.sub = function (other) {
        return this.add(other.negate());
    };
    Integer64.prototype.add = function (other) {
        var a48 = this._high >>> 16;
        var a32 = this._high & 0xFFFF;
        var a16 = this._low >>> 16;
        var a00 = this._low & 0xFFFF;
        var b48 = other._high >>> 16;
        var b32 = other._high & 0xFFFF;
        var b16 = other._low >>> 16;
        var b00 = other._low & 0xFFFF;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return Integer64.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
    };
    Integer64.prototype.lessThan = function (other) {
        return this.compare(other) < 0;
    };
    Integer64.prototype.compare = function (other) {
        if (this.equals(other)) {
            return 0;
        }
        var thisNeg = this.isNegative();
        var otherNeg = other.isNegative();
        if (thisNeg && !otherNeg) {
            return -1;
        }
        if (!thisNeg && otherNeg) {
            return 1;
        }
        if (this.sub(other).isNegative()) {
            return -1;
        }
        else {
            return 1;
        }
    };
    Integer64.prototype.isLowEnoughForMul = function () {
        if (this._high == 0 && (this._low >>> 0) < Integer64._TWO_PWR_23_DBL)
            return true;
        if (this._high == -1 && ((-this._low) >>> 0) < Integer64._TWO_PWR_23_DBL)
            return true;
        return false;
    };
    Integer64.prototype.multiply = function (other) {
        if (this.isZero())
            return Integer64.ZERO;
        if (other.isZero())
            return Integer64.ZERO;
        if (this.isLowEnoughForMul() && other.isLowEnoughForMul()) {
            return Integer64.fromNumber(this.getNumber() * other.getNumber());
        }
        if (this.equals(Integer64.MIN_VALUE))
            return other.isOdd() ? Integer64.MIN_VALUE : Integer64.ZERO;
        if (other.equals(Integer64.MIN_VALUE))
            return this.isOdd() ? Integer64.MIN_VALUE : Integer64.ZERO;
        if (this.isNegative()) {
            if (other.isNegative())
                return this.negate().multiply(other.negate());
            return this.negate().multiply(other).negate();
        }
        if (other.isNegative())
            return this.multiply(other.negate()).negate();
        var a48 = this._high >>> 16;
        var a32 = this._high & 0xFFFF;
        var a16 = this._low >>> 16;
        var a00 = this._low & 0xFFFF;
        var b48 = other._high >>> 16;
        var b32 = other._high & 0xFFFF;
        var b16 = other._low >>> 16;
        var b00 = other._low & 0xFFFF;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return Integer64.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
    };
    Integer64.ZERO = Integer64.fromInt(0);
    Integer64.ONE = Integer64.fromInt(1);
    Integer64.MIN_VALUE = Integer64.fromBits(0, 0x80000000 | 0);
    Integer64.MAX_VALUE = Integer64.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);
    Integer64._TWO_PWR_16_DBL = Math.pow(2, 16);
    Integer64._TWO_PWR_23_DBL = Math.pow(2, 23);
    Integer64._TWO_PWR_24_DBL = Math.pow(2, 24);
    Integer64._TWO_PWR_32_DBL = Math.pow(2, 32);
    Integer64._TWO_PWR_63_DBL = Math.pow(2, 63);
    Integer64._TWO_PWR_24 = Integer64.fromInt(1 << 24);
    return Integer64;
})();

if (typeof global != 'undefined')
    window = global;
if (typeof self != 'undefined')
    window = self;
var mat4 = (function () {
    function mat4() {
    }
    mat4.create = function () {
        return new Float32Array([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ]);
    };
    mat4.identity = function (data) {
        data[0] = 1;
        data[1] = 0;
        data[2] = 0;
        data[3] = 0;
        data[4] = 0;
        data[5] = 1;
        data[6] = 0;
        data[7] = 0;
        data[8] = 0;
        data[9] = 0;
        data[10] = 1;
        data[11] = 0;
        data[12] = 0;
        data[13] = 0;
        data[14] = 0;
        data[15] = 1;
    };
    mat4.ortho = function (out, left, right, bottom, top, near, far) {
        var lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
        out[0] = -2 * lr;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = -2 * bt;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 2 * nf;
        out[11] = 0;
        out[12] = (left + right) * lr;
        out[13] = (top + bottom) * bt;
        out[14] = (far + near) * nf;
        out[15] = 1;
        return out;
    };
    mat4.multiply = function (out, a, b) {
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
        var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
        out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b[4];
        b1 = b[5];
        b2 = b[6];
        b3 = b[7];
        out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b[8];
        b1 = b[9];
        b2 = b[10];
        b3 = b[11];
        out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        b0 = b[12];
        b1 = b[13];
        b2 = b[14];
        b3 = b[15];
        out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        return out;
    };
    mat4.scale = function (out, a, v) {
        var x = v[0], y = v[1], z = v[2];
        out[0] = a[0] * x;
        out[1] = a[1] * x;
        out[2] = a[2] * x;
        out[3] = a[3] * x;
        out[4] = a[4] * y;
        out[5] = a[5] * y;
        out[6] = a[6] * y;
        out[7] = a[7] * y;
        out[8] = a[8] * z;
        out[9] = a[9] * z;
        out[10] = a[10] * z;
        out[11] = a[11] * z;
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
        return out;
    };
    mat4.translate = function (out, a, v) {
        var x = v[0], y = v[1], z = v[2], a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
        if (a === out) {
            out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
            out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
            out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
            out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
        }
        else {
            a00 = a[0];
            a01 = a[1];
            a02 = a[2];
            a03 = a[3];
            a10 = a[4];
            a11 = a[5];
            a12 = a[6];
            a13 = a[7];
            a20 = a[8];
            a21 = a[9];
            a22 = a[10];
            a23 = a[11];
            out[0] = a00;
            out[1] = a01;
            out[2] = a02;
            out[3] = a03;
            out[4] = a10;
            out[5] = a11;
            out[6] = a12;
            out[7] = a13;
            out[8] = a20;
            out[9] = a21;
            out[10] = a22;
            out[11] = a23;
            out[12] = a00 * x + a10 * y + a20 * z + a[12];
            out[13] = a01 * x + a11 * y + a21 * z + a[13];
            out[14] = a02 * x + a12 * y + a22 * z + a[14];
            out[15] = a03 * x + a13 * y + a23 * z + a[15];
        }
        return out;
    };
    return mat4;
})();
if (typeof self == 'undefined')
    window = self = global;
if (typeof navigator == 'undefined')
    navigator = {};
var _self = self;
_self['polyfills'] = _self['polyfills'] || {};
_self['polyfills']['log2'] = !Math['log2'];
if (!Math.log2) {
    Math.log2 = function (x) { return Math.log(x) / Math.LN2; };
}
_self['polyfills']['log10'] = !Math['log10'];
if (!Math.log10) {
    Math.log10 = function (x) { return Math.log(x) / Math.LN10; };
}
_self['polyfills']['sign'] = !Math['sign'];
if (!Math['sign']) {
    Math['sign'] = function (x) {
        if (x < 0)
            return -1;
        if (x > 0)
            return +1;
        return 0;
    };
}
_self['polyfills']['rint'] = !Math['rint'];
if (!Math['rint']) {
    Math['rint'] = function (value) {
        var twoToThe52 = Math.pow(2, 52);
        var sign = Math.sign(value);
        value = Math.abs(value);
        if (value < twoToThe52)
            value = ((twoToThe52 + value) - twoToThe52);
        return sign * value;
    };
}
_self['polyfills']['clz32'] = !Math['clz32'];
if (!Math['clz32']) {
    Math['clz32'] = function (x) {
        x >>>= 0;
        if (x == 0)
            return 32;
        var result = 0;
        if ((x & 0xFFFF0000) === 0) {
            x <<= 16;
            result += 16;
        }
        if ((x & 0xFF000000) === 0) {
            x <<= 8;
            result += 8;
        }
        if ((x & 0xF0000000) === 0) {
            x <<= 4;
            result += 4;
        }
        if ((x & 0xC0000000) === 0) {
            x <<= 2;
            result += 2;
        }
        if ((x & 0x80000000) === 0) {
            x <<= 1;
            result += 1;
        }
        return result;
    };
}
_self['polyfills']['trunc'] = !Math['trunc'];
if (!Math['trunc']) {
    Math['trunc'] = function (x) {
        if (x < 0) {
            return Math.ceil(x) | 0;
        }
        else {
            return Math.floor(x) | 0;
        }
    };
}
_self['polyfills']['imul'] = !Math['imul'];
if (!Math['imul']) {
    Math['imul'] = function (a, b) {
        var ah = (a >>> 16) & 0xffff;
        var al = a & 0xffff;
        var bh = (b >>> 16) & 0xffff;
        var bl = b & 0xffff;
        return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
    };
}
_self['polyfills']['umul32_64'] = !Math['umul32_64'];
if (!Math.umul32_64) {
    Math.umul32_64 = function (a, b, result) {
        if (result === undefined)
            result = [0, 0];
        a >>>= 0;
        b >>>= 0;
        if (a < 32767 && b < 65536) {
            result[0] = a * b;
            result[1] = (result[0] < 0) ? -1 : 0;
            return result;
        }
        var a00 = a & 0xFFFF, a16 = a >>> 16;
        var b00 = b & 0xFFFF, b16 = b >>> 16;
        var c00 = a00 * b00;
        var c16 = (c00 >>> 16) + (a16 * b00);
        var c32 = c16 >>> 16;
        c16 = (c16 & 0xFFFF) + (a00 * b16);
        c32 += c16 >>> 16;
        var c48 = c32 >>> 16;
        c32 = (c32 & 0xFFFF) + (a16 * b16);
        c48 += c32 >>> 16;
        result[0] = ((c16 & 0xFFFF) << 16) | (c00 & 0xFFFF);
        result[1] = ((c48 & 0xFFFF) << 16) | (c32 & 0xFFFF);
        return result;
    };
}
_self['polyfills']['imul32_64'] = !Math['imul32_64'];
if (!Math.imul32_64) {
    Math.imul32_64 = function (a, b, result) {
        if (result === undefined)
            result = [0, 0];
        if (a == 0) {
            result[0] = result[1] = 0;
            return result;
        }
        if (b == 0) {
            result[0] = result[1] = 0;
            return result;
        }
        a |= 0;
        b |= 0;
        if ((a >= -32768 && a <= 32767) && (b >= -32768 && b <= 32767)) {
            result[0] = a * b;
            result[1] = (result[0] < 0) ? -1 : 0;
            return result;
        }
        var doNegate = (a < 0) ^ (b < 0);
        Math.umul32_64(Math.abs(a), Math.abs(b), result);
        if (doNegate) {
            result[0] = ~result[0];
            result[1] = ~result[1];
            result[0] = (result[0] + 1) | 0;
            if (result[0] == 0)
                result[1] = (result[1] + 1) | 0;
        }
        return result;
    };
}
_self['polyfills']['fround'] = !Math['fround'];
if (!Math['fround']) {
    Math['fround'] = function (x) {
        var f32 = new Float32Array(1);
        f32[0] = x;
        return f32[0];
    };
}
var BitUtils = (function () {
    function BitUtils() {
    }
    BitUtils.mask = function (value) {
        return (1 << value) - 1;
    };
    BitUtils.bitrev32 = function (v) {
        v = ((v >>> 1) & 0x55555555) | ((v & 0x55555555) << 1);
        v = ((v >>> 2) & 0x33333333) | ((v & 0x33333333) << 2);
        v = ((v >>> 4) & 0x0F0F0F0F) | ((v & 0x0F0F0F0F) << 4);
        v = ((v >>> 8) & 0x00FF00FF) | ((v & 0x00FF00FF) << 8);
        v = ((v >>> 16) & 0x0000FFFF) | ((v & 0x0000FFFF) << 16);
        return v;
    };
    BitUtils.rotr = function (value, offset) {
        return (value >>> offset) | (value << (32 - offset));
    };
    BitUtils.clo = function (x) {
        return Math['clz32'](~x);
    };
    BitUtils.clz = function (x) {
        return Math['clz32'](x);
    };
    BitUtils.seb = function (x) {
        x = x & 0xFF;
        if ((x & 0x80) != 0)
            x = 0xFFFFFF00 | x;
        return x;
    };
    BitUtils.seh = function (x) {
        return (((x & 0xFFFF) << 16) >> 16);
    };
    BitUtils.wsbh = function (v) {
        return ((v & 0xFF00FF00) >>> 8) | ((v & 0x00FF00FF) << 8);
    };
    BitUtils.wsbw = function (v) {
        return (((v & 0xFF000000) >>> 24) |
            ((v & 0x00FF0000) >>> 8) |
            ((v & 0x0000FF00) << 8) |
            ((v & 0x000000FF) << 24));
    };
    BitUtils.extract = function (data, offset, length) {
        return (data >> offset) & ((1 << length) - 1);
    };
    BitUtils.extractBool = function (data, offset) {
        return (this.extract(data, offset, 1) != 0);
    };
    BitUtils.extractSigned = function (data, offset, length) {
        var mask = this.mask(length);
        var value = this.extract(data, offset, length);
        var signBit = (1 << (offset + (length - 1)));
        if ((value & signBit) != 0)
            value |= ~mask;
        return value;
    };
    BitUtils.extractScale1f = function (data, offset, length) {
        var mask = (1 << length) - 1;
        return (((data >>> offset) & mask) / mask);
    };
    BitUtils.extractScalef = function (data, offset, length, scale) {
        return BitUtils.extractScale1f(data, offset, length) * scale;
    };
    BitUtils.extractScalei = function (data, offset, length, scale) {
        return this.extractScalef(data, offset, length, scale) | 0;
    };
    BitUtils.extractEnum = function (data, offset, length) {
        return this.extract(data, offset, length);
    };
    BitUtils.clear = function (data, offset, length) {
        data &= ~(BitUtils.mask(length) << offset);
        return data;
    };
    BitUtils.insert = function (data, offset, length, value) {
        value &= BitUtils.mask(length);
        data = BitUtils.clear(data, offset, length);
        data |= value << offset;
        return data;
    };
    return BitUtils;
})();
var MathVfpu = (function () {
    function MathVfpu() {
    }
    MathVfpu.vqmul0 = function (s0, s1, s2, s3, t0, t1, t2, t3) { return +(s0 * t3) + (s1 * t2) - (s2 * t1) + (s3 * t0); };
    MathVfpu.vqmul1 = function (s0, s1, s2, s3, t0, t1, t2, t3) { return -(s0 * t2) + (s1 * t3) + (s2 * t0) + (s3 * t1); };
    MathVfpu.vqmul2 = function (s0, s1, s2, s3, t0, t1, t2, t3) { return +(s0 * t1) - (s1 * t0) + (s2 * t3) + (s3 * t2); };
    MathVfpu.vqmul3 = function (s0, s1, s2, s3, t0, t1, t2, t3) { return -(s0 * t0) - (s1 * t1) - (s2 * t2) + (s3 * t3); };
    MathVfpu.vc2i = function (index, value) {
        return (value << ((3 - index) * 8)) & 0xFF000000;
    };
    MathVfpu.vuc2i = function (index, value) {
        return ((((value >>> (index * 8)) & 0xFF) * 0x01010101) >> 1) & ~0x80000000;
    };
    MathVfpu.vs2i = function (index, value) {
        if ((index % 2) == 0)
            value <<= 16;
        return value & 0xFFFF0000;
    };
    MathVfpu.vi2f = function (value, count) {
        return MathFloat.scalb(value, count);
    };
    MathVfpu.vi2uc = function (x, y, z, w) {
        return (0
            | ((x < 0) ? 0 : ((x >>> 23) << 0))
            | ((y < 0) ? 0 : ((y >>> 23) << 8))
            | ((z < 0) ? 0 : ((z >>> 23) << 16))
            | ((w < 0) ? 0 : ((w >>> 23) << 24)));
    };
    MathVfpu.vf2id = function (value, count) {
        return MathFloat.floor(MathFloat.scalb(value, count));
    };
    MathVfpu.vf2in = function (value, count) {
        return MathFloat.rint(MathFloat.scalb(value, count));
    };
    MathVfpu.vf2iu = function (value, count) {
        return MathFloat.ceil(MathFloat.scalb(value, count));
    };
    MathVfpu.vf2iz = function (Value, count) {
        var ScalabValue = MathFloat.scalb(Value, count);
        var DoubleValue = (Value >= 0) ? MathFloat.floor(ScalabValue) : MathFloat.ceil(ScalabValue);
        return isNaN(DoubleValue) ? 0x7FFFFFFF : DoubleValue;
    };
    MathVfpu.vf2h = function () {
        return 0;
    };
    MathVfpu.vh2f = function () {
        return 0;
    };
    return MathVfpu;
})();
var MathFloat = (function () {
    function MathFloat() {
    }
    MathFloat.reinterpretFloatAsInt = function (floatValue) {
        MathFloat.floatArray[0] = floatValue;
        return MathFloat.intArray[0];
    };
    MathFloat.reinterpretIntAsFloat = function (integerValue) {
        MathFloat.intArray[0] = integerValue;
        return MathFloat.floatArray[0];
    };
    MathFloat.scalb = function (value, count) {
        return value * Math.pow(2, count);
    };
    MathFloat.min = function (a, b) { return (a < b) ? a : b; };
    MathFloat.max = function (a, b) { return (a > b) ? a : b; };
    MathFloat.isnan = function (n) { return isNaN(n); };
    MathFloat.isinf = function (n) { return n === n / 0; };
    MathFloat.isnanorinf = function (n) { return MathFloat.isnan(n) || MathFloat.isinf(n); };
    MathFloat.abs = function (value) { return Math.abs(value); };
    MathFloat.neg = function (value) {
        return -value;
    };
    MathFloat.ocp = function (value) { return 1 - value; };
    MathFloat.nrcp = function (value) { return -(1 / value); };
    MathFloat.sat0 = function (value) { return MathUtils.clamp(value, 0, +1); };
    MathFloat.sat1 = function (value) { return MathUtils.clamp(value, -1, +1); };
    MathFloat.rsq = function (value) { return 1 / Math.sqrt(value); };
    MathFloat.sqrt = function (value) { return Math.sqrt(value); };
    MathFloat.rint = function (value) {
        if (!isFinite(value))
            return handleCastInfinite(value);
        return Math.rint(value);
    };
    MathFloat.cast = function (value) {
        if (!isFinite(value))
            return handleCastInfinite(value);
        return (value < 0) ? Math.ceil(value) : Math.floor(value);
    };
    MathFloat.trunc = function (value) {
        if (!isFinite(value))
            return handleCastInfinite(value);
        return Math.trunc(value);
    };
    MathFloat.round = function (value) {
        if (!isFinite(value))
            return handleCastInfinite(value);
        return Math.round(value);
    };
    MathFloat.floor = function (value) {
        if (!isFinite(value))
            return handleCastInfinite(value);
        return Math.floor(value);
    };
    MathFloat.ceil = function (value) {
        if (!isFinite(value))
            return handleCastInfinite(value);
        return Math.ceil(value);
    };
    MathFloat.cosv1 = function (value) { return Math.cos(value * Math.PI * 0.5); };
    MathFloat.sinv1 = function (value) { return Math.sin(value * Math.PI * 0.5); };
    MathFloat.nsinv1 = function (value) { return -Math.sin(value * Math.PI * 0.5); };
    MathFloat.asinv1 = function (value) { return Math.asin(value) / (Math.PI * 0.5); };
    MathFloat.exp2 = function (value) { return Math.pow(2.0, value); };
    MathFloat.rexp2 = function (value) { return 1 / Math.pow(2.0, value); };
    MathFloat.log2 = function (value) { return Math.log2(value); };
    MathFloat.sign = function (value) { return Math.sign(value); };
    MathFloat.sign2 = function (left, right) { var a = left - right; return (((0.0 < a) ? 1 : 0) - ((a < 0.0) ? 1 : 0)); };
    MathFloat.vslt = function (a, b) { if (isNaN(a) || isNaN(b))
        return 0; return (a < b) ? 1 : 0; };
    MathFloat.vsle = function (a, b) { if (isNaN(a) || isNaN(b))
        return 0; return (a <= b) ? 1 : 0; };
    MathFloat.vsgt = function (a, b) { if (isNaN(a) || isNaN(b))
        return 0; return (a > b) ? 1 : 0; };
    MathFloat.vsge = function (a, b) { if (isNaN(a) || isNaN(b))
        return 0; return (a >= b) ? 1 : 0; };
    MathFloat.clamp = function (v, min, max) {
        if (v < min)
            return min;
        if (v > max)
            return max;
        return v;
    };
    MathFloat.reinterpretBuffer = new ArrayBuffer(4);
    MathFloat.floatArray = new Float32Array(MathFloat.reinterpretBuffer);
    MathFloat.intArray = new Int32Array(MathFloat.reinterpretBuffer);
    return MathFloat;
})();
window.BitUtils = BitUtils;
window.MathUtils = MathUtils;
window.MathFloat = MathFloat;
window.MathVfpu = MathVfpu;
function handleCastInfinite(value) {
    return (value < 0) ? -2147483648 : 2147483647;
}
function compare(a, b) {
    if (a < b)
        return -1;
    if (a > b)
        return +1;
    return 0;
}
function parseIntFormat(str) {
    str = str.replace(/_/g, '');
    if (str.substr(0, 2) == '0b')
        return parseInt(str.substr(2), 2);
    if (str.substr(0, 2) == '0x')
        return parseInt(str.substr(2), 16);
    return parseInt(str, 10);
}
var MathUtils = (function () {
    function MathUtils() {
    }
    MathUtils.sextend16 = function (value) {
        return (((value & 0xFFFF) << 16) >> 16);
    };
    MathUtils.prevAligned = function (value, alignment) {
        return Math.floor(value / alignment) * alignment;
    };
    MathUtils.isAlignedTo = function (value, alignment) {
        return (value % alignment) == 0;
    };
    MathUtils.requiredBlocks = function (size, blockSize) {
        if ((size % blockSize) != 0) {
            return (size / blockSize) + 1;
        }
        else {
            return size / blockSize;
        }
    };
    MathUtils.isPowerOfTwo = function (x) {
        return (x != 0) && ((x & (x - 1)) == 0);
    };
    MathUtils.nextAligned = function (value, alignment) {
        if (alignment <= 1)
            return value;
        if ((value % alignment) == 0)
            return value;
        return value + (alignment - (value % alignment));
    };
    MathUtils.clamp = function (v, min, max) {
        if (v < min)
            return min;
        if (v > max)
            return max;
        return v;
    };
    return MathUtils;
})();
var IntUtils = (function () {
    function IntUtils() {
    }
    IntUtils.toHexString = function (value, padCount) {
        var str = (value >>> 0).toString(16);
        while (str.length < padCount)
            str = '0' + str;
        return str;
    };
    return IntUtils;
})();
var StringUtils = (function () {
    function StringUtils() {
    }
    StringUtils.padLeft = function (text, padchar, length) {
        while (text.length < length)
            text = padchar + text;
        return text;
    };
    return StringUtils;
})();
function ToUint32(x) { return x >>> 0; }
function ToInt32(x) { return x | 0; }
var ArrayUtils = (function () {
    function ArrayUtils() {
    }
    ArrayUtils.create2D = function (w, h, generator) {
        if (!generator)
            generator = function (x, y) { return null; };
        var matrix = [];
        for (var y = 0; y < h; y++) {
            var row = [];
            for (var x = 0; x < w; x++) {
                row.push(generator(x, y));
            }
            matrix.push(row);
        }
        return matrix;
    };
    ArrayUtils.range = function (start, end) {
        var array = [];
        for (var n = start; n < end; n++)
            array.push(n);
        return array;
    };
    return ArrayUtils;
})();
function xrange(start, end) {
    return ArrayUtils.range(start, end);
}

undefined
///<reference path="./utils.ts" />
///<reference path="./int64.ts" />
///<reference path="./async.ts" />
///<reference path="./struct.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ProxyAsyncStream = (function () {
    function ProxyAsyncStream(stream) {
        this.stream = stream;
    }
    Object.defineProperty(ProxyAsyncStream.prototype, "name", {
        get: function () { return this.stream.name; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProxyAsyncStream.prototype, "date", {
        get: function () { return this.stream.date; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProxyAsyncStream.prototype, "size", {
        get: function () { return this.stream.size; },
        enumerable: true,
        configurable: true
    });
    ProxyAsyncStream.prototype.readChunkAsync = function (offset, count) { return this.stream.readChunkAsync(offset, count); };
    return ProxyAsyncStream;
})();
var BufferedAsyncStream = (function (_super) {
    __extends(BufferedAsyncStream, _super);
    function BufferedAsyncStream(stream, bufferSize) {
        if (bufferSize === void 0) { bufferSize = 131072; }
        _super.call(this, stream);
        this.bufferSize = bufferSize;
        this.cache = { start: 0, end: 0, data: new ArrayBuffer(0) };
    }
    Object.defineProperty(BufferedAsyncStream.prototype, "name", {
        get: function () { return this.stream.name + '+buffered'; },
        enumerable: true,
        configurable: true
    });
    BufferedAsyncStream.prototype.getCachedEntry = function (start, end) {
        if (start >= this.cache.start && end <= this.cache.end) {
            return this.cache;
        }
        else {
            return null;
        }
    };
    BufferedAsyncStream.prototype.putCacheEntry = function (start, data) {
        this.cache.start = start;
        this.cache.end = start + data.byteLength;
        this.cache.data = data;
    };
    BufferedAsyncStream.prototype.readChunkAsync = function (offset, count) {
        var _this = this;
        var availableFromOffset = this.size - offset;
        var start = offset;
        var end = offset + count;
        var cache = this.getCachedEntry(start, end);
        if (cache) {
            return Promise2.resolve(cache.data.slice(start - cache.start, end - cache.start));
        }
        else {
            var bigCount = Math.max(count, this.bufferSize);
            bigCount = Math.min(bigCount, availableFromOffset);
            end = start + bigCount;
            return this.stream.readChunkAsync(offset, bigCount).then(function (data) {
                _this.putCacheEntry(start, data);
                return _this.readChunkAsync(offset, count);
            });
        }
    };
    return BufferedAsyncStream;
})(ProxyAsyncStream);
var MemoryAsyncStream = (function () {
    function MemoryAsyncStream(data, name, date) {
        if (name === void 0) { name = 'memory'; }
        if (date === void 0) { date = new Date(); }
        this.data = data;
        this.name = name;
        this.date = date;
    }
    MemoryAsyncStream.fromArrayBuffer = function (data) {
        return new MemoryAsyncStream(data);
    };
    Object.defineProperty(MemoryAsyncStream.prototype, "size", {
        get: function () { return this.data.byteLength; },
        enumerable: true,
        configurable: true
    });
    MemoryAsyncStream.prototype.readChunkAsync = function (offset, count) {
        return Promise2.resolve(this.data.slice(offset, offset + count));
    };
    return MemoryAsyncStream;
})();
var UrlAsyncStream = (function () {
    function UrlAsyncStream(url, stat) {
        this.url = url;
        this.stat = stat;
        this.name = url;
        this.date = stat.date;
    }
    UrlAsyncStream.fromUrlAsync = function (url) {
        console.info('open ', url);
        return statFileAsync(url).then(function (stat) {
            console.info('fromUrlAsync', stat);
            if (stat.size == 0) {
                console.error("Invalid file with size '" + stat.size + "'", stat);
                throw (new Error("Invalid file with size '" + stat.size + "'"));
            }
            if (stat.size < 5 * 1024 * 1024) {
                return downloadFileAsync(url).then(function (data) { return MemoryAsyncStream.fromArrayBuffer(data); });
            }
            else {
                return Promise2.resolve(new BufferedAsyncStream(new UrlAsyncStream(url, stat)));
            }
        });
    };
    Object.defineProperty(UrlAsyncStream.prototype, "size", {
        get: function () { return this.stat.size; },
        enumerable: true,
        configurable: true
    });
    UrlAsyncStream.prototype.readChunkAsync = function (offset, count) {
        console.info('download chunk', this.url, offset + '-' + (offset + count), '(' + count + ')');
        return downloadFileChunkAsync(this.url, offset, count);
    };
    return UrlAsyncStream;
})();
var FileAsyncStream = (function () {
    function FileAsyncStream(file) {
        this.file = file;
        this.date = file.lastModifiedDate;
    }
    Object.defineProperty(FileAsyncStream.prototype, "name", {
        get: function () { return this.file.name; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FileAsyncStream.prototype, "size", {
        get: function () { return this.file.size; },
        enumerable: true,
        configurable: true
    });
    FileAsyncStream.prototype.readChunkAsync = function (offset, count) {
        var _this = this;
        return new Promise2(function (resolve, reject) {
            var fileReader = new FileReader();
            fileReader.onload = function (e) { resolve(fileReader.result); };
            fileReader.onerror = function (e) { reject(e['error']); };
            fileReader.readAsArrayBuffer(_this.file.slice(offset, offset + count));
        });
    };
    return FileAsyncStream;
})();
var Stream = (function () {
    function Stream(data, offset) {
        if (offset === void 0) { offset = 0; }
        this.data = data;
        this.offset = offset;
    }
    Stream.fromArrayBuffer = function (data) {
        return new Stream(new DataView(data));
    };
    Stream.fromDataView = function (data, offset) {
        if (offset === void 0) { offset = 0; }
        return new Stream(data);
    };
    Stream.fromBase64 = function (data) {
        var outstr = atob(data);
        var out = new ArrayBuffer(outstr.length);
        var ia = new Uint8Array(out);
        for (var n = 0; n < outstr.length; n++)
            ia[n] = outstr.charCodeAt(n);
        return new Stream(new DataView(out));
    };
    Stream.fromUint8Array = function (array) {
        return Stream.fromArray(array);
    };
    Stream.fromSize = function (size) {
        return Stream.fromUint8Array(new Uint8Array(size));
    };
    Stream.fromArray = function (array) {
        var buffer = new ArrayBuffer(array.length);
        var w8 = new Uint8Array(buffer);
        for (var n = 0; n < array.length; n++)
            w8[n] = array[n];
        return new Stream(new DataView(buffer));
    };
    Stream.prototype.toImageUrl = function () {
        try {
            var urlCreator = window['URL'] || window['webkitURL'];
            var blob = new Blob([this.toUInt8Array()], { type: "image/jpeg" });
            return urlCreator.createObjectURL(blob);
        }
        catch (e) {
            return 'data:image/png;base64,' + this.toBase64();
        }
    };
    Stream.prototype.toBase64 = function () {
        var out = '';
        var array = this.toUInt8Array();
        for (var n = 0; n < array.length; n++) {
            out += String.fromCharCode(array[n]);
        }
        return btoa(out);
    };
    Stream.prototype.toStringAll = function () {
        return this.sliceWithLength(0).readString(this.length);
    };
    Stream.prototype.toUInt8Array = function () {
        return new Uint8Array(this.toArrayBuffer());
    };
    Stream.prototype.toArrayBuffer = function () {
        return this.data.buffer.slice(this.data.byteOffset, this.data.byteOffset + this.data.byteLength);
    };
    Stream.prototype.clone = function () {
        return this.sliceWithLowHigh(this.position, this.length);
    };
    Stream.prototype.slice = function () {
        return this.clone();
    };
    Stream.prototype.sliceFrom = function (low) {
        return this.sliceWithLength(low);
    };
    Stream.prototype.sliceWithLength = function (low, count) {
        if (count === undefined)
            count = this.length - low;
        return new Stream(new DataView(this.data.buffer, this.data.byteOffset + low, count));
    };
    Stream.prototype.sliceWithLowHigh = function (low, high) {
        return new Stream(new DataView(this.data.buffer, this.data.byteOffset + low, high - low));
    };
    Object.defineProperty(Stream.prototype, "available", {
        get: function () {
            return this.length - this.offset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "length", {
        get: function () {
            return this.data.byteLength;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stream.prototype, "position", {
        get: function () {
            return this.offset;
        },
        set: function (value) {
            this.offset = value;
        },
        enumerable: true,
        configurable: true
    });
    Stream.prototype.skip = function (count, pass) {
        this.offset += count;
        return pass;
    };
    Stream.prototype.set = function (index, value) {
        this.data.setInt8(index, value);
        return this;
    };
    Stream.prototype.get = function (index) {
        return this.data.getUint8(index);
    };
    Stream.prototype.readInt8 = function (endian) {
        if (endian === void 0) { endian = Endian.LITTLE; }
        return this.skip(1, this.data.getInt8(this.offset));
    };
    Stream.prototype.readInt16 = function (endian) {
        if (endian === void 0) { endian = Endian.LITTLE; }
        return this.skip(2, this.data.getInt16(this.offset, (endian == Endian.LITTLE)));
    };
    Stream.prototype.readInt32 = function (endian) {
        if (endian === void 0) { endian = Endian.LITTLE; }
        return this.skip(4, this.data.getInt32(this.offset, (endian == Endian.LITTLE)));
    };
    Stream.prototype.readInt64 = function (endian) {
        if (endian === void 0) { endian = Endian.LITTLE; }
        var items = [this.readUInt32(endian), this.readUInt32(endian)];
        var low = items[(endian == Endian.LITTLE) ? 0 : 1];
        var high = items[(endian == Endian.LITTLE) ? 1 : 0];
        return Integer64.fromBits(low, high);
    };
    Stream.prototype.readFloat32 = function (endian) {
        if (endian === void 0) { endian = Endian.LITTLE; }
        return this.skip(4, this.data.getFloat32(this.offset, (endian == Endian.LITTLE)));
    };
    Stream.prototype.readUInt8 = function (endian) {
        if (endian === void 0) { endian = Endian.LITTLE; }
        return this.skip(1, this.data.getUint8(this.offset));
    };
    Stream.prototype.readUInt16 = function (endian) {
        if (endian === void 0) { endian = Endian.LITTLE; }
        return this.skip(2, this.data.getUint16(this.offset, (endian == Endian.LITTLE)));
    };
    Stream.prototype.readUInt32 = function (endian) {
        if (endian === void 0) { endian = Endian.LITTLE; }
        return this.skip(4, this.data.getUint32(this.offset, (endian == Endian.LITTLE)));
    };
    Stream.prototype.readStruct = function (struct) {
        return struct.read(this);
    };
    Stream.prototype.copyTo = function (other) {
        other.writeBytes(this.readBytes(this.available));
    };
    Stream.prototype.writeByteRepeated = function (value, count) {
        if (count === void 0) { count = -1; }
        if (count < 0)
            count = this.available;
        for (var n = 0; n < count; n++)
            this.data.setInt8(this.offset + n, value);
        this.skip(n);
        return this;
    };
    Stream.prototype.writeInt8 = function (value, endian) {
        if (endian === void 0) { endian = Endian.LITTLE; }
        this.data.setInt8(this.offset, value);
        return this.skip(1, this);
    };
    Stream.prototype.writeInt16 = function (value, endian) {
        if (endian === void 0) { endian = Endian.LITTLE; }
        this.data.setInt16(this.offset, value, (endian == Endian.LITTLE));
        return this.skip(2, this);
    };
    Stream.prototype.writeInt32 = function (value, endian) {
        if (endian === void 0) { endian = Endian.LITTLE; }
        this.data.setInt32(this.offset, value, (endian == Endian.LITTLE));
        return this.skip(4, this);
    };
    Stream.prototype.writeInt64 = function (value, endian) {
        if (endian === void 0) { endian = Endian.LITTLE; }
        return this._writeUInt64(value, endian);
    };
    Stream.prototype.writeFloat32 = function (value, endian) {
        if (endian === void 0) { endian = Endian.LITTLE; }
        this.data.setFloat32(this.offset, value, (endian == Endian.LITTLE));
        return this.skip(4, this);
    };
    Stream.prototype.writeUInt8 = function (value, endian) {
        if (endian === void 0) { endian = Endian.LITTLE; }
        this.data.setUint8(this.offset, value);
        return this.skip(1, this);
    };
    Stream.prototype.writeUInt16 = function (value, endian) {
        if (endian === void 0) { endian = Endian.LITTLE; }
        this.data.setUint16(this.offset, value, (endian == Endian.LITTLE));
        return this.skip(2, this);
    };
    Stream.prototype.writeUInt32 = function (value, endian) {
        if (endian === void 0) { endian = Endian.LITTLE; }
        this.data.setUint32(this.offset, value, (endian == Endian.LITTLE));
        return this.skip(4, this);
    };
    Stream.prototype.writeUInt64 = function (value, endian) {
        if (endian === void 0) { endian = Endian.LITTLE; }
        return this._writeUInt64(value, endian);
    };
    Stream.prototype._writeUInt64 = function (value, endian) {
        if (endian === void 0) { endian = Endian.LITTLE; }
        this.writeUInt32((endian == Endian.LITTLE) ? value.low : value.high, endian);
        this.writeUInt32((endian == Endian.LITTLE) ? value.high : value.low, endian);
        return this;
    };
    Stream.prototype.writeStruct = function (struct, value) {
        struct.write(this, value);
    };
    Stream.prototype.writeStream = function (stream) {
        return this.writeBytes(stream.slice().readBytes(stream.available));
    };
    Stream.prototype.writeString = function (str) {
        var _this = this;
        try {
            str.split('').forEach(function (char) {
                _this.writeUInt8(char.charCodeAt(0));
            });
        }
        catch (e) {
            console.log("Can't write string '" + str + "'");
            debugger;
            console.warn(this.data);
            console.error(e);
            throw (e);
        }
    };
    Stream.prototype.writeStringz = function (str) {
        return this.writeString(str + String.fromCharCode(0));
    };
    Stream.prototype.writeBytes = function (data) {
        var out = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
        out.set(data, this.offset);
        this.skip(data.length);
    };
    Stream.prototype.readBytes = function (count) {
        return this.skip(count, new Uint8Array(this.data.buffer, this.data.byteOffset + this.offset, count));
    };
    Stream.prototype.readAllBytes = function () {
        return this.readBytes(this.available);
    };
    Stream.prototype.readInt16Array = function (count) {
        return this.skip(count, new Int16Array(this.data.buffer, this.data.byteOffset + this.offset, count));
    };
    Stream.prototype.readFloat32Array = function (count) {
        return new Float32Array(this.readBytes(count));
    };
    Stream.prototype.readStream = function (count) {
        return Stream.fromUint8Array(this.readBytes(count));
    };
    Stream.prototype.readUtf8String = function (count) {
        return Utf8.decode(this.readString(count));
    };
    Stream.prototype.readString = function (count) {
        if (count > 1 * 1024 * 1024)
            throw (new Error("Trying to read a string larger than 128KB"));
        var str = '';
        for (var n = 0; n < count; n++) {
            str += String.fromCharCode(this.readUInt8());
        }
        return str;
    };
    Stream.prototype.readUtf8Stringz = function (maxCount) {
        if (maxCount === void 0) { maxCount = 131072; }
        return Utf8.decode(this.readStringz(maxCount));
    };
    Stream.prototype.readStringz = function (maxCount) {
        if (maxCount === void 0) { maxCount = 131072; }
        var str = '';
        for (var n = 0; n < maxCount; n++) {
            if (this.available <= 0)
                break;
            var char = this.readUInt8();
            if (char == 0)
                break;
            str += String.fromCharCode(char);
        }
        return str;
    };
    Stream.INVALID = Stream.fromArray([]);
    return Stream;
})();

///<reference path="./utils.ts" />
///<reference path="./stream.ts" />
var Int64Type = (function () {
    function Int64Type(endian) {
        this.endian = endian;
    }
    Int64Type.prototype.read = function (stream) {
        if (this.endian == Endian.LITTLE) {
            var low = stream.readUInt32(this.endian);
            var high = stream.readUInt32(this.endian);
        }
        else {
            var high = stream.readUInt32(this.endian);
            var low = stream.readUInt32(this.endian);
        }
        return high * Math.pow(2, 32) + low;
    };
    Int64Type.prototype.write = function (stream, value) {
        var low = Math.floor(value % Math.pow(2, 32));
        var high = Math.floor(value / Math.pow(2, 32));
        if (this.endian == Endian.LITTLE) {
            stream.writeInt32(low, this.endian);
            stream.writeInt32(high, this.endian);
        }
        else {
            stream.writeInt32(high, this.endian);
            stream.writeInt32(low, this.endian);
        }
    };
    Object.defineProperty(Int64Type.prototype, "length", {
        get: function () { return 8; },
        enumerable: true,
        configurable: true
    });
    return Int64Type;
})();
var Int32Type = (function () {
    function Int32Type(endian) {
        this.endian = endian;
    }
    Int32Type.prototype.read = function (stream) { return stream.readInt32(this.endian); };
    Int32Type.prototype.write = function (stream, value) { stream.writeInt32(value, this.endian); };
    Object.defineProperty(Int32Type.prototype, "length", {
        get: function () { return 4; },
        enumerable: true,
        configurable: true
    });
    return Int32Type;
})();
var Int16Type = (function () {
    function Int16Type(endian) {
        this.endian = endian;
    }
    Int16Type.prototype.read = function (stream) { return stream.readInt16(this.endian); };
    Int16Type.prototype.write = function (stream, value) { stream.writeInt16(value, this.endian); };
    Object.defineProperty(Int16Type.prototype, "length", {
        get: function () { return 2; },
        enumerable: true,
        configurable: true
    });
    return Int16Type;
})();
var Int8Type = (function () {
    function Int8Type(endian) {
        this.endian = endian;
    }
    Int8Type.prototype.read = function (stream) { return stream.readInt8(this.endian); };
    Int8Type.prototype.write = function (stream, value) { stream.writeInt8(value, this.endian); };
    Object.defineProperty(Int8Type.prototype, "length", {
        get: function () { return 1; },
        enumerable: true,
        configurable: true
    });
    return Int8Type;
})();
var UInt32Type = (function () {
    function UInt32Type(endian) {
        this.endian = endian;
    }
    UInt32Type.prototype.read = function (stream) { return stream.readUInt32(this.endian); };
    UInt32Type.prototype.write = function (stream, value) { stream.writeUInt32(value, this.endian); };
    Object.defineProperty(UInt32Type.prototype, "length", {
        get: function () { return 4; },
        enumerable: true,
        configurable: true
    });
    return UInt32Type;
})();
var UInt16Type = (function () {
    function UInt16Type(endian) {
        this.endian = endian;
    }
    UInt16Type.prototype.read = function (stream) { return stream.readUInt16(this.endian); };
    UInt16Type.prototype.write = function (stream, value) { stream.writeUInt16(value, this.endian); };
    Object.defineProperty(UInt16Type.prototype, "length", {
        get: function () { return 2; },
        enumerable: true,
        configurable: true
    });
    return UInt16Type;
})();
var UInt8Type = (function () {
    function UInt8Type(endian) {
        this.endian = endian;
    }
    UInt8Type.prototype.read = function (stream) { return stream.readUInt8(this.endian); };
    UInt8Type.prototype.write = function (stream, value) { stream.writeUInt8(value, this.endian); };
    Object.defineProperty(UInt8Type.prototype, "length", {
        get: function () { return 1; },
        enumerable: true,
        configurable: true
    });
    return UInt8Type;
})();
var StructClass = (function () {
    function StructClass(_class, items) {
        this._class = _class;
        this.items = items;
        this.processedItems = [];
        this.processedItems = items.map(function (item) {
            for (var key in item)
                return { name: key, type: item[key] };
            throw (new Error("Entry must have one item"));
        });
    }
    StructClass.create = function (_class, items) {
        return new StructClass(_class, items);
    };
    StructClass.prototype.read = function (stream) {
        var _class = this._class;
        var out = new _class();
        for (var n = 0; n < this.processedItems.length; n++) {
            var item = this.processedItems[n];
            out[item.name] = item.type.read(stream, out);
        }
        return out;
    };
    StructClass.prototype.write = function (stream, value) {
        for (var n = 0; n < this.processedItems.length; n++) {
            var item = this.processedItems[n];
            item.type.write(stream, value[item.name], value);
        }
    };
    StructClass.prototype.offsetOfField = function (name) {
        var offset = 0;
        for (var n = 0; n < this.processedItems.length; n++) {
            var item = this.processedItems[n];
            if (item.name == name)
                return offset;
            offset += item.type.length;
        }
        return -1;
    };
    Object.defineProperty(StructClass.prototype, "length", {
        get: function () {
            var sum = 0;
            for (var n = 0; n < this.processedItems.length; n++) {
                var item = this.processedItems[n];
                if (!item)
                    throw ("Invalid item!!");
                if (!item.type) {
                    console.log(item);
                    throw ("Invalid item type!!");
                }
                sum += item.type.length;
            }
            return sum;
        },
        enumerable: true,
        configurable: true
    });
    return StructClass;
})();
var StructArrayClass = (function () {
    function StructArrayClass(elementType, count) {
        this.elementType = elementType;
        this.count = count;
    }
    StructArrayClass.prototype.read = function (stream) {
        var out = [];
        for (var n = 0; n < this.count; n++) {
            out.push(this.elementType.read(stream, out));
        }
        return out;
    };
    StructArrayClass.prototype.write = function (stream, value) {
        for (var n = 0; n < this.count; n++)
            this.elementType.write(stream, value[n], value);
    };
    Object.defineProperty(StructArrayClass.prototype, "length", {
        get: function () {
            return this.elementType.length * this.count;
        },
        enumerable: true,
        configurable: true
    });
    return StructArrayClass;
})();
function StructArray(elementType, count) {
    return new StructArrayClass(elementType, count);
}
var StructStringn = (function () {
    function StructStringn(count) {
        this.count = count;
    }
    StructStringn.prototype.read = function (stream) {
        var out = '';
        for (var n = 0; n < this.count; n++) {
            out += String.fromCharCode(stream.readUInt8());
        }
        return out;
    };
    StructStringn.prototype.write = function (stream, value) {
        throw ("Not implemented StructStringn.write");
    };
    Object.defineProperty(StructStringn.prototype, "length", {
        get: function () {
            return this.count;
        },
        enumerable: true,
        configurable: true
    });
    return StructStringn;
})();
var StructStringz = (function () {
    function StructStringz(count) {
        this.count = count;
        this.stringn = new StructStringn(count);
    }
    StructStringz.prototype.read = function (stream) {
        return this.stringn.read(stream).split(String.fromCharCode(0))[0];
    };
    StructStringz.prototype.write = function (stream, value) {
        if (!value)
            value = '';
        var items = value.split('').map(function (char) { return char.charCodeAt(0); });
        while (items.length < this.count)
            items.push(0);
        for (var n = 0; n < items.length; n++)
            stream.writeUInt8(items[n]);
    };
    Object.defineProperty(StructStringz.prototype, "length", {
        get: function () {
            return this.count;
        },
        enumerable: true,
        configurable: true
    });
    return StructStringz;
})();
var StructStringzVariable = (function () {
    function StructStringzVariable() {
    }
    StructStringzVariable.prototype.read = function (stream) {
        return stream.readStringz();
    };
    StructStringzVariable.prototype.write = function (stream, value) {
        stream.writeString(value);
        stream.writeUInt8(0);
    };
    Object.defineProperty(StructStringzVariable.prototype, "length", {
        get: function () {
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    return StructStringzVariable;
})();
var UInt32_2lbStruct = (function () {
    function UInt32_2lbStruct() {
    }
    UInt32_2lbStruct.prototype.read = function (stream) {
        var l = stream.readUInt32(Endian.LITTLE);
        var b = stream.readUInt32(Endian.BIG);
        return l;
    };
    UInt32_2lbStruct.prototype.write = function (stream, value) {
        stream.writeUInt32(value, Endian.LITTLE);
        stream.writeUInt32(value, Endian.BIG);
    };
    Object.defineProperty(UInt32_2lbStruct.prototype, "length", {
        get: function () { return 8; },
        enumerable: true,
        configurable: true
    });
    return UInt32_2lbStruct;
})();
var UInt16_2lbStruct = (function () {
    function UInt16_2lbStruct() {
    }
    UInt16_2lbStruct.prototype.read = function (stream) {
        var l = stream.readUInt16(Endian.LITTLE);
        var b = stream.readUInt16(Endian.BIG);
        return l;
    };
    UInt16_2lbStruct.prototype.write = function (stream, value) {
        stream.writeUInt16(value, Endian.LITTLE);
        stream.writeUInt16(value, Endian.BIG);
    };
    Object.defineProperty(UInt16_2lbStruct.prototype, "length", {
        get: function () { return 4; },
        enumerable: true,
        configurable: true
    });
    return UInt16_2lbStruct;
})();
var StructStringWithSize = (function () {
    function StructStringWithSize(getStringSize) {
        this.getStringSize = getStringSize;
    }
    StructStringWithSize.prototype.read = function (stream, context) {
        return stream.readString(this.getStringSize(context));
    };
    StructStringWithSize.prototype.write = function (stream, value, context) {
        stream.writeString(value);
    };
    Object.defineProperty(StructStringWithSize.prototype, "length", {
        get: function () {
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    return StructStringWithSize;
})();
var Int16 = new Int16Type(Endian.LITTLE);
var Int32 = new Int32Type(Endian.LITTLE);
var Int64 = new Int64Type(Endian.LITTLE);
var Int8 = new Int8Type(Endian.LITTLE);
var UInt16 = new UInt16Type(Endian.LITTLE);
var UInt32 = new UInt32Type(Endian.LITTLE);
var UInt8 = new UInt8Type(Endian.LITTLE);
var UInt16_b = new UInt16Type(Endian.BIG);
var UInt32_b = new UInt32Type(Endian.BIG);
var UInt32_2lb = new UInt32_2lbStruct();
var UInt16_2lb = new UInt16_2lbStruct();
var StringzVariable = new StructStringzVariable();
function Stringn(count) { return new StructStringn(count); }
function Stringz(count) { return new StructStringz(count); }
function StringWithSize(callback) {
    return new StructStringWithSize(callback);
}
var StructPointerStruct = (function () {
    function StructPointerStruct(elementType) {
        this.elementType = elementType;
    }
    StructPointerStruct.prototype.read = function (stream, context) {
        var address = stream.readInt32(Endian.LITTLE);
        return new Pointer(this.elementType, context['memory'], address);
    };
    StructPointerStruct.prototype.write = function (stream, value, context) {
        var address = value.address;
        stream.writeInt32(address, Endian.LITTLE);
    };
    Object.defineProperty(StructPointerStruct.prototype, "length", {
        get: function () {
            return 4;
        },
        enumerable: true,
        configurable: true
    });
    return StructPointerStruct;
})();
function StructPointer(type) {
    return new StructPointerStruct(type);
}
var Pointer = (function () {
    function Pointer(type, memory, address) {
        this.type = type;
        this.memory = memory;
        this.address = address;
        this.stream = memory.getPointerStream(this.address);
    }
    Pointer.prototype.readWrite = function (callback) {
        var value = this.read();
        try {
            callback(value);
        }
        finally {
            this.write(value);
        }
    };
    Pointer.prototype.read = function () {
        return this.type.read(this.stream.clone());
    };
    Pointer.prototype.write = function (value) {
        this.type.write(this.stream.clone(), value);
    };
    return Pointer;
})();

var require = (function() {
function requireModules(moduleFiles) {
	var modules = {};
	
	function normalizePath(path) {
		var components = [];
		path.split('/').forEach(function(item) {
			switch (item) {
				case '': case '.': break;
				case '..': if (components.length) components.pop(); break;
				default: components.push(item);
			}
		});
		//console.log('path: ' + path + ' -> ' + components.join('/'));
		return components.join('/');
	}
	
	function getParentPath(path) {
		var index = path.lastIndexOf('/');
		if (index >= 0) return path.substr(0, index);
		return '';
	}
	
	var getRequireForPath = function(path) {
		return function(relativeModuleName) {
			var absoluteModuleName = normalizePath(path + '/' + relativeModuleName);
			var absoluteModuleParent = getParentPath(absoluteModuleName);
			var module = modules[absoluteModuleName];
			if (!module) {
				modules[absoluteModuleName] = module = { exports : {} };
				var moduleFunction = moduleFiles[absoluteModuleName];
				if (!moduleFunction) throw(new Error("Can't find module '" + absoluteModuleName + "'"));
				moduleFunction(module, module.exports, getRequireForPath(absoluteModuleParent));
			}
			return module.exports;
		};
	};
	return getRequireForPath('');
}return requireModules({
"bootstrap": function(module, exports, require) {
///<reference path="./src/app.ts" />
///<reference path="./test/_tests.ts" />

},
"src/app": function(module, exports, require) {
///<reference path="global.d.ts" />
var _controller = require('./core/controller');
var _emulator = require('./emulator');
var PspCtrlButtons = _controller.PspCtrlButtons;
var Emulator = _emulator.Emulator;
function controllerRegister() {
    var rects = [];
    var generateRects = (function () {
        var overlay_query = $('#touch_overlay');
        var overlay_pos = overlay_query.offset();
        var overlay_width = overlay_query.width(), overlay_height = overlay_query.height();
        [
            { query: '#button_menu', button: 0 },
            { query: '#button_select', button: PspCtrlButtons.select },
            { query: '#button_start', button: PspCtrlButtons.start },
            { query: '#button_up', button: PspCtrlButtons.up },
            { query: '#button_left', button: PspCtrlButtons.left },
            { query: '#button_down', button: PspCtrlButtons.down },
            { query: '#button_right', button: PspCtrlButtons.right },
            { query: '#button_l', button: PspCtrlButtons.leftTrigger },
            { query: '#button_r', button: PspCtrlButtons.rightTrigger },
            { query: '#button_cross', button: PspCtrlButtons.cross },
            { query: '#button_circle', button: PspCtrlButtons.circle },
            { query: '#button_square', button: PspCtrlButtons.square },
            { query: '#button_triangle', button: PspCtrlButtons.triangle },
        ].forEach(function (button) {
            var query = $(button.query);
            var item_pos = query.offset();
            var query_width = query.width(), query_height = query.height();
            var item_left = (item_pos.left - overlay_pos.left) / overlay_width;
            var item_right = (item_pos.left - overlay_pos.left + query_width) / overlay_width;
            var item_top = (item_pos.top - overlay_pos.top) / overlay_height;
            var item_bottom = (item_pos.top - overlay_pos.top + query_height) / overlay_height;
            rects.push({
                left: item_left,
                right: item_right,
                top: item_top,
                bottom: item_bottom,
                name: button.query,
                button: button.button
            });
        });
    });
    generateRects();
    var locateRect = (function (screenX, screenY) {
        var overlay_query = $('#touch_overlay');
        var overlay_pos = overlay_query.offset();
        var overlay_width = overlay_query.width(), overlay_height = overlay_query.height();
        var x = (screenX - overlay_pos.left) / overlay_width;
        var y = (screenY - overlay_pos.top) / overlay_height;
        for (var _i = 0; _i < rects.length; _i++) {
            var rect = rects[_i];
            if (((x >= rect.left) && (x < rect.right)) && ((y >= rect.top && y < rect.bottom))) {
                return rect;
            }
        }
        return null;
    });
    var touchesState = {};
    function simulateButtonDown(button) {
        if (emulator.controller)
            emulator.controller.simulateButtonDown(button);
    }
    function simulateButtonUp(button) {
        if (emulator.controller)
            emulator.controller.simulateButtonUp(button);
    }
    function touchStart(touches) {
        for (var _i = 0; _i < touches.length; _i++) {
            var touch = touches[_i];
            touchesState[touch.identifier] = { rect: null };
        }
        touchMove(touches);
    }
    function touchMove(touches) {
        for (var _i = 0; _i < touches.length; _i++) {
            var touch = touches[_i];
            var rect = locateRect(touch.clientX, touch.clientY);
            var touchState = touchesState[touch.identifier];
            if (touchState.rect) {
                $(touchState.rect.name).removeClass('pressed');
                simulateButtonUp(touchState.rect.button);
            }
            touchState.rect = rect;
            if (rect) {
                $(rect.name).addClass('pressed');
                simulateButtonDown(rect.button);
            }
        }
    }
    function touchEnd(touches) {
        for (var _i = 0; _i < touches.length; _i++) {
            var touch = touches[_i];
            var touchState = touchesState[touch.identifier];
            if (touchState && touchState.rect) {
                $(touchState.rect.name).removeClass('pressed');
                simulateButtonUp(touchState.rect.button);
            }
            delete touchesState[touch.identifier];
        }
    }
    $('#touch_overlay').on('touchstart', function (e) {
        touchStart(e.originalEvent['changedTouches']);
        e.preventDefault();
    });
    $('#touch_overlay').on('touchmove', function (e) {
        touchMove(e.originalEvent['changedTouches']);
        e.preventDefault();
    });
    $('#touch_overlay').on('touchend', function (e) {
        touchEnd(e.originalEvent['changedTouches']);
        e.preventDefault();
    });
    var pressing = false;
    function generateTouchEvent(x, y) { return { clientX: x, clientY: y, identifier: 0 }; }
    $('#touch_overlay').mousedown(function (e) {
        pressing = true;
        touchStart([generateTouchEvent(e.clientX, e.clientY)]);
    });
    $('#touch_overlay').mouseup(function (e) {
        pressing = false;
        touchEnd([generateTouchEvent(e.clientX, e.clientY)]);
    });
    $('#touch_overlay').mousemove(function (e) {
        if (pressing) {
            touchMove([generateTouchEvent(e.clientX, e.clientY)]);
        }
    });
}
var emulator = new Emulator();
var _window = window;
_window['emulator'] = emulator;
var sampleDemo = undefined;
if (document.location.hash) {
    sampleDemo = document.location.hash.substr(1);
    if (sampleDemo.startsWith('samples/')) {
        sampleDemo = 'data/' + sampleDemo;
    }
}
else {
    $('#game_menu').show();
}
if (sampleDemo) {
    emulator.downloadAndExecuteAsync(sampleDemo);
}
$(window).load(function () {
    controllerRegister();
});

},
"src/context": function(module, exports, require) {
///<reference path="global.ts" />
///<reference path="global.d.ts" />
var EmulatorContext = (function () {
    function EmulatorContext() {
        this.onStdout = new Signal();
        this.onStderr = new Signal();
        this.container = {};
        this.gameTitle = 'unknown';
        this.gameId = 'unknown';
    }
    Object.defineProperty(EmulatorContext.prototype, "currentThread", {
        get: function () { return this.threadManager.current; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmulatorContext.prototype, "currentState", {
        get: function () { return this.currentThread.state; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EmulatorContext.prototype, "currentInstructionCache", {
        get: function () { return this.currentState.icache; },
        enumerable: true,
        configurable: true
    });
    EmulatorContext.prototype.init = function (interruptManager, display, controller, gpu, memoryManager, threadManager, audio, memory, fileManager, rtc, callbackManager, moduleManager, config, interop, netManager) {
        this.interruptManager = interruptManager;
        this.display = display;
        this.controller = controller;
        this.gpu = gpu;
        this.memoryManager = memoryManager;
        this.threadManager = threadManager;
        this.audio = audio;
        this.memory = memory;
        this.fileManager = fileManager;
        this.rtc = rtc;
        this.callbackManager = callbackManager;
        this.moduleManager = moduleManager;
        this.config = config;
        this.interop = interop;
        this.netManager = netManager;
    };
    return EmulatorContext;
})();
exports.EmulatorContext = EmulatorContext;

},
"src/core/audio": function(module, exports, require) {
///<reference path="../global.d.ts" />
var PspAudioBuffer = (function () {
    function PspAudioBuffer(readedCallback, data) {
        this.readedCallback = readedCallback;
        this.data = data;
        this.offset = 0;
    }
    PspAudioBuffer.prototype.resolve = function () {
        if (this.readedCallback)
            this.readedCallback();
        this.readedCallback = null;
    };
    Object.defineProperty(PspAudioBuffer.prototype, "hasMore", {
        get: function () { return this.offset < this.length; },
        enumerable: true,
        configurable: true
    });
    PspAudioBuffer.prototype.read = function () { return this.data[this.offset++]; };
    Object.defineProperty(PspAudioBuffer.prototype, "available", {
        get: function () { return this.length - this.offset; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PspAudioBuffer.prototype, "length", {
        get: function () { return this.data.length; },
        enumerable: true,
        configurable: true
    });
    return PspAudioBuffer;
})();
exports.PspAudioBuffer = PspAudioBuffer;
var Sample = (function () {
    function Sample(left, right) {
        this.left = left;
        this.right = right;
    }
    Sample.prototype.set = function (left, right) {
        this.left = left;
        this.right = right;
        return this;
    };
    Sample.prototype.scale = function (leftScale, rightScale) {
        this.left *= leftScale;
        this.right *= rightScale;
    };
    Sample.prototype.addScaled = function (sample, leftScale, rightScale) {
        this.left += sample.left * leftScale;
        this.right += sample.right * rightScale;
    };
    Sample.prototype.GetNextSample = function () {
    };
    return Sample;
})();
exports.Sample = Sample;
var PspAudioChannel = (function () {
    function PspAudioChannel(audio, context) {
        var _this = this;
        this.audio = audio;
        this.context = context;
        this.buffers = [];
        if (this.context) {
            this.node = this.context.createScriptProcessor(1024, 2, 2);
            this.node.onaudioprocess = function (e) { _this.process(e); };
        }
    }
    PspAudioChannel.prototype.start = function () {
        if (this.node)
            this.node.connect(this.context.destination);
        this.audio.playingChannels.add(this);
    };
    PspAudioChannel.prototype.stop = function () {
        if (this.node)
            this.node.disconnect();
        this.audio.playingChannels.delete(this);
    };
    PspAudioChannel.prototype.process = function (e) {
        var left = e.outputBuffer.getChannelData(0);
        var right = e.outputBuffer.getChannelData(1);
        var sampleCount = left.length;
        var hidden = document.hidden;
        for (var n = 0; n < sampleCount; n++) {
            if (!this.currentBuffer) {
                if (this.buffers.length == 0)
                    break;
                for (var m = 0; m < Math.min(3, this.buffers.length); m++) {
                    this.buffers[m].resolve();
                }
                this.currentBuffer = this.buffers.shift();
                this.currentBuffer.resolve();
            }
            if (this.currentBuffer.available >= 2) {
                left[n] = this.currentBuffer.read();
                right[n] = this.currentBuffer.read();
            }
            else {
                this.currentBuffer = null;
                n--;
            }
            if (hidden)
                left[n] = right[n] = 0;
        }
    };
    PspAudioChannel.prototype.playAsync = function (data) {
        var _this = this;
        if (!this.node)
            return waitAsync(10).then(function () { return 0; });
        if (this.buffers.length < 8) {
            this.buffers.push(new PspAudioBuffer(null, data));
            return 0;
        }
        else {
            return new Promise2(function (resolved, rejected) {
                _this.buffers.push(new PspAudioBuffer(resolved, data));
                return 0;
            });
        }
    };
    return PspAudioChannel;
})();
exports.PspAudioChannel = PspAudioChannel;
var PspAudio = (function () {
    function PspAudio() {
        this.context = null;
        this.playingChannels = new SortedSet();
        try {
            this.context = new AudioContext();
        }
        catch (e) {
        }
    }
    PspAudio.prototype.createChannel = function () {
        return new PspAudioChannel(this, this.context);
    };
    PspAudio.convertS16ToF32 = function (channels, input) {
        var output = new Float32Array(input.length * 2 / channels);
        switch (channels) {
            case 2:
                for (var n = 0; n < output.length; n++)
                    output[n] = input[n] / 32767.0;
                break;
            case 1:
                for (var n = 0, m = 0; n < input.length; n++) {
                    output[m++] = output[m++] = (input[n] / 32767.0);
                }
                break;
        }
        return output;
    };
    PspAudio.prototype.startAsync = function () {
        return Promise2.resolve();
    };
    PspAudio.prototype.stopAsync = function () {
        this.playingChannels.forEach(function (channel) {
            channel.stop();
        });
        return Promise2.resolve();
    };
    return PspAudio;
})();
exports.PspAudio = PspAudio;

},
"src/core/controller": function(module, exports, require) {
///<reference path="../global.d.ts" />
if (typeof navigator == 'undefined')
    navigator = {};
var SceCtrlData = (function () {
    function SceCtrlData() {
        this.timeStamp = 0;
        this.buttons = PspCtrlButtons.none;
        this.lx = 0;
        this.ly = 0;
        this._rsrv = [0, 0, 0, 0, 0];
        this.x = 0;
        this.y = 0;
    }
    Object.defineProperty(SceCtrlData.prototype, "x", {
        get: function () { return ((this.lx / 255.0) - 0.5) * 2.0; },
        set: function (value) { this.lx = (((value / 2.0) + 0.5) * 255.0); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SceCtrlData.prototype, "y", {
        get: function () { return ((this.ly / 255.0) - 0.5) * 2.0; },
        set: function (value) { this.ly = (((value / 2.0) + 0.5) * 255.0); },
        enumerable: true,
        configurable: true
    });
    SceCtrlData.struct = StructClass.create(SceCtrlData, [
        { timeStamp: UInt32 },
        { buttons: UInt32 },
        { lx: Int8 },
        { ly: Int8 },
        { _rsrv: StructArray(Int8, 6) },
    ]);
    return SceCtrlData;
})();
exports.SceCtrlData = SceCtrlData;
var PspController = (function () {
    function PspController() {
        this.data = new SceCtrlData();
        this.buttonMapping = {};
        this.fieldMapping = {};
        this.analogUp = false;
        this.analogDown = false;
        this.analogLeft = false;
        this.analogRight = false;
        this.analogAddX = 0;
        this.analogAddY = 0;
        this.latchSamplingCount = 0;
        this.animationTimeId = 0;
        this.buttonMapping = {};
        this.buttonMapping[HtmlKeyCodes.up] = PspCtrlButtons.up;
        this.buttonMapping[HtmlKeyCodes.left] = PspCtrlButtons.left;
        this.buttonMapping[HtmlKeyCodes.right] = PspCtrlButtons.right;
        this.buttonMapping[HtmlKeyCodes.down] = PspCtrlButtons.down;
        this.buttonMapping[HtmlKeyCodes.enter] = PspCtrlButtons.start;
        this.buttonMapping[HtmlKeyCodes.space] = PspCtrlButtons.select;
        this.buttonMapping[HtmlKeyCodes.q] = PspCtrlButtons.leftTrigger;
        this.buttonMapping[HtmlKeyCodes.e] = PspCtrlButtons.rightTrigger;
        this.buttonMapping[HtmlKeyCodes.w] = PspCtrlButtons.triangle;
        this.buttonMapping[HtmlKeyCodes.s] = PspCtrlButtons.cross;
        this.buttonMapping[HtmlKeyCodes.a] = PspCtrlButtons.square;
        this.buttonMapping[HtmlKeyCodes.d] = PspCtrlButtons.circle;
        this.fieldMapping[HtmlKeyCodes.i] = 'analogUp';
        this.fieldMapping[HtmlKeyCodes.k] = 'analogDown';
        this.fieldMapping[HtmlKeyCodes.j] = 'analogLeft';
        this.fieldMapping[HtmlKeyCodes.l] = 'analogRight';
    }
    PspController.prototype.keyDown = function (e) {
        var button = this.buttonMapping[e.keyCode];
        if (button !== undefined)
            this.data.buttons |= button;
        var field = this.fieldMapping[e.keyCode];
        if (field !== undefined)
            this[field] = true;
    };
    PspController.prototype.keyUp = function (e) {
        var button = this.buttonMapping[e.keyCode];
        if (button !== undefined)
            this.data.buttons &= ~button;
        var field = this.fieldMapping[e.keyCode];
        if (field !== undefined)
            this[field] = false;
    };
    PspController.prototype.simulateButtonDown = function (button) {
        this.data.buttons |= button;
    };
    PspController.prototype.simulateButtonUp = function (button) {
        this.data.buttons &= ~button;
    };
    PspController.prototype.simulateButtonPress = function (button) {
        var _this = this;
        this.simulateButtonDown(button);
        setTimeout(function () { _this.simulateButtonUp(button); }, 60);
    };
    PspController.prototype.startAsync = function () {
        var _this = this;
        if (typeof document != 'undefined') {
            document.addEventListener('keydown', this._keyDown = function (e) { return _this.keyDown(e); });
            document.addEventListener('keyup', this._keyUp = function (e) { return _this.keyUp(e); });
        }
        this.frame(0);
        return Promise2.resolve();
    };
    PspController.prototype.frame = function (timestamp) {
        var _this = this;
        if (this.analogUp) {
            this.analogAddY -= 0.25;
        }
        else if (this.analogDown) {
            this.analogAddY += 0.25;
        }
        else {
            this.analogAddY *= 0.3;
        }
        if (this.analogLeft) {
            this.analogAddX -= 0.25;
        }
        else if (this.analogRight) {
            this.analogAddX += 0.25;
        }
        else {
            this.analogAddX *= 0.3;
        }
        this.analogAddX = MathUtils.clamp(this.analogAddX, -1, +1);
        this.analogAddY = MathUtils.clamp(this.analogAddY, -1, +1);
        this.data.x = this.analogAddX;
        this.data.y = this.analogAddY;
        if (window.navigator && window.navigator['getGamepads']) {
            var gamepads = (navigator['getGamepads'])();
            if (gamepads[0]) {
                var buttonMapping = [
                    PspCtrlButtons.cross,
                    PspCtrlButtons.circle,
                    PspCtrlButtons.square,
                    PspCtrlButtons.triangle,
                    PspCtrlButtons.leftTrigger,
                    PspCtrlButtons.rightTrigger,
                    PspCtrlButtons.volumeUp,
                    PspCtrlButtons.volumeDown,
                    PspCtrlButtons.select,
                    PspCtrlButtons.start,
                    PspCtrlButtons.home,
                    PspCtrlButtons.note,
                    PspCtrlButtons.up,
                    PspCtrlButtons.down,
                    PspCtrlButtons.left,
                    PspCtrlButtons.right,
                ];
                var gamepad = gamepads[0];
                var buttons = gamepad['buttons'];
                var axes = gamepad['axes'];
                this.data.x += axes[0];
                this.data.y += axes[1];
                function checkButton(button) {
                    if (typeof button == 'number') {
                        return button != 0;
                    }
                    else {
                        return button ? !!(button.pressed) : false;
                    }
                }
                for (var n = 0; n < 16; n++) {
                    if (checkButton(buttons[n])) {
                        this.simulateButtonDown(buttonMapping[n]);
                    }
                    else {
                        this.simulateButtonUp(buttonMapping[n]);
                    }
                }
            }
        }
        this.data.x = MathUtils.clamp(this.data.x, -1, +1);
        this.data.y = MathUtils.clamp(this.data.y, -1, +1);
        this.animationTimeId = requestAnimationFrame(function (timestamp) { return _this.frame(timestamp); });
    };
    PspController.prototype.stopAsync = function () {
        if (typeof document != 'undefined') {
            document.removeEventListener('keydown', this._keyDown);
            document.removeEventListener('keyup', this._keyUp);
        }
        cancelAnimationFrame(this.animationTimeId);
        return Promise2.resolve();
    };
    return PspController;
})();
exports.PspController = PspController;
(function (PspCtrlButtons) {
    PspCtrlButtons[PspCtrlButtons["none"] = 0] = "none";
    PspCtrlButtons[PspCtrlButtons["select"] = 1] = "select";
    PspCtrlButtons[PspCtrlButtons["start"] = 8] = "start";
    PspCtrlButtons[PspCtrlButtons["up"] = 16] = "up";
    PspCtrlButtons[PspCtrlButtons["right"] = 32] = "right";
    PspCtrlButtons[PspCtrlButtons["down"] = 64] = "down";
    PspCtrlButtons[PspCtrlButtons["left"] = 128] = "left";
    PspCtrlButtons[PspCtrlButtons["leftTrigger"] = 256] = "leftTrigger";
    PspCtrlButtons[PspCtrlButtons["rightTrigger"] = 512] = "rightTrigger";
    PspCtrlButtons[PspCtrlButtons["triangle"] = 4096] = "triangle";
    PspCtrlButtons[PspCtrlButtons["circle"] = 8192] = "circle";
    PspCtrlButtons[PspCtrlButtons["cross"] = 16384] = "cross";
    PspCtrlButtons[PspCtrlButtons["square"] = 32768] = "square";
    PspCtrlButtons[PspCtrlButtons["home"] = 65536] = "home";
    PspCtrlButtons[PspCtrlButtons["hold"] = 131072] = "hold";
    PspCtrlButtons[PspCtrlButtons["wirelessLanUp"] = 262144] = "wirelessLanUp";
    PspCtrlButtons[PspCtrlButtons["remote"] = 524288] = "remote";
    PspCtrlButtons[PspCtrlButtons["volumeUp"] = 1048576] = "volumeUp";
    PspCtrlButtons[PspCtrlButtons["volumeDown"] = 2097152] = "volumeDown";
    PspCtrlButtons[PspCtrlButtons["screen"] = 4194304] = "screen";
    PspCtrlButtons[PspCtrlButtons["note"] = 8388608] = "note";
    PspCtrlButtons[PspCtrlButtons["discPresent"] = 16777216] = "discPresent";
    PspCtrlButtons[PspCtrlButtons["memoryStickPresent"] = 33554432] = "memoryStickPresent";
})(exports.PspCtrlButtons || (exports.PspCtrlButtons = {}));
var PspCtrlButtons = exports.PspCtrlButtons;
(function (HtmlKeyCodes) {
    HtmlKeyCodes[HtmlKeyCodes["backspace"] = 8] = "backspace";
    HtmlKeyCodes[HtmlKeyCodes["tab"] = 9] = "tab";
    HtmlKeyCodes[HtmlKeyCodes["enter"] = 13] = "enter";
    HtmlKeyCodes[HtmlKeyCodes["shift"] = 16] = "shift";
    HtmlKeyCodes[HtmlKeyCodes["ctrl"] = 17] = "ctrl";
    HtmlKeyCodes[HtmlKeyCodes["alt"] = 18] = "alt";
    HtmlKeyCodes[HtmlKeyCodes["pause"] = 19] = "pause";
    HtmlKeyCodes[HtmlKeyCodes["caps_lock"] = 20] = "caps_lock";
    HtmlKeyCodes[HtmlKeyCodes["escape"] = 27] = "escape";
    HtmlKeyCodes[HtmlKeyCodes["space"] = 32] = "space";
    HtmlKeyCodes[HtmlKeyCodes["page_up"] = 33] = "page_up";
    HtmlKeyCodes[HtmlKeyCodes["page_down"] = 34] = "page_down";
    HtmlKeyCodes[HtmlKeyCodes["end"] = 35] = "end";
    HtmlKeyCodes[HtmlKeyCodes["home"] = 36] = "home";
    HtmlKeyCodes[HtmlKeyCodes["left"] = 37] = "left";
    HtmlKeyCodes[HtmlKeyCodes["up"] = 38] = "up";
    HtmlKeyCodes[HtmlKeyCodes["right"] = 39] = "right";
    HtmlKeyCodes[HtmlKeyCodes["down"] = 40] = "down";
    HtmlKeyCodes[HtmlKeyCodes["insert"] = 45] = "insert";
    HtmlKeyCodes[HtmlKeyCodes["_delete"] = 46] = "_delete";
    HtmlKeyCodes[HtmlKeyCodes["k0"] = 48] = "k0";
    HtmlKeyCodes[HtmlKeyCodes["k1"] = 49] = "k1";
    HtmlKeyCodes[HtmlKeyCodes["k2"] = 50] = "k2";
    HtmlKeyCodes[HtmlKeyCodes["k3"] = 51] = "k3";
    HtmlKeyCodes[HtmlKeyCodes["k4"] = 52] = "k4";
    HtmlKeyCodes[HtmlKeyCodes["k5"] = 53] = "k5";
    HtmlKeyCodes[HtmlKeyCodes["k6"] = 54] = "k6";
    HtmlKeyCodes[HtmlKeyCodes["k7"] = 55] = "k7";
    HtmlKeyCodes[HtmlKeyCodes["k8"] = 56] = "k8";
    HtmlKeyCodes[HtmlKeyCodes["k9"] = 57] = "k9";
    HtmlKeyCodes[HtmlKeyCodes["a"] = 65] = "a";
    HtmlKeyCodes[HtmlKeyCodes["b"] = 66] = "b";
    HtmlKeyCodes[HtmlKeyCodes["c"] = 67] = "c";
    HtmlKeyCodes[HtmlKeyCodes["d"] = 68] = "d";
    HtmlKeyCodes[HtmlKeyCodes["e"] = 69] = "e";
    HtmlKeyCodes[HtmlKeyCodes["f"] = 70] = "f";
    HtmlKeyCodes[HtmlKeyCodes["g"] = 71] = "g";
    HtmlKeyCodes[HtmlKeyCodes["h"] = 72] = "h";
    HtmlKeyCodes[HtmlKeyCodes["i"] = 73] = "i";
    HtmlKeyCodes[HtmlKeyCodes["j"] = 74] = "j";
    HtmlKeyCodes[HtmlKeyCodes["k"] = 75] = "k";
    HtmlKeyCodes[HtmlKeyCodes["l"] = 76] = "l";
    HtmlKeyCodes[HtmlKeyCodes["m"] = 77] = "m";
    HtmlKeyCodes[HtmlKeyCodes["n"] = 78] = "n";
    HtmlKeyCodes[HtmlKeyCodes["o"] = 79] = "o";
    HtmlKeyCodes[HtmlKeyCodes["p"] = 80] = "p";
    HtmlKeyCodes[HtmlKeyCodes["q"] = 81] = "q";
    HtmlKeyCodes[HtmlKeyCodes["r"] = 82] = "r";
    HtmlKeyCodes[HtmlKeyCodes["s"] = 83] = "s";
    HtmlKeyCodes[HtmlKeyCodes["t"] = 84] = "t";
    HtmlKeyCodes[HtmlKeyCodes["u"] = 85] = "u";
    HtmlKeyCodes[HtmlKeyCodes["v"] = 86] = "v";
    HtmlKeyCodes[HtmlKeyCodes["w"] = 87] = "w";
    HtmlKeyCodes[HtmlKeyCodes["x"] = 88] = "x";
    HtmlKeyCodes[HtmlKeyCodes["y"] = 89] = "y";
    HtmlKeyCodes[HtmlKeyCodes["z"] = 90] = "z";
    HtmlKeyCodes[HtmlKeyCodes["left_window_key"] = 91] = "left_window_key";
    HtmlKeyCodes[HtmlKeyCodes["right_window_key"] = 92] = "right_window_key";
    HtmlKeyCodes[HtmlKeyCodes["select_key"] = 93] = "select_key";
    HtmlKeyCodes[HtmlKeyCodes["numpad_0"] = 96] = "numpad_0";
    HtmlKeyCodes[HtmlKeyCodes["numpad_1"] = 97] = "numpad_1";
    HtmlKeyCodes[HtmlKeyCodes["numpad_2"] = 98] = "numpad_2";
    HtmlKeyCodes[HtmlKeyCodes["numpad_3"] = 99] = "numpad_3";
    HtmlKeyCodes[HtmlKeyCodes["numpad_4"] = 100] = "numpad_4";
    HtmlKeyCodes[HtmlKeyCodes["numpad_5"] = 101] = "numpad_5";
    HtmlKeyCodes[HtmlKeyCodes["numpad_6"] = 102] = "numpad_6";
    HtmlKeyCodes[HtmlKeyCodes["numpad_7"] = 103] = "numpad_7";
    HtmlKeyCodes[HtmlKeyCodes["numpad_8"] = 104] = "numpad_8";
    HtmlKeyCodes[HtmlKeyCodes["numpad_9"] = 105] = "numpad_9";
    HtmlKeyCodes[HtmlKeyCodes["multiply"] = 106] = "multiply";
    HtmlKeyCodes[HtmlKeyCodes["add"] = 107] = "add";
    HtmlKeyCodes[HtmlKeyCodes["subtract"] = 109] = "subtract";
    HtmlKeyCodes[HtmlKeyCodes["decimal_point"] = 110] = "decimal_point";
    HtmlKeyCodes[HtmlKeyCodes["divide"] = 111] = "divide";
    HtmlKeyCodes[HtmlKeyCodes["f1"] = 112] = "f1";
    HtmlKeyCodes[HtmlKeyCodes["f2"] = 113] = "f2";
    HtmlKeyCodes[HtmlKeyCodes["f3"] = 114] = "f3";
    HtmlKeyCodes[HtmlKeyCodes["f4"] = 115] = "f4";
    HtmlKeyCodes[HtmlKeyCodes["f5"] = 116] = "f5";
    HtmlKeyCodes[HtmlKeyCodes["f6"] = 117] = "f6";
    HtmlKeyCodes[HtmlKeyCodes["f7"] = 118] = "f7";
    HtmlKeyCodes[HtmlKeyCodes["f8"] = 119] = "f8";
    HtmlKeyCodes[HtmlKeyCodes["f9"] = 120] = "f9";
    HtmlKeyCodes[HtmlKeyCodes["f10"] = 121] = "f10";
    HtmlKeyCodes[HtmlKeyCodes["f11"] = 122] = "f11";
    HtmlKeyCodes[HtmlKeyCodes["f12"] = 123] = "f12";
    HtmlKeyCodes[HtmlKeyCodes["num_lock"] = 144] = "num_lock";
    HtmlKeyCodes[HtmlKeyCodes["scroll_lock"] = 145] = "scroll_lock";
    HtmlKeyCodes[HtmlKeyCodes["semi_colon"] = 186] = "semi_colon";
    HtmlKeyCodes[HtmlKeyCodes["equal_sign"] = 187] = "equal_sign";
    HtmlKeyCodes[HtmlKeyCodes["comma"] = 188] = "comma";
    HtmlKeyCodes[HtmlKeyCodes["dash"] = 189] = "dash";
    HtmlKeyCodes[HtmlKeyCodes["period"] = 190] = "period";
    HtmlKeyCodes[HtmlKeyCodes["forward_slash"] = 191] = "forward_slash";
    HtmlKeyCodes[HtmlKeyCodes["grave_accent"] = 192] = "grave_accent";
    HtmlKeyCodes[HtmlKeyCodes["open_bracket"] = 219] = "open_bracket";
    HtmlKeyCodes[HtmlKeyCodes["back_slash"] = 220] = "back_slash";
    HtmlKeyCodes[HtmlKeyCodes["close_braket"] = 221] = "close_braket";
    HtmlKeyCodes[HtmlKeyCodes["single_quote"] = 222] = "single_quote";
})(exports.HtmlKeyCodes || (exports.HtmlKeyCodes = {}));
var HtmlKeyCodes = exports.HtmlKeyCodes;

},
"src/core/cpu": function(module, exports, require) {
///<reference path="../global.d.ts" />
var _assembler = require('./cpu/cpu_assembler');
var _core = require('./cpu/cpu_core');
var _instructions = require('./cpu/cpu_instructions');
exports.MipsAssembler = _assembler.MipsAssembler;
exports.MipsDisassembler = _assembler.MipsDisassembler;
exports.CpuState = _core.CpuState;
exports.CpuSpecialAddresses = _core.CpuSpecialAddresses;
exports.SyscallManager = _core.SyscallManager;
exports.Instruction = _instructions.Instruction;
exports.Instructions = _instructions.Instructions;
exports.NativeFunction = _core.NativeFunction;
exports.createNativeFunction = _core.createNativeFunction;

},
"src/core/cpu/assembler": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var instructions = require('./instructions');
var Instructions = instructions.Instructions;
var Instruction = instructions.Instruction;
var MipsAssembler = (function () {
    function MipsAssembler() {
        this.instructions = Instructions.instance;
    }
    MipsAssembler.prototype.assembleToMemory = function (memory, PC, lines) {
        for (var n = 0; n < lines.length; n++) {
            var instructions = this.assemble(PC, lines[n]);
            for (var m = 0; m < instructions.length; m++) {
                var instruction = instructions[m];
                memory.writeInt32(PC, instruction.data);
                PC += 4;
            }
        }
    };
    MipsAssembler.prototype.assemble = function (PC, line) {
        //console.log(line);
        var matches = line.match(/^\s*(\w+)(.*)$/);
        var instructionName = matches[1];
        var instructionArguments = matches[2].replace(/^\s+/, '').replace(/\s+$/, '');
        switch (instructionName) {
            case 'li':
                var parts = instructionArguments.split(',');
                return this.assemble(PC, 'addiu ' + parts[0] + ', r0, ' + parts[1]);
        }
        var instructionType = this.instructions.findByName(instructionName);
        var instruction = new Instruction(PC, instructionType.vm.value);
        var types = [];
        var formatPattern = instructionType.format
            .replace('(', '\\(')
            .replace(')', '\\)')
            .replace(/(%\w+)/g, function (type) {
            types.push(type);
            switch (type) {
                case '%J':
                case '%s':
                case '%d':
                case '%t': return '([$r]\\d+)';
                case '%i': return '((?:0b|0x|\\-)?[0-9A-Fa-f_]+)';
                case '%C': return '((?:0b|0x|\\-)?[0-9A-Fa-f_]+)';
                case '%c': return '((?:0b|0x|\\-)?[0-9A-Fa-f_]+)';
                default: throw (new Error("MipsAssembler.Transform: Unknown type '" + type + "'"));
            }
        })
            .replace(/\s+/g, '\\s*');
        var regex = new RegExp('^' + formatPattern + '$', '');
        var matches = instructionArguments.match(regex);
        if (matches === null) {
            throw ('Not matching ' + instructionArguments + ' : ' + regex + ' : ' + instructionType.format);
        }
        for (var n = 0; n < types.length; n++) {
            var type = types[n];
            var match = matches[n + 1];
            this.update(instruction, type, match);
        }
        return [instruction];
    };
    MipsAssembler.prototype.decodeRegister = function (name) {
        if (name.charAt(0) == '$')
            return parseInt(name.substr(1));
        if (name.charAt(0) == 'r')
            return parseInt(name.substr(1));
        throw ('Invalid register "' + name + '"');
    };
    MipsAssembler.prototype.decodeInteger = function (str) {
        str = str.replace(/_/g, '');
        if (str.substr(0, 2) == '0b')
            return parseInt(str.substr(2), 2);
        if (str.substr(0, 2) == '0x')
            return parseInt(str.substr(2), 16);
        return parseInt(str, 10);
    };
    MipsAssembler.prototype.update = function (instruction, type, value) {
        switch (type) {
            case '%J':
            case '%s':
                instruction.rs = this.decodeRegister(value);
                break;
            case '%d':
                instruction.rd = this.decodeRegister(value);
                break;
            case '%t':
                instruction.rt = this.decodeRegister(value);
                break;
            case '%i':
                instruction.imm16 = this.decodeInteger(value);
                break;
            case '%C':
                instruction.syscall = this.decodeInteger(value);
                break;
            case '%c':
                instruction.syscall = this.decodeInteger(value);
                break;
            default: throw ("MipsAssembler.Update: Unknown type '" + type + "'");
        }
    };
    return MipsAssembler;
})();
exports.MipsAssembler = MipsAssembler;
var MipsDisassembler = (function () {
    function MipsDisassembler() {
        this.instructions = Instructions.instance;
    }
    MipsDisassembler.prototype.encodeRegister = function (index) {
        return '$' + index;
    };
    MipsDisassembler.prototype.disassemble = function (instruction) {
        var _this = this;
        var instructionType = this.instructions.findByData(instruction.data);
        var args = instructionType.format.replace(/(\%\w+)/g, function (type) {
            switch (type) {
                case '%s':
                    return _this.encodeRegister(instruction.rs);
                    break;
                case '%d':
                    return _this.encodeRegister(instruction.rd);
                    break;
                case '%t':
                    return _this.encodeRegister(instruction.rt);
                    break;
                default: throw ("MipsDisassembler.Disassemble: Unknown type '" + type + "'");
            }
        });
        return instructionType.name + ' ' + args;
    };
    return MipsDisassembler;
})();
exports.MipsDisassembler = MipsDisassembler;

},
"src/core/cpu/ast_builder": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ANode = (function () {
    function ANode() {
    }
    ANode.prototype.toJs = function () { return ''; };
    ANode.prototype.optimize = function () { return this; };
    return ANode;
})();
exports.ANode = ANode;
var ANodeStm = (function (_super) {
    __extends(ANodeStm, _super);
    function ANodeStm() {
        _super.apply(this, arguments);
    }
    return ANodeStm;
})(ANode);
exports.ANodeStm = ANodeStm;
var ANodeStmJump = (function (_super) {
    __extends(ANodeStmJump, _super);
    function ANodeStmJump(label) {
        _super.call(this);
        this.label = label;
    }
    return ANodeStmJump;
})(ANodeStm);
exports.ANodeStmJump = ANodeStmJump;
var ANodeStmReturn = (function (_super) {
    __extends(ANodeStmReturn, _super);
    function ANodeStmReturn() {
        _super.apply(this, arguments);
    }
    ANodeStmReturn.prototype.toJs = function () { return 'return;'; };
    return ANodeStmReturn;
})(ANodeStm);
exports.ANodeStmReturn = ANodeStmReturn;
var ANodeStmList = (function (_super) {
    __extends(ANodeStmList, _super);
    function ANodeStmList(childs) {
        _super.call(this);
        this.childs = childs;
        this.labels = {};
    }
    ANodeStmList.prototype.createLabel = function (label) {
        this.labels[label] = this.childs.length;
        return this.childs.length;
    };
    ANodeStmList.prototype.add = function (node) {
        this.childs.push(node);
    };
    ANodeStmList.prototype.toJs = function () {
        var jumpCount = 0;
        var usedLabels = {};
        for (var n = 0; n < this.childs.length; n++) {
            var item = this.childs[n];
            if (item instanceof ANodeStmJump) {
                jumpCount++;
                usedLabels[item.label] = true;
            }
        }
        if (jumpCount > 1)
            throw (new Error("Not supported more than one jump at this point!"));
        var lines = [];
        for (var n = 0; n < this.childs.length; n++) {
            var child = this.childs[n];
            if (usedLabels[n] !== undefined) {
                lines.push('while(true) {');
            }
            lines.push(child.toJs());
            if (child instanceof ANodeStmJump) {
                lines.push('}');
            }
        }
        return lines.join("\n");
    };
    return ANodeStmList;
})(ANodeStm);
exports.ANodeStmList = ANodeStmList;
var ANodeStmRaw = (function (_super) {
    __extends(ANodeStmRaw, _super);
    function ANodeStmRaw(content) {
        _super.call(this);
        this.content = content;
    }
    ANodeStmRaw.prototype.toJs = function () { return this.content; };
    return ANodeStmRaw;
})(ANodeStm);
exports.ANodeStmRaw = ANodeStmRaw;
var ANodeStmExpr = (function (_super) {
    __extends(ANodeStmExpr, _super);
    function ANodeStmExpr(expr) {
        _super.call(this);
        this.expr = expr;
    }
    ANodeStmExpr.prototype.toJs = function () { return this.expr.toJs() + ';'; };
    return ANodeStmExpr;
})(ANodeStm);
exports.ANodeStmExpr = ANodeStmExpr;
var ANodeAllocVarStm = (function (_super) {
    __extends(ANodeAllocVarStm, _super);
    function ANodeAllocVarStm(name, initialValue) {
        _super.call(this);
        this.name = name;
        this.initialValue = initialValue;
    }
    ANodeAllocVarStm.prototype.toJs = function () { return 'var ' + this.name + ' = ' + this.initialValue.toJs() + ';'; };
    return ANodeAllocVarStm;
})(ANodeStm);
exports.ANodeAllocVarStm = ANodeAllocVarStm;
var ANodeExpr = (function (_super) {
    __extends(ANodeExpr, _super);
    function ANodeExpr() {
        _super.apply(this, arguments);
    }
    return ANodeExpr;
})(ANode);
exports.ANodeExpr = ANodeExpr;
var ANodeExprLValue = (function (_super) {
    __extends(ANodeExprLValue, _super);
    function ANodeExprLValue() {
        _super.apply(this, arguments);
    }
    ANodeExprLValue.prototype.toAssignJs = function (right) { return ''; };
    return ANodeExprLValue;
})(ANodeExpr);
exports.ANodeExprLValue = ANodeExprLValue;
var ANodeExprLValueSetGet = (function (_super) {
    __extends(ANodeExprLValueSetGet, _super);
    function ANodeExprLValueSetGet(setTemplate, getTemplate, replacements) {
        _super.call(this);
        this.setTemplate = setTemplate;
        this.getTemplate = getTemplate;
        this.replacements = replacements;
    }
    ANodeExprLValueSetGet.prototype._toJs = function (template, right) {
        var _this = this;
        return template.replace(/(\$\d|#)/g, function (match) {
            if (match == '#') {
                return right.toJs();
            }
            else if (match.startsWith('$')) {
                return _this.replacements[parseInt(match.substr(1))].toJs();
            }
        });
    };
    ANodeExprLValueSetGet.prototype.toAssignJs = function (right) {
        return this._toJs(this.setTemplate, right);
    };
    ANodeExprLValueSetGet.prototype.toJs = function () {
        return this._toJs(this.getTemplate);
    };
    return ANodeExprLValueSetGet;
})(ANodeExpr);
exports.ANodeExprLValueSetGet = ANodeExprLValueSetGet;
var ANodeExprLValueVar = (function (_super) {
    __extends(ANodeExprLValueVar, _super);
    function ANodeExprLValueVar(name) {
        _super.call(this);
        this.name = name;
    }
    ANodeExprLValueVar.prototype.toAssignJs = function (right) { return this.name + ' = ' + right.toJs(); };
    ANodeExprLValueVar.prototype.toJs = function () { return this.name; };
    return ANodeExprLValueVar;
})(ANodeExprLValue);
exports.ANodeExprLValueVar = ANodeExprLValueVar;
var ANodeExprI32 = (function (_super) {
    __extends(ANodeExprI32, _super);
    function ANodeExprI32(value) {
        _super.call(this);
        this.value = value;
    }
    ANodeExprI32.prototype.toJs = function () { return String(this.value); };
    return ANodeExprI32;
})(ANodeExpr);
exports.ANodeExprI32 = ANodeExprI32;
var ANodeExprFloat = (function (_super) {
    __extends(ANodeExprFloat, _super);
    function ANodeExprFloat(value) {
        _super.call(this);
        this.value = value;
    }
    ANodeExprFloat.prototype.toJs = function () {
        var rfloat = MathFloat.reinterpretFloatAsInt(this.value);
        if (rfloat & 0x80000000) {
            return '-' + MathFloat.reinterpretIntAsFloat(rfloat & 0x7FFFFFFF);
        }
        else {
            return String(this.value);
        }
    };
    return ANodeExprFloat;
})(ANodeExpr);
exports.ANodeExprFloat = ANodeExprFloat;
var ANodeExprU32 = (function (_super) {
    __extends(ANodeExprU32, _super);
    function ANodeExprU32(value) {
        _super.call(this);
        this.value = value;
    }
    ANodeExprU32.prototype.toJs = function () {
        return '0x' + IntUtils.toHexString(this.value, 8);
    };
    return ANodeExprU32;
})(ANodeExpr);
exports.ANodeExprU32 = ANodeExprU32;
var ANodeExprBinop = (function (_super) {
    __extends(ANodeExprBinop, _super);
    function ANodeExprBinop(left, op, right) {
        _super.call(this);
        this.left = left;
        this.op = op;
        this.right = right;
        if (!this.left || !this.left.toJs)
            debugger;
        if (!this.right || !this.right.toJs)
            debugger;
    }
    ANodeExprBinop.prototype.toJs = function () { return '(' + this.left.toJs() + ' ' + this.op + ' ' + this.right.toJs() + ')'; };
    return ANodeExprBinop;
})(ANodeExpr);
exports.ANodeExprBinop = ANodeExprBinop;
var ANodeExprUnop = (function (_super) {
    __extends(ANodeExprUnop, _super);
    function ANodeExprUnop(op, right) {
        _super.call(this);
        this.op = op;
        this.right = right;
    }
    ANodeExprUnop.prototype.toJs = function () { return '(' + this.op + '(' + this.right.toJs() + '))'; };
    return ANodeExprUnop;
})(ANodeExpr);
exports.ANodeExprUnop = ANodeExprUnop;
var ANodeExprAssign = (function (_super) {
    __extends(ANodeExprAssign, _super);
    function ANodeExprAssign(left, right) {
        _super.call(this);
        this.left = left;
        this.right = right;
        if (!this.left || !this.left.toAssignJs)
            debugger;
        if (!this.right)
            debugger;
    }
    ANodeExprAssign.prototype.toJs = function () { return this.left.toAssignJs(this.right); };
    return ANodeExprAssign;
})(ANodeExpr);
exports.ANodeExprAssign = ANodeExprAssign;
var ANodeExprArray = (function (_super) {
    __extends(ANodeExprArray, _super);
    function ANodeExprArray(_items) {
        _super.call(this);
        this._items = _items;
    }
    ANodeExprArray.prototype.toJs = function () { return '[' + this._items.map(function (item) { return item.toJs(); }).join(', ') + ']'; };
    return ANodeExprArray;
})(ANodeExpr);
exports.ANodeExprArray = ANodeExprArray;
var ANodeExprCall = (function (_super) {
    __extends(ANodeExprCall, _super);
    function ANodeExprCall(name, _arguments) {
        _super.call(this);
        this.name = name;
        this._arguments = _arguments;
        if (!_arguments)
            debugger;
        this._arguments.forEach(function (argument) {
            if (!argument || !(argument instanceof ANodeExpr))
                debugger;
        });
    }
    ANodeExprCall.prototype.toJs = function () { return this.name + '(' + this._arguments.map(function (argument) { return argument.toJs(); }).join(', ') + ')'; };
    return ANodeExprCall;
})(ANodeExpr);
exports.ANodeExprCall = ANodeExprCall;
var ANodeStmIf = (function (_super) {
    __extends(ANodeStmIf, _super);
    function ANodeStmIf(cond, codeTrue, codeFalse) {
        _super.call(this);
        this.cond = cond;
        this.codeTrue = codeTrue;
        this.codeFalse = codeFalse;
    }
    ANodeStmIf.prototype.toJs = function () {
        var result = '';
        result += 'if (' + this.cond.toJs() + ')';
        result += ' { ' + this.codeTrue.toJs() + ' }';
        if (this.codeFalse)
            result += ' else { ' + this.codeFalse.toJs() + ' }';
        return result;
    };
    return ANodeStmIf;
})(ANodeStm);
exports.ANodeStmIf = ANodeStmIf;
var AstBuilder = (function () {
    function AstBuilder() {
    }
    AstBuilder.prototype.assign = function (ref, value) { return new ANodeExprAssign(ref, value); };
    AstBuilder.prototype._if = function (cond, codeTrue, codeFalse) { return new ANodeStmIf(cond, codeTrue, codeFalse); };
    AstBuilder.prototype.binop = function (left, op, right) { return new ANodeExprBinop(left, op, right); };
    AstBuilder.prototype.unop = function (op, right) { return new ANodeExprUnop(op, right); };
    AstBuilder.prototype.binop_i = function (left, op, right) { return this.binop(left, op, this.imm32(right)); };
    AstBuilder.prototype.imm32 = function (value) { return new ANodeExprI32(value); };
    AstBuilder.prototype.imm_f = function (value) { return new ANodeExprFloat(value); };
    AstBuilder.prototype.u_imm32 = function (value) { return new ANodeExprU32(value); };
    AstBuilder.prototype.stm = function (expr) { return expr ? (new ANodeStmExpr(expr)) : new ANodeStm(); };
    AstBuilder.prototype.stms = function (stms) { return new ANodeStmList(stms); };
    AstBuilder.prototype.array = function (exprList) { return new ANodeExprArray(exprList); };
    AstBuilder.prototype.arrayNumbers = function (values) {
        var _this = this;
        return this.array(values.map(function (value) { return _this.imm_f(value); }));
    };
    AstBuilder.prototype.call = function (name, exprList) { return new ANodeExprCall(name, exprList); };
    AstBuilder.prototype.jump = function (label) { return new ANodeStmJump(label); };
    AstBuilder.prototype._return = function () { return new ANodeStmReturn(); };
    AstBuilder.prototype.raw_stm = function (content) { return new ANodeStmRaw(content); };
    AstBuilder.prototype.raw = function (content) { return new ANodeExprLValueVar(content); };
    AstBuilder.prototype.allocVar = function (name, initialValue) { return new ANodeAllocVarStm(name, initialValue); };
    return AstBuilder;
})();
exports.AstBuilder = AstBuilder;
var MipsAstBuilder = (function (_super) {
    __extends(MipsAstBuilder, _super);
    function MipsAstBuilder() {
        _super.apply(this, arguments);
    }
    MipsAstBuilder.prototype.debugger = function (comment) {
        if (comment === void 0) { comment = '-'; }
        return new ANodeStmRaw("debugger; // " + comment + "\n");
    };
    MipsAstBuilder.prototype.functionPrefix = function () { return this.stm(); };
    MipsAstBuilder.prototype.gpr = function (index) {
        if (index === 0)
            return new ANodeExprLValueVar('0');
        return new ANodeExprLValueVar('state.gpr[' + index + ']');
    };
    MipsAstBuilder.prototype.gpr_f = function (index) {
        if (index === 0)
            return new ANodeExprLValueVar('0');
        return new ANodeExprLValueVar('state.gpr_f[' + index + ']');
    };
    MipsAstBuilder.prototype.tempr = function (index) { return new ANodeExprLValueVar('state.temp[' + index + ']'); };
    MipsAstBuilder.prototype.vector_vs = function (index) { return new ANodeExprLValueVar('state.vector_vs[' + index + ']'); };
    MipsAstBuilder.prototype.vector_vt = function (index) { return new ANodeExprLValueVar('state.vector_vt[' + index + ']'); };
    MipsAstBuilder.prototype.vfpr = function (index) { return new ANodeExprLValueVar('state.vfpr[' + index + ']'); };
    MipsAstBuilder.prototype.vfprc = function (index) { return new ANodeExprLValueVar('state.vfprc[' + index + ']'); };
    MipsAstBuilder.prototype.vfpr_i = function (index) { return new ANodeExprLValueVar('state.vfpr_i[' + index + ']'); };
    MipsAstBuilder.prototype.fpr = function (index) { return new ANodeExprLValueVar('state.fpr[' + index + ']'); };
    MipsAstBuilder.prototype.fpr_i = function (index) { return new ANodeExprLValueVar('state.fpr_i[' + index + ']'); };
    MipsAstBuilder.prototype.fcr31_cc = function () { return new ANodeExprLValueVar('state.fcr31_cc'); };
    MipsAstBuilder.prototype.lo = function () { return new ANodeExprLValueVar('state.LO'); };
    MipsAstBuilder.prototype.hi = function () { return new ANodeExprLValueVar('state.HI'); };
    MipsAstBuilder.prototype.ic = function () { return new ANodeExprLValueVar('state.IC'); };
    MipsAstBuilder.prototype.pc = function () { return new ANodeExprLValueVar('state.PC'); };
    MipsAstBuilder.prototype.VCC = function (index) {
        return new ANodeExprLValueSetGet('state.setVfrCc($0, #)', 'state.getVfrCc($0)', [this.imm32(index)]);
    };
    MipsAstBuilder.prototype.ra = function () { return new ANodeExprLValueVar('state.gpr[31]'); };
    MipsAstBuilder.prototype.branchflag = function () { return new ANodeExprLValueVar('state.BRANCHFLAG'); };
    MipsAstBuilder.prototype.branchpc = function () { return new ANodeExprLValueVar('state.BRANCHPC'); };
    MipsAstBuilder.prototype.assignGpr = function (index, expr) {
        if (index == 0)
            return this.stm();
        return this.stm(this.assign(this.gpr(index), expr));
    };
    MipsAstBuilder.prototype.assignIC = function (expr) { return this.stm(this.assign(this.ic(), expr)); };
    MipsAstBuilder.prototype.assignFpr = function (index, expr) { return this.stm(this.assign(this.fpr(index), expr)); };
    MipsAstBuilder.prototype.assignFpr_I = function (index, expr) { return this.stm(this.assign(this.fpr_i(index), expr)); };
    return MipsAstBuilder;
})(AstBuilder);
exports.MipsAstBuilder = MipsAstBuilder;

},
"src/core/cpu/codegen": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _ast = require('./ast_builder');
var ast;
function assignGpr(index, expr) { return ast.assignGpr(index, expr); }
function assignFpr(index, expr) { return ast.assignFpr(index, expr); }
function assignFpr_I(index, expr) { return ast.assignFpr_I(index, expr); }
function assignIC(expr) { return ast.assignIC(expr); }
function fcr31_cc() { return ast.fcr31_cc(); }
function fpr(index) { return ast.fpr(index); }
function fpr_i(index) { return ast.fpr_i(index); }
function gpr(index) { return ast.gpr(index); }
function gpr_f(index) { return ast.gpr_f(index); }
function tempr(index) { return ast.tempr(index); }
function vfpr(reg) { return ast.vfpr(reg); }
function vfprc(reg) { return ast.vfprc(reg); }
function vfpr_i(index) { return ast.vfpr_i(index); }
function immBool(value) { return ast.imm32(value ? 1 : 0); }
function imm32(value) { return ast.imm32(value); }
function imm_f(value) { return ast.imm_f(value); }
function u_imm32(value) { return ast.u_imm32(value); }
function unop(op, right) { return ast.unop(op, right); }
function binop(left, op, right) { return ast.binop(left, op, right); }
function binop_i(left, op, right) { return ast.binop_i(left, op, right); }
function _if(cond, codeTrue, codeFalse) { return ast._if(cond, codeTrue, codeFalse); }
function call(name, exprList) { return ast.call(name, exprList); }
function call_stm(name, exprList) { return stm(ast.call(name, exprList)); }
function stm(expr) { return ast.stm(expr); }
function stms(stms) { return ast.stms(stms); }
function pc() { return ast.pc(); }
function lo() { return ast.lo(); }
function hi() { return ast.hi(); }
function ic() { return ast.ic(); }
function branchflag() { return ast.branchflag(); }
function branchpc() { return ast.branchpc(); }
function assign(ref, value) { return ast.assign(ref, value); }
function assign_stm(ref, value) { return stm(ast.assign(ref, value)); }
function i_simm16(i) { return imm32(i.imm16); }
function i_uimm16(i) { return u_imm32(i.u_imm16); }
function rs_imm16(i) { return binop(binop(gpr(i.rs), '+', imm32(i.imm16)), '|', imm32(0)); }
function cast_uint(expr) { return binop(expr, '>>>', ast.imm32(0)); }
var VMatRegClass = (function () {
    function VMatRegClass(reg) {
        this.reg = reg;
    }
    VMatRegClass.prototype._setMatrix = function (generator) {
        var array = [];
        for (var column = 0; column < 4; column++) {
            for (var row = 0; row < 4; row++) {
                array.push(generator(column, row));
            }
        }
        return stm(ast.call('state.vfpuSetMatrix', [imm32(this.reg), ast.array(array)]));
    };
    VMatRegClass.prototype.setMatrix = function (generator) {
        return stms([
            this._setMatrix(generator),
            stm(ast.debugger('wip vfpu'))
        ]);
    };
    VMatRegClass.prototype.setMatrixDebug = function (generator) {
        return stms([
            this._setMatrix(generator),
            stm(ast.debugger('wip vfpu'))
        ]);
    };
    return VMatRegClass;
})();
var VVecRegClass = (function () {
    function VVecRegClass(reg, size) {
        this.reg = reg;
    }
    VVecRegClass.prototype._setVector = function (generator) {
        var array = [];
        var statements = [];
        var regs = getVectorRegs(this.reg, VectorSize.Quad);
        statements.push(stm(ast.call('state.vfpuStore', [
            ast.array(regs.map(function (item) { return imm32(item); })),
            ast.array([0, 1, 2, 3].map(function (index) { return generator(index); }))
        ])));
        return stms(statements);
    };
    VVecRegClass.prototype.setVector = function (generator) {
        return stms([
            this._setVector(generator),
            stm(ast.debugger('wip vfpu'))
        ]);
    };
    return VVecRegClass;
})();
function VMatReg(index) {
    return new VMatRegClass(index);
}
function VVecReg(index, size) {
    return new VVecRegClass(index, size);
}
(function (VectorSize) {
    VectorSize[VectorSize["Single"] = 1] = "Single";
    VectorSize[VectorSize["Pair"] = 2] = "Pair";
    VectorSize[VectorSize["Triple"] = 3] = "Triple";
    VectorSize[VectorSize["Quad"] = 4] = "Quad";
})(exports.VectorSize || (exports.VectorSize = {}));
var VectorSize = exports.VectorSize;
(function (MatrixSize) {
    MatrixSize[MatrixSize["M_2x2"] = 2] = "M_2x2";
    MatrixSize[MatrixSize["M_3x3"] = 3] = "M_3x3";
    MatrixSize[MatrixSize["M_4x4"] = 4] = "M_4x4";
})(exports.MatrixSize || (exports.MatrixSize = {}));
var MatrixSize = exports.MatrixSize;
;
function getVectorRegs(vectorReg, N) {
    var mtx = (vectorReg >>> 2) & 7;
    var col = vectorReg & 3;
    var row = 0;
    var length = 0;
    var transpose = (vectorReg >>> 5) & 1;
    switch (N) {
        case VectorSize.Single:
            transpose = 0;
            row = (vectorReg >>> 5) & 3;
            length = 1;
            break;
        case VectorSize.Pair:
            row = (vectorReg >>> 5) & 2;
            length = 2;
            break;
        case VectorSize.Triple:
            row = (vectorReg >>> 6) & 1;
            length = 3;
            break;
        case VectorSize.Quad:
            row = (vectorReg >>> 5) & 2;
            length = 4;
            break;
        default: debugger;
    }
    var regs = new Array(length);
    for (var i = 0; i < length; i++) {
        var index = mtx * 4;
        if (transpose) {
            index += ((row + i) & 3) + col * 32;
        }
        else {
            index += col + ((row + i) & 3) * 32;
        }
        regs[i] = index;
    }
    return regs;
}
function getMatrixRegs(matrixReg, N) {
    var mtx = (matrixReg >> 2) & 7;
    var col = matrixReg & 3;
    var row = 0;
    var side = 0;
    switch (N) {
        case MatrixSize.M_2x2:
            row = (matrixReg >> 5) & 2;
            side = 2;
            break;
        case MatrixSize.M_3x3:
            row = (matrixReg >> 6) & 1;
            side = 3;
            break;
        case MatrixSize.M_4x4:
            row = (matrixReg >> 5) & 2;
            side = 4;
            break;
        default: debugger;
    }
    var transpose = (matrixReg >> 5) & 1;
    var regs = new Array(side * side);
    for (var i = 0; i < side; i++) {
        for (var j = 0; j < side; j++) {
            var index = mtx * 4;
            if (transpose) {
                index += ((row + i) & 3) + ((col + j) & 3) * 32;
            }
            else {
                index += ((col + j) & 3) + ((row + i) & 3) * 32;
            }
            regs[j * side + i] = index;
        }
    }
    return regs;
}
function readVector_f(vectorReg, N) {
    return getVectorRegs(vectorReg, N).map(function (index) { return vfpr(index); });
}
function readVector_i(vectorReg, N) {
    return getVectorRegs(vectorReg, N).map(function (index) { return vfpr_i(index); });
}
function readVector_type(vectorReg, N, type) {
    return (type == 'float') ? readVector_f(vectorReg, N) : readVector_i(vectorReg, N);
}
function readMatrix(vectorReg, N) {
    return getMatrixRegs(vectorReg, N).map(function (index) { return vfpr(index); });
}
function setMemoryVector(offset, items) {
    return call_stm('state.storeFloats', [offset, ast.array(items)]);
}
function memoryRef(type, address) {
    switch (type) {
        case 'float': return new _ast.ANodeExprLValueSetGet('state.swc1($0, #)', 'state.lwc1($0)', [address]);
        default: throw (new Error("Not implemented memoryRef type '" + type + "'"));
    }
}
function getMemoryVector(offset, count) {
    return ArrayUtils.range(0, count).map(function (item) { return memoryRef('float', binop(offset, '+', imm32(item * 4))); });
}
function setItems(leftList, values) {
    return stms(leftList.map(function (left, index) { return ast.assign(left, values[index]); }));
}
function address_RS_IMM14(i, offset) {
    if (offset === void 0) { offset = 0; }
    return binop(gpr(i.rs), '+', imm32(i.IMM14 * 4 + offset));
}
function setMatrix(leftList, generator) {
    var side = Math.sqrt(leftList.length);
    return call_stm('state.vfpuStore', [
        ast.array(leftList.map(function (item) { return imm32(item); })),
        ast.array(ArrayUtils.range(0, leftList.length).map(function (index) { return generator(Math.floor(index % side), Math.floor(index / side), index); }))
    ]);
}
function setVector(leftList, generator) {
    return call_stm('state.vfpuStore', [
        ast.array(leftList.map(function (item) { return imm32(item); })),
        ast.array(ArrayUtils.range(0, leftList.length).map(function (index) { return generator(index); }))
    ]);
}
function setVector_i(leftList, generator) {
    return call_stm('state.vfpuStore_i', [
        ast.array(leftList.map(function (item) { return imm32(item); })),
        ast.array(ArrayUtils.range(0, leftList.length).map(function (index) { return generator(index); }))
    ]);
}
var VfpuConstants = [
    { name: "VFPU_ZERO", value: 0.0 },
    { name: "VFPU_HUGE", value: 340282346638528859811704183484516925440 },
    { name: "VFPU_SQRT2", value: Math.sqrt(2.0) },
    { name: "VFPU_SQRT1_2", value: Math.sqrt(1.0 / 2.0) },
    { name: "VFPU_2_SQRTPI", value: 2.0 / Math.sqrt(Math.PI) },
    { name: "VFPU_2_PI", value: 2.0 / Math.PI },
    { name: "VFPU_1_PI", value: 1.0 / Math.PI },
    { name: "VFPU_PI_4", value: Math.PI / 4.0 },
    { name: "VFPU_PI_2", value: Math.PI / 2.0 },
    { name: "VFPU_PI", value: Math.PI },
    { name: "VFPU_E", value: Math.E },
    { name: "VFPU_LOG2E", value: Math.log2(Math.E) },
    { name: "VFPU_LOG10E", value: Math.log10(Math.E) },
    { name: "VFPU_LN2", value: Math.log(2) },
    { name: "VFPU_LN10", value: Math.log(10) },
    { name: "VFPU_2PI", value: 2.0 * Math.PI },
    { name: "VFPU_PI_6", value: Math.PI / 6.0 },
    { name: "VFPU_LOG10TWO", value: Math.log10(2.0) },
    { name: "VFPU_LOG2TEN", value: Math.log2(10.0) },
    { name: "VFPU_SQRT3_2", value: Math.sqrt(3.0) / 2.0 },
];
function getMatrixRegsVD(i) {
    return getMatrixRegs(i.VD, i.ONE_TWO);
}
var VfpuPrefixes = (function () {
    function VfpuPrefixes() {
    }
    VfpuPrefixes.transformRead = function (n, info, values) {
        var sourceIndex = (info >> (0 + n * 2)) & 3;
        var sourceAbsolute = (info >> (8 + n * 1)) & 1;
        var sourceConstant = (info >> (12 + n * 1)) & 1;
        var sourceNegate = (info >> (16 + n * 1)) & 1;
        var value;
        if (sourceConstant) {
            switch (sourceIndex) {
                case 0:
                    value = imm_f(sourceAbsolute ? (3) : (0));
                    break;
                case 1:
                    value = imm_f(sourceAbsolute ? (1 / 3) : (1));
                    break;
                case 2:
                    value = imm_f(sourceAbsolute ? (1 / 4) : (2));
                    break;
                case 3:
                    value = imm_f(sourceAbsolute ? (1 / 6) : (1 / 2));
                    break;
                default:
                    throw (new Error("Invalid operation"));
                    break;
            }
        }
        else {
            value = values[sourceIndex];
            if (sourceAbsolute)
                value = call('Math.abs', [value]);
        }
        if (sourceNegate)
            value = call('MathFloat.neg', [value]);
        return value;
    };
    VfpuPrefixes.transformStore = function (n, info, left, value) {
        var destinationSaturation = (info >> (0 + n * 2)) & 3;
        var destinationMask = (info >> (8 + n * 1)) & 1;
        if (destinationMask) {
            return ast.stm();
        }
        else {
            var value = value;
            switch (destinationSaturation) {
                case 1:
                    value = call('MathFloat.sat0', [value]);
                    break;
                case 3:
                    value = call('MathFloat.sat1', [value]);
                    break;
                default: break;
            }
            return assign_stm(left, value);
        }
    };
    return VfpuPrefixes;
})();
var PrefixPrediction = (function () {
    function PrefixPrediction(default_value) {
        this.default_value = default_value;
        this.known = true;
        this.value = this.default_value;
    }
    PrefixPrediction.prototype.reset = function () {
        this.set(this.default_value);
    };
    PrefixPrediction.prototype.eat = function () {
        this.set(this.default_value);
    };
    PrefixPrediction.prototype.set = function (value) {
        this.known = true;
        this.value = value;
    };
    PrefixPrediction.prototype.setUnknown = function () {
        this.known = false;
        this.value = this.default_value;
    };
    PrefixPrediction.DEFAULT_LOAD_VALUE = 0xDC0000E4;
    PrefixPrediction.DEFAULT_STORE_VALUE = 0x00000000;
    return PrefixPrediction;
})();
var InstructionAst = (function () {
    function InstructionAst() {
        this._vpfxs = new PrefixPrediction(PrefixPrediction.DEFAULT_LOAD_VALUE);
        this._vpfxt = new PrefixPrediction(PrefixPrediction.DEFAULT_LOAD_VALUE);
        this._vpfxd = new PrefixPrediction(PrefixPrediction.DEFAULT_STORE_VALUE);
        this.enableStaticPrefixVfpuOptimization = true;
        ast = new _ast.MipsAstBuilder();
    }
    InstructionAst.prototype.reset = function () {
        this._vpfxs.reset();
        this._vpfxt.reset();
        this._vpfxd.reset();
    };
    InstructionAst.prototype.eatPrefixes = function () {
        this._vpfxs.eat();
        this._vpfxt.eat();
        this._vpfxd.eat();
    };
    InstructionAst.prototype.lui = function (i) { return assignGpr(i.rt, u_imm32(i.imm16 << 16)); };
    InstructionAst.prototype._vset1 = function (i, generate, destSize, destType) {
        if (destSize === void 0) { destSize = 0; }
        if (destType === void 0) { destType = 'float'; }
        var st = [];
        this._vset_storeVD(st, i, destType, destSize, function (index) { return generate(index); });
        return stms(st);
    };
    InstructionAst.prototype._vset2 = function (i, generate, destSize, srcSize, destType, srcType) {
        if (destSize === void 0) { destSize = 0; }
        if (srcSize === void 0) { srcSize = 0; }
        if (destType === void 0) { destType = 'float'; }
        if (srcType === void 0) { srcType = 'float'; }
        var st = [];
        var src = this._vset_readVS(st, i, srcType, srcSize);
        this._vset_storeVD(st, i, destType, destSize, function (index) { return generate(index, src); });
        return stms(st);
    };
    InstructionAst.prototype._vset3 = function (i, generate, destSize, srcSize, targetSize, destType, srcType, targetType) {
        if (destSize === void 0) { destSize = 0; }
        if (srcSize === void 0) { srcSize = 0; }
        if (targetSize === void 0) { targetSize = 0; }
        if (destType === void 0) { destType = 'float'; }
        if (srcType === void 0) { srcType = 'float'; }
        if (targetType === void 0) { targetType = 'float'; }
        var st = [];
        var src = this._vset_readVS(st, i, srcType, srcSize);
        var target = this._vset_readVT(st, i, targetType, targetSize);
        this._vset_storeVD(st, i, destType, destSize, function (index) { return generate(index, src, target); });
        return stms(st);
    };
    InstructionAst.prototype._vset_readVS = function (st, i, type, size) {
        return this._vset_readVSVT(st, i, type, size, 'vs');
    };
    InstructionAst.prototype._vset_readVT = function (st, i, type, size) {
        return this._vset_readVSVT(st, i, type, size, 'vt');
    };
    InstructionAst.prototype._vset_readVSVT = function (st, i, type, size, name) {
        if (size <= 0)
            size = i.ONE_TWO;
        var regs = readVector_type((name == 'vs') ? i.VS : i.VT, size, type);
        var prefix = (name == 'vs') ? this._vpfxs : this._vpfxt;
        if (this.enableStaticPrefixVfpuOptimization && prefix.known) {
            var out = [];
            for (var n = 0; n < size; n++) {
                var vname = ((name == 'vs') ? 's' : 't') + n;
                out.push(ast.raw(vname));
                st.push(ast.allocVar(vname, VfpuPrefixes.transformRead(n, prefix.value, regs)));
            }
            return out;
        }
        else {
            st.push(call_stm(((name == 'vs') ? 'state.loadVs_prefixed' : 'state.loadVt_prefixed'), [ast.array(regs)]));
        }
        return xrange(0, size).map(function (index) { return (name == 'vs') ? ast.vector_vs(index) : ast.vector_vt(index); });
    };
    InstructionAst.prototype._vset_storeVD = function (st, i, type, size, generate) {
        if (size <= 0)
            size = i.ONE_TWO;
        var dest_regs = getVectorRegs(i.VD, size);
        if (this.enableStaticPrefixVfpuOptimization && this._vpfxd.known) {
            for (var n = 0; n < size; n++) {
                var dest_reg = dest_regs[n];
                st.push(VfpuPrefixes.transformStore(n, this._vpfxd.value, (type == 'float') ? vfpr(dest_reg) : vfpr_i(dest_reg), generate(n)));
            }
        }
        else {
            st.push(call_stm((type == 'float') ? 'state.storeVd_prefixed' : 'state.storeVd_prefixed_i', [
                ast.arrayNumbers(dest_regs),
                ast.array(xrange(0, size).map(function (n) { return generate(n); })),
            ]));
        }
        st.push(call_stm('state.eatPrefixes', []));
        this.eatPrefixes();
    };
    InstructionAst.prototype.vpfxs = function (i) {
        this._vpfxs.set(i.data);
        return stms([
            call_stm('state.setVpfxs', [imm32(i.data)]),
        ]);
    };
    InstructionAst.prototype.vpfxt = function (i) {
        this._vpfxt.set(i.data);
        return stms([
            call_stm('state.setVpfxt', [imm32(i.data)]),
        ]);
    };
    InstructionAst.prototype.vpfxd = function (i) {
        this._vpfxd.set(i.data);
        return stms([
            call_stm('state.setVpfxd', [imm32(i.data)]),
        ]);
    };
    InstructionAst.prototype["lv.s"] = function (i) { return assign_stm(vfpr(i.VT5_2), call('state.lwc1', [address_RS_IMM14(i, 0)])); };
    InstructionAst.prototype["sv.s"] = function (i) { return call_stm('state.swc1', [vfpr(i.VT5_2), address_RS_IMM14(i, 0)]); };
    InstructionAst.prototype["lv.q"] = function (i) { return setItems(readVector_f(i.VT5_1, VectorSize.Quad), getMemoryVector(address_RS_IMM14(i), 4)); };
    InstructionAst.prototype["lvl.q"] = function (i) { return call_stm('state.lvl_q', [address_RS_IMM14(i, 0), ast.array(getVectorRegs(i.VT5_1, VectorSize.Quad).map(function (item) { return imm32(item); }))]); };
    InstructionAst.prototype["lvr.q"] = function (i) { return call_stm('state.lvr_q', [address_RS_IMM14(i, 0), ast.array(getVectorRegs(i.VT5_1, VectorSize.Quad).map(function (item) { return imm32(item); }))]); };
    InstructionAst.prototype["sv.q"] = function (i) { return setMemoryVector(address_RS_IMM14(i), readVector_f(i.VT5_1, VectorSize.Quad)); };
    InstructionAst.prototype["svl.q"] = function (i) { return call_stm('state.svl_q', [address_RS_IMM14(i, 0), ast.array(getVectorRegs(i.VT5_1, VectorSize.Quad).map(function (item) { return imm32(item); }))]); };
    InstructionAst.prototype["svr.q"] = function (i) { return call_stm('state.svr_q', [address_RS_IMM14(i, 0), ast.array(getVectorRegs(i.VT5_1, VectorSize.Quad).map(function (item) { return imm32(item); }))]); };
    InstructionAst.prototype.viim = function (i) { return assign_stm(vfpr(i.VT), imm32(i.imm16)); };
    InstructionAst.prototype.vfim = function (i) { return assign_stm(vfpr(i.VT), imm_f(i.IMM_HF)); };
    InstructionAst.prototype.vcst = function (i) { return assign_stm(vfpr(i.VD), imm_f(VfpuConstants[i.IMM5].value)); };
    InstructionAst.prototype.vhdp = function (i) {
        var _this = this;
        var vectorSize = i.ONE_TWO;
        return this._vset3(i, function (_, src, target) {
            return _this._aggregateV(imm_f(0), vectorSize, function (aggregate, index) {
                return binop(aggregate, '+', binop(target[index], '*', (index == (vectorSize - 1)) ? imm_f(1.0) : src[index]));
            });
        }, 1, vectorSize, vectorSize);
    };
    InstructionAst.prototype.vmidt = function (i) { return setMatrix(getMatrixRegsVD(i), function (c, r) { return imm32((c == r) ? 1 : 0); }); };
    InstructionAst.prototype.vmzero = function (i) { return setMatrix(getMatrixRegsVD(i), function (c, r) { return imm32(0); }); };
    InstructionAst.prototype.vmone = function (i) { return setMatrix(getMatrixRegsVD(i), function (c, r) { return imm32(1); }); };
    InstructionAst.prototype._vtfm_x = function (i, vectorSize) {
        var _this = this;
        var srcMat = readMatrix(i.VS, vectorSize);
        var st = [];
        st.push(call_stm('state.loadVt_prefixed', [ast.array(readVector_f(i.VT, vectorSize))]));
        st.push(call_stm('state.storeVd_prefixed', [
            ast.arrayNumbers(getVectorRegs(i.VD, vectorSize)),
            ast.array(xrange(0, vectorSize).map(function (n) {
                return _this._aggregateV(imm_f(0), vectorSize, function (aggregated, m) { return binop(aggregated, '+', binop(srcMat[n * vectorSize + m], '*', ast.vector_vt(m))); });
            })),
        ]));
        this.eatPrefixes();
        return stms(st);
    };
    InstructionAst.prototype._vhtfm_x = function (i, vectorSize) {
        var _this = this;
        var srcMat = readMatrix(i.VS, vectorSize);
        var st = [];
        st.push(call_stm('state.loadVt_prefixed', [ast.array(readVector_f(i.VT, vectorSize))]));
        st.push(call_stm('state.storeVd_prefixed', [
            ast.arrayNumbers(getVectorRegs(i.VD, vectorSize)),
            ast.array(xrange(0, vectorSize).map(function (n) {
                return _this._aggregateV(imm_f(0), vectorSize, function (aggregated, m) { return binop(aggregated, '+', binop(srcMat[n * vectorSize + m], '*', ((m == vectorSize - 1) ? imm_f(1) : ast.vector_vt(m)))); });
            })),
        ]));
        this.eatPrefixes();
        return stms(st);
    };
    InstructionAst.prototype.vtfm2 = function (i) { return this._vtfm_x(i, 2); };
    InstructionAst.prototype.vtfm3 = function (i) { return this._vtfm_x(i, 3); };
    InstructionAst.prototype.vtfm4 = function (i) { return this._vtfm_x(i, 4); };
    InstructionAst.prototype.vhtfm2 = function (i) { return this._vhtfm_x(i, 2); };
    InstructionAst.prototype.vhtfm3 = function (i) { return this._vhtfm_x(i, 3); };
    InstructionAst.prototype.vhtfm4 = function (i) { return this._vhtfm_x(i, 4); };
    InstructionAst.prototype.vmscl = function (i) {
        var vectorSize = i.ONE_TWO;
        var src = readMatrix(i.VS, vectorSize);
        return setMatrix(getMatrixRegsVD(i), function (c, r, index) { return binop(src[index], '*', vfpr(i.VT)); });
    };
    InstructionAst.prototype.vzero = function (i) { return this._vset1(i, function (i) { return imm_f(0); }); };
    InstructionAst.prototype.vone = function (i) { return this._vset1(i, function (i) { return imm_f(1); }); };
    InstructionAst.prototype.vmov = function (i) { return this._vset3(i, function (i, s, t) { return s[i]; }); };
    InstructionAst.prototype.vrcp = function (i) { return this._vset2(i, function (i, s) { return binop(imm_f(1.0), '/', s[i]); }); };
    InstructionAst.prototype.vmul = function (i) { return this._vset3(i, function (i, s, t) { return binop(s[i], '*', t[i]); }); };
    InstructionAst.prototype.vbfy1 = function (i) {
        return this._vset2(i, function (i, src) {
            switch (i) {
                case 0: return binop(src[0], '+', src[1]);
                case 1: return binop(src[0], '-', src[1]);
                case 2: return binop(src[2], '+', src[3]);
                case 3: return binop(src[2], '-', src[3]);
                default: throw (new Error("vbfy1: Invalid operation"));
            }
        });
    };
    InstructionAst.prototype.vbfy2 = function (i) {
        return this._vset2(i, function (i, src) {
            switch (i) {
                case 0: return binop(src[0], '+', src[2]);
                case 1: return binop(src[1], '+', src[3]);
                case 2: return binop(src[0], '-', src[2]);
                case 3: return binop(src[1], '-', src[3]);
                default: throw (new Error("vbfy1: Invalid operation"));
            }
        });
    };
    InstructionAst.prototype.vsocp = function (i) {
        var vectorSize = i.ONE_TWO;
        return this._vset2(i, function (index, src) {
            switch (index) {
                case 0: return ast.call('MathFloat.sat0', [binop(imm_f(1), '-', src[0])]);
                case 1: return ast.call('MathFloat.sat0', [src[0]]);
                case 2: return ast.call('MathFloat.sat0', [binop(imm_f(1), '-', src[1])]);
                case 3: return ast.call('MathFloat.sat0', [src[1]]);
                default: throw (new Error("vsocp: " + index));
            }
        }, vectorSize * 2, vectorSize);
    };
    InstructionAst.prototype.vsrt1 = function (i) {
        return this._vset2(i, function (i, src) {
            switch (i) {
                case 0: return call('MathFloat.min', [src[0], src[1]]);
                case 1: return call('MathFloat.max', [src[0], src[1]]);
                case 2: return call('MathFloat.min', [src[2], src[3]]);
                case 3: return call('MathFloat.max', [src[2], src[3]]);
                default: throw (new Error("vsrt1: Invalid operation"));
            }
        }, i.ONE_TWO, 4);
    };
    InstructionAst.prototype.vsrt2 = function (i) {
        return this._vset2(i, function (i, src) {
            switch (i) {
                case 0: return call('MathFloat.min', [src[0], src[3]]);
                case 1: return call('MathFloat.min', [src[1], src[2]]);
                case 2: return call('MathFloat.max', [src[1], src[2]]);
                case 3: return call('MathFloat.max', [src[0], src[3]]);
                default: throw (new Error("vsrt2: Invalid operation"));
            }
        }, i.ONE_TWO, 4);
    };
    InstructionAst.prototype.vsrt3 = function (i) {
        return this._vset2(i, function (i, src) {
            switch (i) {
                case 0: return call('MathFloat.max', [src[0], src[1]]);
                case 1: return call('MathFloat.min', [src[0], src[1]]);
                case 2: return call('MathFloat.max', [src[2], src[3]]);
                case 3: return call('MathFloat.min', [src[2], src[3]]);
                default: throw (new Error("vsrt3: Invalid operation"));
            }
        }, i.ONE_TWO, 4);
    };
    InstructionAst.prototype.vsrt4 = function (i) {
        return this._vset2(i, function (i, src) {
            switch (i) {
                case 0: return call('MathFloat.max', [src[0], src[3]]);
                case 1: return call('MathFloat.max', [src[1], src[2]]);
                case 2: return call('MathFloat.min', [src[1], src[2]]);
                case 3: return call('MathFloat.min', [src[0], src[3]]);
                default: throw (new Error("vsrt4: Invalid operation"));
            }
        }, i.ONE_TWO, 4);
    };
    InstructionAst.prototype.vrnds = function (i) { return call_stm('state.vrnds', []); };
    InstructionAst.prototype.vrndi = function (i) { return this._vset1(i, function (i) { return call('state.vrndi', []); }, undefined, 'int'); };
    InstructionAst.prototype.vrndf1 = function (i) { return this._vset1(i, function (i) { return call('state.vrndf1', []); }); };
    InstructionAst.prototype.vrndf2 = function (i) { return this._vset1(i, function (i) { return call('state.vrndf2', []); }); };
    InstructionAst.prototype._aggregateV = function (val, size, generator) {
        for (var n = 0; n < size; n++)
            val = generator(val, n);
        return val;
    };
    InstructionAst.prototype.vnop = function (i) { return ast.stm(); };
    InstructionAst.prototype.vsync = function (i) { return ast.stm(); };
    InstructionAst.prototype.vflush = function (i) { return ast.stm(); };
    InstructionAst.prototype.vfad = function (i) {
        var _this = this;
        var vectorSize = i.ONE_TWO;
        return this._vset2(i, function (i, src) {
            return _this._aggregateV(imm_f(0), vectorSize, function (value, index) { return binop(value, '+', src[index]); });
        }, 1, vectorSize);
    };
    InstructionAst.prototype.vavg = function (i) {
        var _this = this;
        var vectorSize = i.ONE_TWO;
        return this._vset2(i, function (i, src) {
            return binop(_this._aggregateV(imm_f(0), vectorSize, function (value, index) { return binop(value, '+', src[index]); }), '/', imm_f(vectorSize));
        }, 1, vectorSize);
    };
    InstructionAst.prototype.vidt = function (i) {
        return this._vset1(i, function (index) { return imm_f((index == (i.IMM7 % i.ONE_TWO)) ? 1 : 0); });
    };
    InstructionAst.prototype["vcrs.t"] = function (i) {
        return this._vset3(i, function (index, src, target) {
            switch (index) {
                case 0: return binop(src[1], '*', target[2]);
                case 1: return binop(src[2], '*', target[0]);
                case 2: return binop(src[0], '*', target[1]);
                default: throw (new Error("vcrs_t not implemented"));
            }
        }, 3, 3, 3);
    };
    InstructionAst.prototype["vcrsp.t"] = function (i) {
        return this._vset3(i, function (index, src, target) {
            switch (index) {
                case 0: return binop(binop(src[1], '*', target[2]), '-', binop(src[2], '*', target[1]));
                case 1: return binop(binop(src[2], '*', target[0]), '-', binop(src[0], '*', target[2]));
                case 2: return binop(binop(src[0], '*', target[1]), '-', binop(src[1], '*', target[0]));
                default: throw (new Error("vcrs_t assert"));
            }
        }, 3, 3, 3);
    };
    InstructionAst.prototype.vc2i = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vc2i', [imm32(index), src[0]]); }, 0, 1, 'int', 'int'); };
    InstructionAst.prototype.vuc2i = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vuc2i', [imm32(index), src[0]]); }, 0, 1, 'int', 'int'); };
    InstructionAst.prototype.vs2i = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vs2i', [imm32(index), src[Math.floor(index / 2)]]); }, i.ONE_TWO * 2, i.ONE_TWO, 'int', 'int'); };
    InstructionAst.prototype.vi2f = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vi2f', [src[index], imm32(-i.IMM5)]); }, 0, 0, 'float', 'int'); };
    InstructionAst.prototype.vi2uc = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vi2uc', [src[0], src[1], src[2], src[3]]); }, 1, 4, 'int', 'int'); };
    InstructionAst.prototype.vf2id = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vf2id', [src[index], imm32(i.IMM5)]); }, 0, 0, 'int', 'float'); };
    InstructionAst.prototype.vf2in = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vf2in', [src[index], imm32(i.IMM5)]); }, 0, 0, 'int', 'float'); };
    InstructionAst.prototype.vf2iu = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vf2iu', [src[index], imm32(i.IMM5)]); }, 0, 0, 'int', 'float'); };
    InstructionAst.prototype.vf2iz = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vf2iz', [src[index], imm32(i.IMM5)]); }, 0, 0, 'int', 'float'); };
    InstructionAst.prototype.vf2h = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vf2h', [imm32(index), src[index]]); }, 0, 0, 'float', 'float'); };
    InstructionAst.prototype.vh2f = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vh2f', [imm32(index), src[index]]); }, 0, 0, 'float', 'float'); };
    InstructionAst.prototype.vdet = function (i) {
        return this._vset3(i, function (i, s, t) {
            return binop(binop(s[0], '*', t[1]), '-', binop(s[1], '*', t[0]));
        }, 1, 2, 2);
    };
    InstructionAst.prototype.vqmul = function (i) {
        return this._vset3(i, function (i, s, t) {
            switch (i) {
                case 0: return call('MathVfpu.vqmul0', [s[0], s[1], s[2], s[3], t[0], t[1], t[2], t[3]]);
                case 1: return call('MathVfpu.vqmul1', [s[0], s[1], s[2], s[3], t[0], t[1], t[2], t[3]]);
                case 2: return call('MathVfpu.vqmul2', [s[0], s[1], s[2], s[3], t[0], t[1], t[2], t[3]]);
                case 3: return call('MathVfpu.vqmul3', [s[0], s[1], s[2], s[3], t[0], t[1], t[2], t[3]]);
            }
        }, 4, 4, 4);
    };
    InstructionAst.prototype.vslt = function (i) { return this._vset3(i, function (i, s, t) { return call('MathFloat.vslt', [s[i], t[i]]); }); };
    InstructionAst.prototype.vsle = function (i) { return this._vset3(i, function (i, s, t) { return call('MathFloat.vsle', [s[i], t[i]]); }); };
    InstructionAst.prototype.vsge = function (i) { return this._vset3(i, function (i, s, t) { return call('MathFloat.vsge', [s[i], t[i]]); }); };
    InstructionAst.prototype.vsgt = function (i) { return this._vset3(i, function (i, s, t) { return call('MathFloat.vsgt', [s[i], t[i]]); }); };
    InstructionAst.prototype.vscmp = function (i) { return this._vset3(i, function (i, s, t) { return call('MathFloat.sign2', [s[i], t[i]]); }); };
    InstructionAst.prototype._bvtf = function (i, cond) {
        var reg = i.IMM3;
        var branchExpr = ast.VCC(reg);
        if (!cond)
            branchExpr = unop("!", branchExpr);
        return this._branch(i, branchExpr);
    };
    InstructionAst.prototype.bvf = function (i) { return this._bvtf(i, false); };
    InstructionAst.prototype.bvt = function (i) { return this._bvtf(i, true); };
    InstructionAst.prototype.bvfl = function (i) { return this.bvf(i); };
    InstructionAst.prototype.bvtl = function (i) { return this.bvt(i); };
    InstructionAst.prototype.mtv = function (i) { return this._vset1(i, function (_) { return gpr(i.rt); }, 1, 'int'); };
    InstructionAst.prototype.mfv = function (i) { return assign_stm(gpr(i.rt), vfpr_i(i.VD)); };
    InstructionAst.prototype.mtvc = function (i) {
        switch (i.IMM7) {
            case 0:
                this._vpfxs.setUnknown();
                break;
            case 1:
                this._vpfxt.setUnknown();
                break;
            case 2:
                this._vpfxd.setUnknown();
                break;
        }
        return assign_stm(vfprc(i.IMM7), gpr(i.rt));
    };
    InstructionAst.prototype.mfvc = function (i) {
        return assign_stm(gpr(i.rt), vfprc(i.IMM7));
    };
    InstructionAst.prototype._vcmovtf = function (i, True) {
        var result = call_stm('state.vcmovtf', [
            imm32(i.IMM3),
            immBool(True),
            ast.arrayNumbers(getVectorRegs(i.VD, i.ONE_TWO)),
            ast.arrayNumbers(getVectorRegs(i.VS, i.ONE_TWO))
        ]);
        this.eatPrefixes();
        return result;
    };
    InstructionAst.prototype.vcmovt = function (i) { return this._vcmovtf(i, true); };
    InstructionAst.prototype.vcmovf = function (i) { return this._vcmovtf(i, false); };
    InstructionAst.prototype.vcmp = function (i) {
        var result = call_stm('state.vcmp', [
            imm32(i.IMM4),
            ast.array(readVector_f(i.VS, i.ONE_TWO)),
            ast.array(readVector_f(i.VT, i.ONE_TWO))
        ]);
        this.eatPrefixes();
        return result;
    };
    InstructionAst.prototype.vwbn = function (i) { return ast.stm(); };
    InstructionAst.prototype.vsbn = function (i) { return ast.stm(); };
    InstructionAst.prototype.vabs = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.abs', [src[i]]); }); };
    InstructionAst.prototype.vocp = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.ocp', [src[i]]); }); };
    InstructionAst.prototype.vneg = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.neg', [src[i]]); }); };
    InstructionAst.prototype.vsgn = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.sign', [src[i]]); }); };
    InstructionAst.prototype.vsat0 = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.sat0', [src[i]]); }); };
    InstructionAst.prototype.vsat1 = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.sat1', [src[i]]); }); };
    InstructionAst.prototype.vrsq = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.rsq', [src[i]]); }); };
    InstructionAst.prototype.vsin = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.sinv1', [src[i]]); }); };
    InstructionAst.prototype.vcos = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.cosv1', [src[i]]); }); };
    InstructionAst.prototype.vexp2 = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.exp2', [src[i]]); }); };
    InstructionAst.prototype.vrexp2 = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.rexp2', [src[i]]); }); };
    InstructionAst.prototype.vlog2 = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.log2', [src[i]]); }); };
    InstructionAst.prototype.vsqrt = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.sqrt', [src[i]]); }); };
    InstructionAst.prototype.vasin = function (i) {
        return stms([
            this._vset2(i, function (i, src) { return call('MathFloat.asinv1', [src[i]]); }),
        ]);
    };
    InstructionAst.prototype.vnsin = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.nsinv1', [src[i]]); }); };
    InstructionAst.prototype.vnrcp = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.nrcp', [src[i]]); }); };
    InstructionAst.prototype.vmin = function (i) { return this._vset3(i, function (i, src, target) { return call('MathFloat.min', [src[i], target[i]]); }); };
    InstructionAst.prototype.vmax = function (i) { return this._vset3(i, function (i, src, target) { return call('MathFloat.max', [src[i], target[i]]); }); };
    InstructionAst.prototype.vdiv = function (i) { return this._vset3(i, function (i, src, target) { return binop(src[i], '/', target[i]); }); };
    InstructionAst.prototype.vadd = function (i) { return this._vset3(i, function (i, src, target) { return binop(src[i], '+', target[i]); }); };
    InstructionAst.prototype.vsub = function (i) { return this._vset3(i, function (i, src, target) { return binop(src[i], '-', target[i]); }); };
    InstructionAst.prototype.vscl = function (i) { return this._vset3(i, function (i, src, target) { return binop(src[i], '*', target[0]); }, 0, 0, 1); };
    InstructionAst.prototype.vdot = function (i) {
        var _this = this;
        var vectorSize = i.ONE_TWO;
        return this._vset3(i, function (i, s, t) {
            return _this._aggregateV(imm_f(0), vectorSize, function (sum, n) { return binop(sum, '+', binop(s[n], '*', t[n])); });
        }, 1, vectorSize, vectorSize);
    };
    InstructionAst.prototype.vrot = function (i) {
        var vectorSize = i.ONE_TWO;
        var imm5 = i.IMM5;
        var cosIndex = BitUtils.extract(imm5, 0, 2);
        var sinIndex = BitUtils.extract(imm5, 2, 2);
        var negateSin = BitUtils.extractBool(imm5, 4);
        var dest = getVectorRegs(i.VD, i.ONE_TWO);
        return this._vset2(i, function (i, s) {
            var sine = call('MathFloat.sinv1', [s[0]]);
            var cosine = call('MathFloat.cosv1', [s[0]]);
            if (negateSin)
                sine = unop('-', sine);
            if (i == cosIndex)
                return cosine;
            if (i == sinIndex)
                return sine;
            return (sinIndex == cosIndex) ? sine : imm32(0);
        }, vectorSize, 1);
    };
    InstructionAst.prototype.vmmov = function (i) {
        var vectorSize = i.ONE_TWO;
        var dest = getMatrixRegs(i.VD, vectorSize);
        var src = readMatrix(i.VS, vectorSize);
        var result = setMatrix(dest, function (column, row, index) { return src[index]; });
        this.eatPrefixes();
        return result;
    };
    InstructionAst.prototype.vmmul = function (i) {
        var VectorSize = i.ONE_TWO;
        var dest = getMatrixRegs(i.VD, VectorSize);
        var src = readMatrix(i.VS, VectorSize);
        var target = readMatrix(i.VT, VectorSize);
        var st = [];
        st.push(setMatrix(dest, function (Column, Row, Index) {
            var sum = imm_f(0);
            for (var n = 0; n < VectorSize; n++) {
                sum = binop(sum, '+', binop(src[Column * VectorSize + n], '*', target[Row * VectorSize + n]));
            }
            return sum;
        }));
        st.push(call_stm('state.eatPrefixes', []));
        this.eatPrefixes();
        return stms(st);
    };
    InstructionAst.prototype['vt4444.q'] = function (i) { return this._vtXXX_q(i, '_vt4444_step'); };
    InstructionAst.prototype['vt5551.q'] = function (i) { return this._vtXXX_q(i, '_vt5551_step'); };
    InstructionAst.prototype['vt5650.q'] = function (i) { return this._vtXXX_q(i, '_vt5650_step'); };
    InstructionAst.prototype._vtXXX_q = function (i, func) {
        var size = i.ONE_TWO;
        if (size != 4)
            throw (new Error("Not implemented _vtXXXX_q for VectorSize=" + size));
        var dest = getVectorRegs(i.VD, 2);
        var src = readVector_i(i.VS, 4);
        var result = setVector_i(dest, function (index) { return ast.call('state.' + func, [src[index * 2 + 0], src[index * 2 + 1]]); });
        this.eatPrefixes();
        return result;
    };
    InstructionAst.prototype.add = function (i) { return this.addu(i); };
    InstructionAst.prototype.addu = function (i) { return assignGpr(i.rd, binop(gpr(i.rs), '+', gpr(i.rt))); };
    InstructionAst.prototype.addi = function (i) { return this.addiu(i); };
    InstructionAst.prototype.addiu = function (i) { return assignGpr(i.rt, binop(gpr(i.rs), '+', imm32(i.imm16))); };
    InstructionAst.prototype.sub = function (i) { return this.subu(i); };
    InstructionAst.prototype.subu = function (i) { return assignGpr(i.rd, binop(gpr(i.rs), '-', gpr(i.rt))); };
    InstructionAst.prototype.sll = function (i) { return assignGpr(i.rd, binop(gpr(i.rt), '<<', imm32(i.pos))); };
    InstructionAst.prototype.sra = function (i) { return assignGpr(i.rd, binop(gpr(i.rt), '>>', imm32(i.pos))); };
    InstructionAst.prototype.srl = function (i) { return assignGpr(i.rd, binop(gpr(i.rt), '>>>', imm32(i.pos))); };
    InstructionAst.prototype.rotr = function (i) { return assignGpr(i.rd, call('BitUtils.rotr', [gpr(i.rt), imm32(i.pos)])); };
    InstructionAst.prototype.sllv = function (i) { return assignGpr(i.rd, binop(gpr(i.rt), '<<', binop(gpr(i.rs), '&', imm32(31)))); };
    InstructionAst.prototype.srav = function (i) { return assignGpr(i.rd, binop(gpr(i.rt), '>>', binop(gpr(i.rs), '&', imm32(31)))); };
    InstructionAst.prototype.srlv = function (i) { return assignGpr(i.rd, binop(gpr(i.rt), '>>>', binop(gpr(i.rs), '&', imm32(31)))); };
    InstructionAst.prototype.rotrv = function (i) { return assignGpr(i.rd, call('BitUtils.rotr', [gpr(i.rt), gpr(i.rs)])); };
    InstructionAst.prototype.bitrev = function (i) { return assignGpr(i.rd, call('BitUtils.bitrev32', [gpr(i.rt)])); };
    InstructionAst.prototype.and = function (i) { return assignGpr(i.rd, binop(gpr(i.rs), '&', gpr(i.rt))); };
    InstructionAst.prototype.or = function (i) { return assignGpr(i.rd, binop(gpr(i.rs), '|', gpr(i.rt))); };
    InstructionAst.prototype.xor = function (i) { return assignGpr(i.rd, binop(gpr(i.rs), '^', gpr(i.rt))); };
    InstructionAst.prototype.nor = function (i) { return assignGpr(i.rd, unop('~', binop(gpr(i.rs), '|', gpr(i.rt)))); };
    InstructionAst.prototype.andi = function (i) { return assignGpr(i.rt, binop(gpr(i.rs), '&', u_imm32(i.u_imm16))); };
    InstructionAst.prototype.ori = function (i) { return assignGpr(i.rt, binop(gpr(i.rs), '|', u_imm32(i.u_imm16))); };
    InstructionAst.prototype.xori = function (i) { return assignGpr(i.rt, binop(gpr(i.rs), '^', u_imm32(i.u_imm16))); };
    InstructionAst.prototype.mflo = function (i) { return assignGpr(i.rd, lo()); };
    InstructionAst.prototype.mfhi = function (i) { return assignGpr(i.rd, hi()); };
    InstructionAst.prototype.mfic = function (i) { return assignGpr(i.rt, ic()); };
    InstructionAst.prototype.mtlo = function (i) { return assign(lo(), gpr(i.rs)); };
    InstructionAst.prototype.mthi = function (i) { return assign(hi(), gpr(i.rs)); };
    InstructionAst.prototype.mtic = function (i) { return assignIC(gpr(i.rt)); };
    InstructionAst.prototype.slt = function (i) { return assignGpr(i.rd, call('state.slt', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.sltu = function (i) { return assignGpr(i.rd, call('state.sltu', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.slti = function (i) { return assignGpr(i.rt, call('state.slt', [gpr(i.rs), imm32(i.imm16)])); };
    InstructionAst.prototype.sltiu = function (i) { return assignGpr(i.rt, call('state.sltu', [gpr(i.rs), u_imm32(i.imm16)])); };
    InstructionAst.prototype.movz = function (i) { return _if(binop(gpr(i.rt), '==', imm32(0)), assignGpr(i.rd, gpr(i.rs))); };
    InstructionAst.prototype.movn = function (i) { return _if(binop(gpr(i.rt), '!=', imm32(0)), assignGpr(i.rd, gpr(i.rs))); };
    InstructionAst.prototype.ext = function (i) { return assignGpr(i.rt, call('BitUtils.extract', [gpr(i.rs), imm32(i.pos), imm32(i.size_e)])); };
    InstructionAst.prototype.ins = function (i) { return assignGpr(i.rt, call('BitUtils.insert', [gpr(i.rt), imm32(i.pos), imm32(i.size_i), gpr(i.rs)])); };
    InstructionAst.prototype.clz = function (i) { return assignGpr(i.rd, call('BitUtils.clz', [gpr(i.rs)])); };
    InstructionAst.prototype.clo = function (i) { return assignGpr(i.rd, call('BitUtils.clo', [gpr(i.rs)])); };
    InstructionAst.prototype.seb = function (i) { return assignGpr(i.rd, call('BitUtils.seb', [gpr(i.rt)])); };
    InstructionAst.prototype.seh = function (i) { return assignGpr(i.rd, call('BitUtils.seh', [gpr(i.rt)])); };
    InstructionAst.prototype.wsbh = function (i) { return assignGpr(i.rd, call('BitUtils.wsbh', [gpr(i.rt)])); };
    InstructionAst.prototype.wsbw = function (i) { return assignGpr(i.rd, call('BitUtils.wsbw', [gpr(i.rt)])); };
    InstructionAst.prototype._trace_state = function () { return stm(ast.call('state._trace_state', [])); };
    InstructionAst.prototype["mov.s"] = function (i) { return assignFpr(i.fd, fpr(i.fs)); };
    InstructionAst.prototype["add.s"] = function (i) { return assignFpr(i.fd, binop(fpr(i.fs), '+', fpr(i.ft))); };
    InstructionAst.prototype["sub.s"] = function (i) { return assignFpr(i.fd, binop(fpr(i.fs), '-', fpr(i.ft))); };
    InstructionAst.prototype["mul.s"] = function (i) { return assignFpr(i.fd, binop(fpr(i.fs), '*', fpr(i.ft))); };
    InstructionAst.prototype["div.s"] = function (i) { return assignFpr(i.fd, binop(fpr(i.fs), '/', fpr(i.ft))); };
    InstructionAst.prototype["abs.s"] = function (i) { return assignFpr(i.fd, call('Math.abs', [fpr(i.fs)])); };
    InstructionAst.prototype["sqrt.s"] = function (i) { return assignFpr(i.fd, call('Math.sqrt', [fpr(i.fs)])); };
    InstructionAst.prototype["neg.s"] = function (i) { return assignFpr(i.fd, unop('-', fpr(i.fs))); };
    InstructionAst.prototype.min = function (i) { return assignGpr(i.rd, call('state.min', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.max = function (i) { return assignGpr(i.rd, call('state.max', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.div = function (i) { return stm(call('state.div', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.divu = function (i) { return stm(call('state.divu', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.mult = function (i) { return stm(call('state.mult', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.multu = function (i) { return stm(call('state.multu', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.madd = function (i) { return stm(call('state.madd', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.maddu = function (i) { return stm(call('state.maddu', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.msub = function (i) { return stm(call('state.msub', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.msubu = function (i) { return stm(call('state.msubu', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.cache = function (i) { return stm(call('state.cache', [gpr(i.rs), imm32(i.rt), imm32(i.imm16)])); };
    InstructionAst.prototype.syscall = function (i) { return stm(call('state.syscall', [imm32(i.syscall)])); };
    InstructionAst.prototype["break"] = function (i) { return stm(call('state.break', [])); };
    InstructionAst.prototype.dbreak = function (i) { return ast.debugger("dbreak"); };
    InstructionAst.prototype._likely = function (isLikely, code) {
        return isLikely ? _if(branchflag(), code) : code;
    };
    InstructionAst.prototype._postBranch = function (nextPc) {
        return _if(branchflag(), stm(assign(pc(), branchpc())), stms([stm(assign(pc(), u_imm32(nextPc)))]));
    };
    InstructionAst.prototype._storePC = function (_pc) {
        return assign(pc(), u_imm32(_pc));
    };
    InstructionAst.prototype._branch = function (i, cond) {
        return stms([
            stm(assign(branchflag(), cond)),
            stm(assign(branchpc(), u_imm32(i.PC + i.imm16 * 4 + 4)))
        ]);
    };
    InstructionAst.prototype.beq = function (i) { return this._branch(i, binop(gpr(i.rs), "==", gpr(i.rt))); };
    InstructionAst.prototype.bne = function (i) { return this._branch(i, binop(gpr(i.rs), "!=", gpr(i.rt))); };
    InstructionAst.prototype.bltz = function (i) { return this._branch(i, binop(gpr(i.rs), "<", imm32(0))); };
    InstructionAst.prototype.blez = function (i) { return this._branch(i, binop(gpr(i.rs), "<=", imm32(0))); };
    InstructionAst.prototype.bgtz = function (i) { return this._branch(i, binop(gpr(i.rs), ">", imm32(0))); };
    InstructionAst.prototype.bgez = function (i) { return this._branch(i, binop(gpr(i.rs), ">=", imm32(0))); };
    InstructionAst.prototype.beql = function (i) { return this.beq(i); };
    InstructionAst.prototype.bnel = function (i) { return this.bne(i); };
    InstructionAst.prototype.bltzl = function (i) { return this.bltz(i); };
    InstructionAst.prototype.blezl = function (i) { return this.blez(i); };
    InstructionAst.prototype.bgtzl = function (i) { return this.bgtz(i); };
    InstructionAst.prototype.bgezl = function (i) { return this.bgez(i); };
    InstructionAst.prototype.bltzal = function (i) { return stms([assignGpr(31, u_imm32(i.PC + 8)), this.bltz(i)]); };
    InstructionAst.prototype.bltzall = function (i) { return stms([assignGpr(31, u_imm32(i.PC + 8)), this.bltzl(i)]); };
    InstructionAst.prototype.bgezal = function (i) { return stms([assignGpr(31, u_imm32(i.PC + 8)), this.bgez(i)]); };
    InstructionAst.prototype.bgezall = function (i) { return stms([assignGpr(31, u_imm32(i.PC + 8)), this.bgezl(i)]); };
    InstructionAst.prototype.bc1t = function (i) { return this._branch(i, fcr31_cc()); };
    InstructionAst.prototype.bc1f = function (i) { return this._branch(i, unop("!", fcr31_cc())); };
    InstructionAst.prototype.bc1tl = function (i) { return this.bc1t(i); };
    InstructionAst.prototype.bc1fl = function (i) { return this.bc1f(i); };
    InstructionAst.prototype.sb = function (i) { return stm(call('state.sb', [gpr(i.rt), rs_imm16(i)])); };
    InstructionAst.prototype.sh = function (i) { return stm(call('state.sh', [gpr(i.rt), rs_imm16(i)])); };
    InstructionAst.prototype.sw = function (i) { return stm(call('state.sw', [gpr(i.rt), rs_imm16(i)])); };
    InstructionAst.prototype.swc1 = function (i) { return stm(call('state.swc1', [fpr(i.ft), rs_imm16(i)])); };
    InstructionAst.prototype.lwc1 = function (i) { return assignFpr_I(i.ft, call('state.lw', [rs_imm16(i)])); };
    InstructionAst.prototype.mfc1 = function (i) { return assignGpr(i.rt, ast.fpr_i(i.fs)); };
    InstructionAst.prototype.mtc1 = function (i) { return assignFpr_I(i.fs, ast.gpr(i.rt)); };
    InstructionAst.prototype.cfc1 = function (i) { return stm(call('state._cfc1_impl', [imm32(i.rd), imm32(i.rt)])); };
    InstructionAst.prototype.ctc1 = function (i) { return stm(call('state._ctc1_impl', [imm32(i.rd), gpr(i.rt)])); };
    InstructionAst.prototype["trunc.w.s"] = function (i) { return assignFpr_I(i.fd, call('MathFloat.trunc', [fpr(i.fs)])); };
    InstructionAst.prototype["round.w.s"] = function (i) { return assignFpr_I(i.fd, call('MathFloat.round', [fpr(i.fs)])); };
    InstructionAst.prototype["ceil.w.s"] = function (i) { return assignFpr_I(i.fd, call('MathFloat.ceil', [fpr(i.fs)])); };
    InstructionAst.prototype["floor.w.s"] = function (i) { return assignFpr_I(i.fd, call('MathFloat.floor', [fpr(i.fs)])); };
    InstructionAst.prototype["cvt.s.w"] = function (i) { return assignFpr(i.fd, fpr_i(i.fs)); };
    InstructionAst.prototype["cvt.w.s"] = function (i) { return assignFpr_I(i.fd, call('state._cvt_w_s_impl', [fpr(i.fs)])); };
    InstructionAst.prototype.lb = function (i) { return assignGpr(i.rt, call('state.lb', [rs_imm16(i)])); };
    InstructionAst.prototype.lbu = function (i) { return assignGpr(i.rt, call('state.lbu', [rs_imm16(i)])); };
    InstructionAst.prototype.lh = function (i) { return assignGpr(i.rt, call('state.lh', [rs_imm16(i)])); };
    InstructionAst.prototype.lhu = function (i) { return assignGpr(i.rt, call('state.lhu', [rs_imm16(i)])); };
    InstructionAst.prototype.lw = function (i) { return assignGpr(i.rt, call('state.lw', [rs_imm16(i)])); };
    InstructionAst.prototype.lwl = function (i) { return assignGpr(i.rt, call('state.lwl', [gpr(i.rs), i_simm16(i), gpr(i.rt)])); };
    InstructionAst.prototype.lwr = function (i) { return assignGpr(i.rt, call('state.lwr', [gpr(i.rs), i_simm16(i), gpr(i.rt)])); };
    InstructionAst.prototype.swl = function (i) { return stm(call('state.swl', [gpr(i.rs), i_simm16(i), gpr(i.rt)])); };
    InstructionAst.prototype.swr = function (i) { return stm(call('state.swr', [gpr(i.rs), i_simm16(i), gpr(i.rt)])); };
    InstructionAst.prototype._callstackPush = function (i) {
        return ast.stm();
    };
    InstructionAst.prototype._callstackPop = function (i) {
        return ast.stm();
    };
    InstructionAst.prototype.j = function (i) { return stms([stm(assign(branchflag(), imm32(1))), stm(assign(branchpc(), u_imm32(i.u_imm26 * 4)))]); };
    InstructionAst.prototype.jr = function (i) {
        var statements = [];
        statements.push(stm(assign(branchflag(), imm32(1))));
        statements.push(stm(assign(branchpc(), gpr(i.rs))));
        if (i.rs == 31) {
            statements.push(this._callstackPop(i));
        }
        return stms(statements);
    };
    InstructionAst.prototype.jal = function (i) { return stms([this.j(i), this._callstackPush(i), assignGpr(31, u_imm32(i.PC + 8))]); };
    InstructionAst.prototype.jalr = function (i) { return stms([this.jr(i), this._callstackPush(i), assignGpr(i.rd, u_imm32(i.PC + 8)),]); };
    InstructionAst.prototype._comp = function (i, fc02, fc3) {
        var fc_unordererd = ((fc02 & 1) != 0);
        var fc_equal = ((fc02 & 2) != 0);
        var fc_less = ((fc02 & 4) != 0);
        var fc_inv_qnan = (fc3 != 0);
        return stm(call('state._comp_impl', [fpr(i.fs), fpr(i.ft), immBool(fc_unordererd), immBool(fc_equal), immBool(fc_less), immBool(fc_inv_qnan)]));
    };
    InstructionAst.prototype["c.f.s"] = function (i) { return this._comp(i, 0, 0); };
    InstructionAst.prototype["c.un.s"] = function (i) { return this._comp(i, 1, 0); };
    InstructionAst.prototype["c.eq.s"] = function (i) { return this._comp(i, 2, 0); };
    InstructionAst.prototype["c.ueq.s"] = function (i) { return this._comp(i, 3, 0); };
    InstructionAst.prototype["c.olt.s"] = function (i) { return this._comp(i, 4, 0); };
    InstructionAst.prototype["c.ult.s"] = function (i) { return this._comp(i, 5, 0); };
    InstructionAst.prototype["c.ole.s"] = function (i) { return this._comp(i, 6, 0); };
    InstructionAst.prototype["c.ule.s"] = function (i) { return this._comp(i, 7, 0); };
    InstructionAst.prototype["c.sf.s"] = function (i) { return this._comp(i, 0, 1); };
    InstructionAst.prototype["c.ngle.s"] = function (i) { return this._comp(i, 1, 1); };
    InstructionAst.prototype["c.seq.s"] = function (i) { return this._comp(i, 2, 1); };
    InstructionAst.prototype["c.ngl.s"] = function (i) { return this._comp(i, 3, 1); };
    InstructionAst.prototype["c.lt.s"] = function (i) { return this._comp(i, 4, 1); };
    InstructionAst.prototype["c.nge.s"] = function (i) { return this._comp(i, 5, 1); };
    InstructionAst.prototype["c.le.s"] = function (i) { return this._comp(i, 6, 1); };
    InstructionAst.prototype["c.ngt.s"] = function (i) { return this._comp(i, 7, 1); };
    return InstructionAst;
})();
exports.InstructionAst = InstructionAst;

},
"src/core/cpu/cpu_assembler": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var instructions = require('./cpu_instructions');
var Instructions = instructions.Instructions;
var Instruction = instructions.Instruction;
var Labels = (function () {
    function Labels() {
        this.labels = {};
    }
    return Labels;
})();
var MipsAssemblerResult = (function () {
    function MipsAssemblerResult(entrypoint) {
        this.entrypoint = entrypoint;
    }
    return MipsAssemblerResult;
})();
exports.MipsAssemblerResult = MipsAssemblerResult;
var MipsAssembler = (function () {
    function MipsAssembler() {
        this.instructions = Instructions.instance;
    }
    MipsAssembler.prototype.assembleToMemory = function (memory, startPC, lines) {
        var labels = new Labels();
        var entryPoint = startPC;
        for (var n = 0; n < 2; n++) {
            var PC = startPC;
            for (var _i = 0; _i < lines.length; _i++) {
                var line = lines[_i];
                switch (line.substr(0, 1)) {
                    case '.':
                        switch (line) {
                            case '.entrypoint':
                                entryPoint = PC;
                                break;
                            default: throw new Error("Invalid " + line);
                        }
                        break;
                    case ':':
                        labels.labels[line.substr(1)] = PC;
                        break;
                    default:
                        var instructions = this.assemble(PC, line, labels);
                        for (var _a = 0; _a < instructions.length; _a++) {
                            var instruction = instructions[_a];
                            memory.writeInt32(PC, instruction.data);
                            PC += 4;
                        }
                        break;
                }
            }
        }
        return new MipsAssemblerResult(entryPoint);
    };
    MipsAssembler.prototype.assemble = function (PC, line, labels) {
        if (labels == null)
            labels = new Labels();
        var matches = line.match(/^\s*(\w+)(.*)$/);
        var instructionName = matches[1];
        var instructionArguments = matches[2].replace(/^\s+/, '').replace(/\s+$/, '');
        switch (instructionName) {
            case 'nop': return this.assemble(PC, 'sll r0, r0, 0');
            case 'li':
                var parts = instructionArguments.split(',');
                return this.assemble(PC, 'addiu ' + parts[0] + ', r0, ' + parts[1]);
        }
        var instructionType = this.instructions.findByName(instructionName);
        var instruction = new Instruction(PC, instructionType.vm.value);
        var types = [];
        var formatPattern = instructionType.format
            .replace('(', '\\(')
            .replace(')', '\\)')
            .replace(/(%\w+)/g, function (type) {
            types.push(type);
            switch (type) {
                case '%J':
                case '%s':
                case '%d':
                case '%t':
                    return '([$r]\\d+)';
                case '%i':
                case '%C':
                case '%c':
                case '%a':
                    return '((?:0b|0x|\\-)?[0-9A-Fa-f_]+)';
                case '%j':
                case '%O':
                    return '(\\w+)';
                default: throw (new Error("MipsAssembler.Transform: Unknown type '" + type + "'"));
            }
        })
            .replace(/\s+/g, '\\s*');
        var regex = new RegExp('^' + formatPattern + '$', '');
        var matches = instructionArguments.match(regex);
        if (matches === null) {
            throw ('Not matching ' + instructionArguments + ' : ' + regex + ' : ' + instructionType.format);
        }
        for (var n = 0; n < types.length; n++) {
            var type = types[n];
            var match = matches[n + 1];
            this.update(instruction, type, match, labels);
        }
        return [instruction];
    };
    MipsAssembler.prototype.decodeRegister = function (name) {
        if (name.charAt(0) == '$')
            return parseInt(name.substr(1));
        if (name.charAt(0) == 'r')
            return parseInt(name.substr(1));
        throw ('Invalid register "' + name + '"');
    };
    MipsAssembler.prototype.decodeInteger = function (str) {
        str = str.replace(/_/g, '');
        if (str.substr(0, 2) == '0b')
            return parseInt(str.substr(2), 2);
        if (str.substr(0, 2) == '0x')
            return parseInt(str.substr(2), 16);
        return parseInt(str, 10);
    };
    MipsAssembler.prototype.update = function (instruction, type, value, labels) {
        switch (type) {
            case '%J':
            case '%s':
                instruction.rs = this.decodeRegister(value);
                break;
            case '%d':
                instruction.rd = this.decodeRegister(value);
                break;
            case '%t':
                instruction.rt = this.decodeRegister(value);
                break;
            case '%a':
            case '%i':
                instruction.imm16 = this.decodeInteger(value);
                break;
            case '%C':
                instruction.syscall = this.decodeInteger(value);
                break;
            case '%c':
                instruction.syscall = this.decodeInteger(value);
                break;
            case '%O':
                instruction.branch_address = labels.labels[value];
                break;
            case '%j':
                instruction.jump_address = labels.labels[value];
                break;
            default: throw ("MipsAssembler.Update: Unknown type '" + type + "' with value '" + value + "'");
        }
    };
    return MipsAssembler;
})();
exports.MipsAssembler = MipsAssembler;
var MipsDisassembler = (function () {
    function MipsDisassembler() {
        this.instructions = Instructions.instance;
    }
    MipsDisassembler.prototype.encodeRegister = function (index) {
        return '$' + index;
    };
    MipsDisassembler.prototype.disassemble = function (instruction) {
        var _this = this;
        var instructionType = this.instructions.findByData(instruction.data);
        var args = instructionType.format.replace(/(\%\w+)/g, function (type) {
            switch (type) {
                case '%s':
                    return _this.encodeRegister(instruction.rs);
                    break;
                case '%d':
                    return _this.encodeRegister(instruction.rd);
                    break;
                case '%t':
                    return _this.encodeRegister(instruction.rt);
                    break;
                default: throw ("MipsDisassembler.Disassemble: Unknown type '" + type + "'");
            }
        });
        return instructionType.name + ' ' + args;
    };
    return MipsDisassembler;
})();
exports.MipsDisassembler = MipsDisassembler;

},
"src/core/cpu/cpu_ast": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var ANode = (function () {
    function ANode() {
    }
    ANode.prototype.toJs = function () { return ''; };
    ANode.prototype.optimize = function () { return this; };
    return ANode;
})();
exports.ANode = ANode;
var ANodeStm = (function (_super) {
    __extends(ANodeStm, _super);
    function ANodeStm() {
        _super.apply(this, arguments);
    }
    return ANodeStm;
})(ANode);
exports.ANodeStm = ANodeStm;
var ANodeStmLabel = (function (_super) {
    __extends(ANodeStmLabel, _super);
    function ANodeStmLabel(address) {
        _super.call(this);
        this.address = 0;
        this.references = [];
        this.type = 'normal';
        this.address = address;
    }
    ANodeStmLabel.prototype.toJs = function () {
        switch (this.type) {
            case 'none': return "";
            case 'normal':
                if (this.references.length == 0)
                    return "";
                return "case " + addressToHex(this.address) + ":";
            case 'while': return "loop_" + addressToHex(this.address) + ": while (true) {";
        }
    };
    return ANodeStmLabel;
})(ANodeStm);
exports.ANodeStmLabel = ANodeStmLabel;
var ANodeStmStaticJump = (function (_super) {
    __extends(ANodeStmStaticJump, _super);
    function ANodeStmStaticJump(cond, address) {
        _super.call(this);
        this.cond = cond;
        this.address = address;
        this.type = 'normal';
    }
    ANodeStmStaticJump.prototype.toJs = function () {
        switch (this.type) {
            case 'normal': return "if (" + this.cond.toJs() + ") { loop_state = " + addressToHex(this.address) + "; continue loop; }";
            case 'while': return "if (" + this.cond.toJs() + ") { continue loop_" + addressToHex(this.address) + "; } else { break loop_" + addressToHex(this.address) + "; } }";
        }
    };
    return ANodeStmStaticJump;
})(ANodeStm);
exports.ANodeStmStaticJump = ANodeStmStaticJump;
var ANodeStmReturn = (function (_super) {
    __extends(ANodeStmReturn, _super);
    function ANodeStmReturn() {
        _super.apply(this, arguments);
    }
    ANodeStmReturn.prototype.toJs = function () { return 'return;'; };
    return ANodeStmReturn;
})(ANodeStm);
exports.ANodeStmReturn = ANodeStmReturn;
var ANodeStmList = (function (_super) {
    __extends(ANodeStmList, _super);
    function ANodeStmList(childs) {
        _super.call(this);
        this.childs = childs;
    }
    ANodeStmList.prototype.add = function (node) {
        this.childs.push(node);
    };
    ANodeStmList.prototype.toJs = function () {
        return this.childs.map(function (c) { return c.toJs(); }).join("\n");
    };
    return ANodeStmList;
})(ANodeStm);
exports.ANodeStmList = ANodeStmList;
var ABlock = (function () {
    function ABlock(index, label, jump) {
        if (label === void 0) { label = null; }
        if (jump === void 0) { jump = null; }
        this.index = index;
        this.label = label;
        this.jump = jump;
        this.code = '';
        this.rblock = null;
    }
    ABlock.prototype.add = function (node) {
        this.code += node.toJs() + '\n';
    };
    return ABlock;
})();
var RelooperBlock = (function () {
    function RelooperBlock(index, code) {
        this.index = index;
        this.code = code;
        this.conditionalBranches = [];
        this.nextBlock = null;
        this.conditionalReferences = [];
    }
    return RelooperBlock;
})();
var RelooperBranch = (function () {
    function RelooperBranch(to, cond) {
        this.to = to;
        this.cond = cond;
    }
    return RelooperBranch;
})();
var IndentWriter = (function () {
    function IndentWriter() {
        this.i = '';
        this.startline = true;
        this.chunks = [];
    }
    IndentWriter.prototype.write = function (chunk) {
        this.chunks.push(chunk);
    };
    IndentWriter.prototype.indent = function () { this.i += '\t'; };
    IndentWriter.prototype.unindent = function () { this.i = this.i.substr(0, -1); };
    Object.defineProperty(IndentWriter.prototype, "output", {
        get: function () { return this.chunks.join(''); },
        enumerable: true,
        configurable: true
    });
    return IndentWriter;
})();
var SimpleRelooper = (function () {
    function SimpleRelooper() {
        this.blocks = [];
        this.lastId = 0;
    }
    SimpleRelooper.prototype.init = function () {
        this.lastId = 0;
    };
    SimpleRelooper.prototype.cleanup = function () {
    };
    SimpleRelooper.prototype.addBlock = function (code) {
        var block = new RelooperBlock(this.lastId++, code);
        this.blocks.push(block);
        return block;
    };
    SimpleRelooper.prototype.addBranch = function (from, to, cond) {
        var branch = new RelooperBranch(to, cond);
        if (cond) {
            from.conditionalBranches.push(branch);
            to.conditionalReferences.push(from);
        }
        else {
            from.nextBlock = to;
        }
    };
    SimpleRelooper.prototype.render = function (first) {
        var writer = new IndentWriter();
        if (this.blocks.length <= 1) {
            if (this.blocks.length == 1)
                writer.write(this.blocks[0].code);
        }
        else {
            writer.write('label = 0; loop_label: while (true) switch (label) { case 0:\n');
            writer.indent();
            for (var _i = 0, _a = this.blocks; _i < _a.length; _i++) {
                var block = _a[_i];
                var nblock = this.blocks[block.index + 1];
                if (block.index != 0) {
                    writer.write('case ' + block.index + ':\n');
                    writer.indent();
                }
                if ((block.conditionalBranches.length == 0) && (block.conditionalReferences.length == 1) && (block.conditionalReferences[0] == nblock)) {
                    var condBranch = nblock.conditionalBranches[0];
                    writer.write("while (true) {\n");
                    writer.indent();
                    writer.write(block.code);
                    writer.write("if (!(" + condBranch.cond + ")) break;\n");
                    writer.unindent();
                    writer.write("}\n");
                    writer.write(nblock.code);
                }
                else {
                    for (var _b = 0, _c = block.conditionalBranches; _b < _c.length; _b++) {
                        var branch = _c[_b];
                        writer.write("if (" + branch.cond + ") { label = " + branch.to.index + "; continue loop_label; }\n");
                    }
                    writer.write(block.code);
                }
                if (block.nextBlock) {
                    if (block.nextBlock != nblock) {
                        writer.write("label = " + block.nextBlock.index + "; continue loop_label;\n");
                    }
                }
                else {
                    writer.write('break loop_label;\n');
                }
                if (block.index != 0)
                    writer.unindent();
            }
            writer.unindent();
            writer.write('}');
        }
        return writer.output;
    };
    return SimpleRelooper;
})();
var ANodeFunction = (function (_super) {
    __extends(ANodeFunction, _super);
    function ANodeFunction(address, prefix, sufix, childs) {
        _super.call(this, childs);
        this.address = address;
        this.prefix = prefix;
        this.sufix = sufix;
    }
    ANodeFunction.prototype.toJs = function () {
        var block = new ABlock(0, null);
        var blocksByLabel = {};
        var blocks = [block];
        for (var _i = 0, _a = this.childs; _i < _a.length; _i++) {
            var child = _a[_i];
            if (child instanceof ANodeStmLabel) {
                blocks.push(block = new ABlock(blocks.length, child, null));
                blocksByLabel[child.address] = block;
            }
            else if (child instanceof ANodeStmStaticJump) {
                blocks.push(block = new ABlock(blocks.length, null, child));
            }
            else {
                block.add(child);
            }
        }
        var text = null;
        if (text === null) {
            var relooper = new SimpleRelooper();
            for (var _b = 0; _b < blocks.length; _b++) {
                var block_1 = blocks[_b];
                block_1.rblock = relooper.addBlock(block_1.code);
            }
            for (var n = 0; n < blocks.length; n++) {
                var block_2 = blocks[n];
                var nblock = (n < blocks.length - 1) ? blocks[n + 1] : null;
                var jblock = block_2.jump ? blocksByLabel[block_2.jump.address] : null;
                if (nblock)
                    relooper.addBranch(block_2.rblock, nblock.rblock);
                if (jblock)
                    relooper.addBranch(block_2.rblock, jblock.rblock, block_2.jump.cond.toJs());
            }
            text = relooper.render(blocks[0].rblock);
            relooper.cleanup();
        }
        return this.prefix.toJs() + '\n' + text + this.sufix.toJs() + '\n';
    };
    return ANodeFunction;
})(ANodeStmList);
exports.ANodeFunction = ANodeFunction;
var ANodeStmRaw = (function (_super) {
    __extends(ANodeStmRaw, _super);
    function ANodeStmRaw(content) {
        _super.call(this);
        this.content = content;
    }
    ANodeStmRaw.prototype.toJs = function () { return this.content; };
    return ANodeStmRaw;
})(ANodeStm);
exports.ANodeStmRaw = ANodeStmRaw;
var ANodeStmExpr = (function (_super) {
    __extends(ANodeStmExpr, _super);
    function ANodeStmExpr(expr) {
        _super.call(this);
        this.expr = expr;
    }
    ANodeStmExpr.prototype.toJs = function () { return this.expr.toJs() + ';'; };
    return ANodeStmExpr;
})(ANodeStm);
exports.ANodeStmExpr = ANodeStmExpr;
var ANodeAllocVarStm = (function (_super) {
    __extends(ANodeAllocVarStm, _super);
    function ANodeAllocVarStm(name, initialValue) {
        _super.call(this);
        this.name = name;
        this.initialValue = initialValue;
    }
    ANodeAllocVarStm.prototype.toJs = function () { return 'var ' + this.name + ' = ' + this.initialValue.toJs() + ';'; };
    return ANodeAllocVarStm;
})(ANodeStm);
exports.ANodeAllocVarStm = ANodeAllocVarStm;
var ANodeExpr = (function (_super) {
    __extends(ANodeExpr, _super);
    function ANodeExpr() {
        _super.apply(this, arguments);
    }
    return ANodeExpr;
})(ANode);
exports.ANodeExpr = ANodeExpr;
var ANodeExprLValue = (function (_super) {
    __extends(ANodeExprLValue, _super);
    function ANodeExprLValue() {
        _super.apply(this, arguments);
    }
    ANodeExprLValue.prototype.toAssignJs = function (right) { return ''; };
    return ANodeExprLValue;
})(ANodeExpr);
exports.ANodeExprLValue = ANodeExprLValue;
var ANodeExprLValueSetGet = (function (_super) {
    __extends(ANodeExprLValueSetGet, _super);
    function ANodeExprLValueSetGet(setTemplate, getTemplate, replacements) {
        _super.call(this);
        this.setTemplate = setTemplate;
        this.getTemplate = getTemplate;
        this.replacements = replacements;
    }
    ANodeExprLValueSetGet.prototype._toJs = function (template, right) {
        var _this = this;
        return template.replace(/(\$\d|#)/g, function (match) {
            if (match == '#') {
                return right.toJs();
            }
            else if (match.startsWith('$')) {
                return _this.replacements[parseInt(match.substr(1))].toJs();
            }
        });
    };
    ANodeExprLValueSetGet.prototype.toAssignJs = function (right) {
        return this._toJs(this.setTemplate, right);
    };
    ANodeExprLValueSetGet.prototype.toJs = function () {
        return this._toJs(this.getTemplate);
    };
    return ANodeExprLValueSetGet;
})(ANodeExpr);
exports.ANodeExprLValueSetGet = ANodeExprLValueSetGet;
var ANodeExprLValueVar = (function (_super) {
    __extends(ANodeExprLValueVar, _super);
    function ANodeExprLValueVar(name) {
        _super.call(this);
        this.name = name;
    }
    ANodeExprLValueVar.prototype.toAssignJs = function (right) { return this.name + ' = ' + right.toJs(); };
    ANodeExprLValueVar.prototype.toJs = function () { return this.name; };
    return ANodeExprLValueVar;
})(ANodeExprLValue);
exports.ANodeExprLValueVar = ANodeExprLValueVar;
var ANodeExprI32 = (function (_super) {
    __extends(ANodeExprI32, _super);
    function ANodeExprI32(value) {
        _super.call(this);
        this.value = value;
    }
    ANodeExprI32.prototype.toJs = function () { return String(this.value); };
    return ANodeExprI32;
})(ANodeExpr);
exports.ANodeExprI32 = ANodeExprI32;
var ANodeExprFloat = (function (_super) {
    __extends(ANodeExprFloat, _super);
    function ANodeExprFloat(value) {
        _super.call(this);
        this.value = value;
    }
    ANodeExprFloat.prototype.toJs = function () {
        var rfloat = MathFloat.reinterpretFloatAsInt(this.value);
        if (rfloat & 0x80000000) {
            return '-' + MathFloat.reinterpretIntAsFloat(rfloat & 0x7FFFFFFF);
        }
        else {
            return String(this.value);
        }
    };
    return ANodeExprFloat;
})(ANodeExpr);
exports.ANodeExprFloat = ANodeExprFloat;
var ANodeExprU32 = (function (_super) {
    __extends(ANodeExprU32, _super);
    function ANodeExprU32(value) {
        _super.call(this);
        this.value = value;
    }
    ANodeExprU32.prototype.toJs = function () {
        return addressToHex(this.value);
    };
    return ANodeExprU32;
})(ANodeExpr);
exports.ANodeExprU32 = ANodeExprU32;
var ANodeExprBinop = (function (_super) {
    __extends(ANodeExprBinop, _super);
    function ANodeExprBinop(left, op, right) {
        _super.call(this);
        this.left = left;
        this.op = op;
        this.right = right;
        if (!this.left || !this.left.toJs)
            debugger;
        if (!this.right || !this.right.toJs)
            debugger;
    }
    ANodeExprBinop.prototype.toJs = function () { return '(' + this.left.toJs() + ' ' + this.op + ' ' + this.right.toJs() + ')'; };
    return ANodeExprBinop;
})(ANodeExpr);
exports.ANodeExprBinop = ANodeExprBinop;
var ANodeExprUnop = (function (_super) {
    __extends(ANodeExprUnop, _super);
    function ANodeExprUnop(op, right) {
        _super.call(this);
        this.op = op;
        this.right = right;
    }
    ANodeExprUnop.prototype.toJs = function () { return '(' + this.op + '(' + this.right.toJs() + '))'; };
    return ANodeExprUnop;
})(ANodeExpr);
exports.ANodeExprUnop = ANodeExprUnop;
var ANodeExprAssign = (function (_super) {
    __extends(ANodeExprAssign, _super);
    function ANodeExprAssign(left, right) {
        _super.call(this);
        this.left = left;
        this.right = right;
        if (!this.left || !this.left.toAssignJs)
            debugger;
        if (!this.right)
            debugger;
    }
    ANodeExprAssign.prototype.toJs = function () { return this.left.toAssignJs(this.right); };
    return ANodeExprAssign;
})(ANodeExpr);
exports.ANodeExprAssign = ANodeExprAssign;
var ANodeExprArray = (function (_super) {
    __extends(ANodeExprArray, _super);
    function ANodeExprArray(_items) {
        _super.call(this);
        this._items = _items;
    }
    ANodeExprArray.prototype.toJs = function () { return '[' + this._items.map(function (item) { return item.toJs(); }).join(', ') + ']'; };
    return ANodeExprArray;
})(ANodeExpr);
exports.ANodeExprArray = ANodeExprArray;
var ANodeExprCall = (function (_super) {
    __extends(ANodeExprCall, _super);
    function ANodeExprCall(name, _arguments) {
        _super.call(this);
        this.name = name;
        this._arguments = _arguments;
        if (!_arguments)
            debugger;
        this._arguments.forEach(function (argument) {
            if (!argument || !(argument instanceof ANodeExpr))
                debugger;
        });
    }
    ANodeExprCall.prototype.toJs = function () { return this.name + '(' + this._arguments.map(function (argument) { return argument.toJs(); }).join(', ') + ')'; };
    return ANodeExprCall;
})(ANodeExpr);
exports.ANodeExprCall = ANodeExprCall;
var ANodeStmIf = (function (_super) {
    __extends(ANodeStmIf, _super);
    function ANodeStmIf(cond, codeTrue, codeFalse) {
        _super.call(this);
        this.cond = cond;
        this.codeTrue = codeTrue;
        this.codeFalse = codeFalse;
    }
    ANodeStmIf.prototype.toJs = function () {
        var result = '';
        result += 'if (' + this.cond.toJs() + ')';
        result += ' { ' + this.codeTrue.toJs() + ' }';
        if (this.codeFalse)
            result += ' else { ' + this.codeFalse.toJs() + ' }';
        return result;
    };
    return ANodeStmIf;
})(ANodeStm);
exports.ANodeStmIf = ANodeStmIf;
var AstBuilder = (function () {
    function AstBuilder() {
    }
    AstBuilder.prototype.assign = function (ref, value) { return new ANodeExprAssign(ref, value); };
    AstBuilder.prototype._if = function (cond, codeTrue, codeFalse) { return new ANodeStmIf(cond, codeTrue, codeFalse); };
    AstBuilder.prototype.binop = function (left, op, right) { return new ANodeExprBinop(left, op, right); };
    AstBuilder.prototype.unop = function (op, right) { return new ANodeExprUnop(op, right); };
    AstBuilder.prototype.binop_i = function (left, op, right) { return this.binop(left, op, this.imm32(right)); };
    AstBuilder.prototype.imm32 = function (value) { return new ANodeExprI32(value); };
    AstBuilder.prototype.imm_f = function (value) { return new ANodeExprFloat(value); };
    AstBuilder.prototype.u_imm32 = function (value) { return new ANodeExprU32(value); };
    AstBuilder.prototype.stm = function (expr) { return expr ? (new ANodeStmExpr(expr)) : new ANodeStm(); };
    AstBuilder.prototype.stms = function (stms) { return new ANodeStmList(stms); };
    AstBuilder.prototype.func = function (address, prefix, sufix, stms) { return new ANodeFunction(address, prefix, sufix, stms); };
    AstBuilder.prototype.array = function (exprList) { return new ANodeExprArray(exprList); };
    AstBuilder.prototype.arrayNumbers = function (values) {
        var _this = this;
        return this.array(values.map(function (value) { return _this.imm_f(value); }));
    };
    AstBuilder.prototype.call = function (name, exprList) { return new ANodeExprCall(name, exprList); };
    AstBuilder.prototype.label = function (address) { return new ANodeStmLabel(address); };
    AstBuilder.prototype.sjump = function (cond, value) { return new ANodeStmStaticJump(cond, value); };
    AstBuilder.prototype._return = function () { return new ANodeStmReturn(); };
    AstBuilder.prototype.raw_stm = function (content) { return new ANodeStmRaw(content); };
    AstBuilder.prototype.raw = function (content) { return new ANodeExprLValueVar(content); };
    AstBuilder.prototype.allocVar = function (name, initialValue) { return new ANodeAllocVarStm(name, initialValue); };
    return AstBuilder;
})();
exports.AstBuilder = AstBuilder;
var MipsAstBuilder = (function (_super) {
    __extends(MipsAstBuilder, _super);
    function MipsAstBuilder() {
        _super.apply(this, arguments);
    }
    MipsAstBuilder.prototype.debugger = function (comment) {
        if (comment === void 0) { comment = '-'; }
        return new ANodeStmRaw("debugger; // " + comment + "\n");
    };
    MipsAstBuilder.prototype.gpr = function (index) {
        if (index === 0)
            return new ANodeExprLValueVar('0');
        return new ANodeExprLValueVar('gpr[' + index + ']');
    };
    MipsAstBuilder.prototype.gpr_f = function (index) {
        if (index === 0)
            return new ANodeExprLValueVar('0');
        return new ANodeExprLValueVar('gpr_f[' + index + ']');
    };
    MipsAstBuilder.prototype.tempr = function (index) { return new ANodeExprLValueVar('state.temp[' + index + ']'); };
    MipsAstBuilder.prototype.vector_vs = function (index) { return new ANodeExprLValueVar('state.vector_vs[' + index + ']'); };
    MipsAstBuilder.prototype.vector_vt = function (index) { return new ANodeExprLValueVar('state.vector_vt[' + index + ']'); };
    MipsAstBuilder.prototype.vfpr = function (index) { return new ANodeExprLValueVar('state.vfpr[' + index + ']'); };
    MipsAstBuilder.prototype.vfprc = function (index) { return new ANodeExprLValueVar('state.vfprc[' + index + ']'); };
    MipsAstBuilder.prototype.vfpr_i = function (index) { return new ANodeExprLValueVar('state.vfpr_i[' + index + ']'); };
    MipsAstBuilder.prototype.fpr = function (index) { return new ANodeExprLValueVar('state.fpr[' + index + ']'); };
    MipsAstBuilder.prototype.fpr_i = function (index) { return new ANodeExprLValueVar('state.fpr_i[' + index + ']'); };
    MipsAstBuilder.prototype.fcr31_cc = function () { return new ANodeExprLValueVar('state.fcr31_cc'); };
    MipsAstBuilder.prototype.lo = function () { return new ANodeExprLValueVar('state.LO'); };
    MipsAstBuilder.prototype.hi = function () { return new ANodeExprLValueVar('state.HI'); };
    MipsAstBuilder.prototype.ic = function () { return new ANodeExprLValueVar('state.IC'); };
    MipsAstBuilder.prototype.pc = function () { return new ANodeExprLValueVar('state.PC'); };
    MipsAstBuilder.prototype.VCC = function (index) {
        return new ANodeExprLValueSetGet('state.setVfrCc($0, #)', 'state.getVfrCc($0)', [this.imm32(index)]);
    };
    MipsAstBuilder.prototype.ra = function () { return new ANodeExprLValueVar('state.gpr[31]'); };
    MipsAstBuilder.prototype.branchflag = function () { return new ANodeExprLValueVar('BRANCHFLAG'); };
    MipsAstBuilder.prototype.branchpc = function () { return new ANodeExprLValueVar('BRANCHPC'); };
    MipsAstBuilder.prototype.assignGpr = function (index, expr) {
        if (index == 0)
            return this.stm();
        return this.stm(this.assign(this.gpr(index), expr));
    };
    MipsAstBuilder.prototype.assignIC = function (expr) { return this.stm(this.assign(this.ic(), expr)); };
    MipsAstBuilder.prototype.assignFpr = function (index, expr) { return this.stm(this.assign(this.fpr(index), expr)); };
    MipsAstBuilder.prototype.assignFpr_I = function (index, expr) { return this.stm(this.assign(this.fpr_i(index), expr)); };
    return MipsAstBuilder;
})(AstBuilder);
exports.MipsAstBuilder = MipsAstBuilder;

},
"src/core/cpu/cpu_codegen": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _ast = require('./cpu_ast');
var ast;
function assignGpr(index, expr) { return ast.assignGpr(index, expr); }
function assignFpr(index, expr) { return ast.assignFpr(index, expr); }
function assignFpr_I(index, expr) { return ast.assignFpr_I(index, expr); }
function assignIC(expr) { return ast.assignIC(expr); }
function fcr31_cc() { return ast.fcr31_cc(); }
function fpr(index) { return ast.fpr(index); }
function fpr_i(index) { return ast.fpr_i(index); }
function gpr(index) { return ast.gpr(index); }
function gpr_f(index) { return ast.gpr_f(index); }
function tempr(index) { return ast.tempr(index); }
function vfpr(reg) { return ast.vfpr(reg); }
function vfprc(reg) { return ast.vfprc(reg); }
function vfpr_i(index) { return ast.vfpr_i(index); }
function immBool(value) { return ast.imm32(value ? 1 : 0); }
function imm32(value) { return ast.imm32(value); }
function imm_f(value) { return ast.imm_f(value); }
function u_imm32(value) { return ast.u_imm32(value); }
function unop(op, right) { return ast.unop(op, right); }
function binop(left, op, right) { return ast.binop(left, op, right); }
function binop_i(left, op, right) { return ast.binop_i(left, op, right); }
function _if(cond, codeTrue, codeFalse) { return ast._if(cond, codeTrue, codeFalse); }
function call(name, exprList) { return ast.call(name, exprList); }
function call_stm(name, exprList) { return stm(ast.call(name, exprList)); }
function stm(expr) { return ast.stm(expr); }
function stms(stms) { return ast.stms(stms); }
function pc() { return ast.pc(); }
function lo() { return ast.lo(); }
function hi() { return ast.hi(); }
function ic() { return ast.ic(); }
function branchflag() { return ast.branchflag(); }
function branchpc() { return ast.branchpc(); }
function assign(ref, value) { return ast.assign(ref, value); }
function assign_stm(ref, value) { return stm(ast.assign(ref, value)); }
function i_simm16(i) { return imm32(i.imm16); }
function i_uimm16(i) { return u_imm32(i.u_imm16); }
function rs_imm16(i) { return binop(binop(gpr(i.rs), '+', imm32(i.imm16)), '|', imm32(0)); }
function cast_uint(expr) { return binop(expr, '>>>', ast.imm32(0)); }
var VMatRegClass = (function () {
    function VMatRegClass(reg) {
        this.reg = reg;
    }
    VMatRegClass.prototype._setMatrix = function (generator) {
        var array = [];
        for (var column = 0; column < 4; column++) {
            for (var row = 0; row < 4; row++) {
                array.push(generator(column, row));
            }
        }
        return stm(ast.call('state.vfpuSetMatrix', [imm32(this.reg), ast.array(array)]));
    };
    VMatRegClass.prototype.setMatrix = function (generator) {
        return stms([
            this._setMatrix(generator),
            stm(ast.debugger('wip vfpu'))
        ]);
    };
    VMatRegClass.prototype.setMatrixDebug = function (generator) {
        return stms([
            this._setMatrix(generator),
            stm(ast.debugger('wip vfpu'))
        ]);
    };
    return VMatRegClass;
})();
var VVecRegClass = (function () {
    function VVecRegClass(reg, size) {
        this.reg = reg;
    }
    VVecRegClass.prototype._setVector = function (generator) {
        var array = [];
        var statements = [];
        var regs = getVectorRegs(this.reg, VectorSize.Quad);
        statements.push(stm(ast.call('state.vfpuStore', [
            ast.array(regs.map(function (item) { return imm32(item); })),
            ast.array([0, 1, 2, 3].map(function (index) { return generator(index); }))
        ])));
        return stms(statements);
    };
    VVecRegClass.prototype.setVector = function (generator) {
        return stms([
            this._setVector(generator),
            stm(ast.debugger('wip vfpu'))
        ]);
    };
    return VVecRegClass;
})();
function VMatReg(index) {
    return new VMatRegClass(index);
}
function VVecReg(index, size) {
    return new VVecRegClass(index, size);
}
(function (VectorSize) {
    VectorSize[VectorSize["Single"] = 1] = "Single";
    VectorSize[VectorSize["Pair"] = 2] = "Pair";
    VectorSize[VectorSize["Triple"] = 3] = "Triple";
    VectorSize[VectorSize["Quad"] = 4] = "Quad";
})(exports.VectorSize || (exports.VectorSize = {}));
var VectorSize = exports.VectorSize;
(function (MatrixSize) {
    MatrixSize[MatrixSize["M_2x2"] = 2] = "M_2x2";
    MatrixSize[MatrixSize["M_3x3"] = 3] = "M_3x3";
    MatrixSize[MatrixSize["M_4x4"] = 4] = "M_4x4";
})(exports.MatrixSize || (exports.MatrixSize = {}));
var MatrixSize = exports.MatrixSize;
;
function getVectorRegs(vectorReg, N) {
    var mtx = (vectorReg >>> 2) & 7;
    var col = vectorReg & 3;
    var row = 0;
    var length = 0;
    var transpose = (vectorReg >>> 5) & 1;
    switch (N) {
        case VectorSize.Single:
            transpose = 0;
            row = (vectorReg >>> 5) & 3;
            length = 1;
            break;
        case VectorSize.Pair:
            row = (vectorReg >>> 5) & 2;
            length = 2;
            break;
        case VectorSize.Triple:
            row = (vectorReg >>> 6) & 1;
            length = 3;
            break;
        case VectorSize.Quad:
            row = (vectorReg >>> 5) & 2;
            length = 4;
            break;
        default: debugger;
    }
    var regs = new Array(length);
    for (var i = 0; i < length; i++) {
        var index = mtx * 4;
        if (transpose) {
            index += ((row + i) & 3) + col * 32;
        }
        else {
            index += col + ((row + i) & 3) * 32;
        }
        regs[i] = index;
    }
    return regs;
}
function getMatrixRegs(matrixReg, N) {
    var mtx = (matrixReg >> 2) & 7;
    var col = matrixReg & 3;
    var row = 0;
    var side = 0;
    switch (N) {
        case MatrixSize.M_2x2:
            row = (matrixReg >> 5) & 2;
            side = 2;
            break;
        case MatrixSize.M_3x3:
            row = (matrixReg >> 6) & 1;
            side = 3;
            break;
        case MatrixSize.M_4x4:
            row = (matrixReg >> 5) & 2;
            side = 4;
            break;
        default: debugger;
    }
    var transpose = (matrixReg >> 5) & 1;
    var regs = new Array(side * side);
    for (var i = 0; i < side; i++) {
        for (var j = 0; j < side; j++) {
            var index = mtx * 4;
            if (transpose) {
                index += ((row + i) & 3) + ((col + j) & 3) * 32;
            }
            else {
                index += ((col + j) & 3) + ((row + i) & 3) * 32;
            }
            regs[j * side + i] = index;
        }
    }
    return regs;
}
function readVector_f(vectorReg, N) {
    return getVectorRegs(vectorReg, N).map(function (index) { return vfpr(index); });
}
function readVector_i(vectorReg, N) {
    return getVectorRegs(vectorReg, N).map(function (index) { return vfpr_i(index); });
}
function readVector_type(vectorReg, N, type) {
    return (type == 'float') ? readVector_f(vectorReg, N) : readVector_i(vectorReg, N);
}
function readMatrix(vectorReg, N) {
    return getMatrixRegs(vectorReg, N).map(function (index) { return vfpr(index); });
}
function setMemoryVector(offset, items) {
    return call_stm('state.storeFloats', [offset, ast.array(items)]);
}
function memoryRef(type, address) {
    switch (type) {
        case 'float': return new _ast.ANodeExprLValueSetGet('memory.swc1($0, #)', 'memory.lwc1($0)', [address]);
        default: throw (new Error("Not implemented memoryRef type '" + type + "'"));
    }
}
function getMemoryVector(offset, count) {
    return ArrayUtils.range(0, count).map(function (item) { return memoryRef('float', binop(offset, '+', imm32(item * 4))); });
}
function setItems(leftList, values) {
    return stms(leftList.map(function (left, index) { return ast.assign(left, values[index]); }));
}
function address_RS_IMM14(i, offset) {
    if (offset === void 0) { offset = 0; }
    return binop(gpr(i.rs), '+', imm32(i.IMM14 * 4 + offset));
}
function setMatrix(leftList, generator) {
    var side = Math.sqrt(leftList.length);
    return call_stm('state.vfpuStore', [
        ast.array(leftList.map(function (item) { return imm32(item); })),
        ast.array(ArrayUtils.range(0, leftList.length).map(function (index) { return generator(Math.floor(index % side), Math.floor(index / side), index); }))
    ]);
}
function setVector(leftList, generator) {
    return call_stm('state.vfpuStore', [
        ast.array(leftList.map(function (item) { return imm32(item); })),
        ast.array(ArrayUtils.range(0, leftList.length).map(function (index) { return generator(index); }))
    ]);
}
function setVector_i(leftList, generator) {
    return call_stm('state.vfpuStore_i', [
        ast.array(leftList.map(function (item) { return imm32(item); })),
        ast.array(ArrayUtils.range(0, leftList.length).map(function (index) { return generator(index); }))
    ]);
}
var VfpuConstants = [
    { name: "VFPU_ZERO", value: 0.0 },
    { name: "VFPU_HUGE", value: 340282346638528859811704183484516925440 },
    { name: "VFPU_SQRT2", value: Math.sqrt(2.0) },
    { name: "VFPU_SQRT1_2", value: Math.sqrt(1.0 / 2.0) },
    { name: "VFPU_2_SQRTPI", value: 2.0 / Math.sqrt(Math.PI) },
    { name: "VFPU_2_PI", value: 2.0 / Math.PI },
    { name: "VFPU_1_PI", value: 1.0 / Math.PI },
    { name: "VFPU_PI_4", value: Math.PI / 4.0 },
    { name: "VFPU_PI_2", value: Math.PI / 2.0 },
    { name: "VFPU_PI", value: Math.PI },
    { name: "VFPU_E", value: Math.E },
    { name: "VFPU_LOG2E", value: Math.log2(Math.E) },
    { name: "VFPU_LOG10E", value: Math.log10(Math.E) },
    { name: "VFPU_LN2", value: Math.log(2) },
    { name: "VFPU_LN10", value: Math.log(10) },
    { name: "VFPU_2PI", value: 2.0 * Math.PI },
    { name: "VFPU_PI_6", value: Math.PI / 6.0 },
    { name: "VFPU_LOG10TWO", value: Math.log10(2.0) },
    { name: "VFPU_LOG2TEN", value: Math.log2(10.0) },
    { name: "VFPU_SQRT3_2", value: Math.sqrt(3.0) / 2.0 },
];
function getMatrixRegsVD(i) {
    return getMatrixRegs(i.VD, i.ONE_TWO);
}
var VfpuPrefixes = (function () {
    function VfpuPrefixes() {
    }
    VfpuPrefixes.transformRead = function (n, info, values) {
        var sourceIndex = (info >> (0 + n * 2)) & 3;
        var sourceAbsolute = (info >> (8 + n * 1)) & 1;
        var sourceConstant = (info >> (12 + n * 1)) & 1;
        var sourceNegate = (info >> (16 + n * 1)) & 1;
        var value;
        if (sourceConstant) {
            switch (sourceIndex) {
                case 0:
                    value = imm_f(sourceAbsolute ? (3) : (0));
                    break;
                case 1:
                    value = imm_f(sourceAbsolute ? (1 / 3) : (1));
                    break;
                case 2:
                    value = imm_f(sourceAbsolute ? (1 / 4) : (2));
                    break;
                case 3:
                    value = imm_f(sourceAbsolute ? (1 / 6) : (1 / 2));
                    break;
                default:
                    throw (new Error("Invalid operation"));
                    break;
            }
        }
        else {
            value = values[sourceIndex];
            if (sourceAbsolute)
                value = call('Math.abs', [value]);
        }
        if (sourceNegate)
            value = call('MathFloat.neg', [value]);
        return value;
    };
    VfpuPrefixes.transformStore = function (n, info, left, value) {
        var destinationSaturation = (info >> (0 + n * 2)) & 3;
        var destinationMask = (info >> (8 + n * 1)) & 1;
        if (destinationMask) {
            return ast.stm();
        }
        else {
            var value = value;
            switch (destinationSaturation) {
                case 1:
                    value = call('MathFloat.sat0', [value]);
                    break;
                case 3:
                    value = call('MathFloat.sat1', [value]);
                    break;
                default: break;
            }
            return assign_stm(left, value);
        }
    };
    return VfpuPrefixes;
})();
var PrefixPrediction = (function () {
    function PrefixPrediction(default_value) {
        this.default_value = default_value;
        this.known = true;
        this.value = this.default_value;
    }
    PrefixPrediction.prototype.reset = function () {
        this.set(this.default_value);
    };
    PrefixPrediction.prototype.eat = function () {
        this.set(this.default_value);
    };
    PrefixPrediction.prototype.set = function (value) {
        this.known = true;
        this.value = value;
    };
    PrefixPrediction.prototype.setUnknown = function () {
        this.known = false;
        this.value = this.default_value;
    };
    PrefixPrediction.DEFAULT_LOAD_VALUE = 0xDC0000E4;
    PrefixPrediction.DEFAULT_STORE_VALUE = 0x00000000;
    return PrefixPrediction;
})();
var InstructionAst = (function () {
    function InstructionAst() {
        this._vpfxs = new PrefixPrediction(PrefixPrediction.DEFAULT_LOAD_VALUE);
        this._vpfxt = new PrefixPrediction(PrefixPrediction.DEFAULT_LOAD_VALUE);
        this._vpfxd = new PrefixPrediction(PrefixPrediction.DEFAULT_STORE_VALUE);
        this.enableStaticPrefixVfpuOptimization = true;
        ast = new _ast.MipsAstBuilder();
    }
    InstructionAst.prototype.reset = function () {
        this._vpfxs.reset();
        this._vpfxt.reset();
        this._vpfxd.reset();
    };
    InstructionAst.prototype.eatPrefixes = function () {
        this._vpfxs.eat();
        this._vpfxt.eat();
        this._vpfxd.eat();
    };
    InstructionAst.prototype.lui = function (i) { return assignGpr(i.rt, u_imm32(i.imm16 << 16)); };
    InstructionAst.prototype._vset1 = function (i, generate, destSize, destType) {
        if (destSize === void 0) { destSize = 0; }
        if (destType === void 0) { destType = 'float'; }
        var st = [];
        this._vset_storeVD(st, i, destType, destSize, function (index) { return generate(index); });
        return stms(st);
    };
    InstructionAst.prototype._vset2 = function (i, generate, destSize, srcSize, destType, srcType) {
        if (destSize === void 0) { destSize = 0; }
        if (srcSize === void 0) { srcSize = 0; }
        if (destType === void 0) { destType = 'float'; }
        if (srcType === void 0) { srcType = 'float'; }
        var st = [];
        var src = this._vset_readVS(st, i, srcType, srcSize);
        this._vset_storeVD(st, i, destType, destSize, function (index) { return generate(index, src); });
        return stms(st);
    };
    InstructionAst.prototype._vset3 = function (i, generate, destSize, srcSize, targetSize, destType, srcType, targetType) {
        if (destSize === void 0) { destSize = 0; }
        if (srcSize === void 0) { srcSize = 0; }
        if (targetSize === void 0) { targetSize = 0; }
        if (destType === void 0) { destType = 'float'; }
        if (srcType === void 0) { srcType = 'float'; }
        if (targetType === void 0) { targetType = 'float'; }
        var st = [];
        var src = this._vset_readVS(st, i, srcType, srcSize);
        var target = this._vset_readVT(st, i, targetType, targetSize);
        this._vset_storeVD(st, i, destType, destSize, function (index) { return generate(index, src, target); });
        return stms(st);
    };
    InstructionAst.prototype._vset_readVS = function (st, i, type, size) {
        return this._vset_readVSVT(st, i, type, size, 'vs');
    };
    InstructionAst.prototype._vset_readVT = function (st, i, type, size) {
        return this._vset_readVSVT(st, i, type, size, 'vt');
    };
    InstructionAst.prototype._vset_readVSVT = function (st, i, type, size, name) {
        if (size <= 0)
            size = i.ONE_TWO;
        var regs = readVector_type((name == 'vs') ? i.VS : i.VT, size, type);
        var prefix = (name == 'vs') ? this._vpfxs : this._vpfxt;
        if (this.enableStaticPrefixVfpuOptimization && prefix.known) {
            var out = [];
            for (var n = 0; n < size; n++) {
                var vname = ((name == 'vs') ? 's' : 't') + n;
                out.push(ast.raw(vname));
                st.push(ast.allocVar(vname, VfpuPrefixes.transformRead(n, prefix.value, regs)));
            }
            return out;
        }
        else {
            st.push(call_stm(((name == 'vs') ? 'state.loadVs_prefixed' : 'state.loadVt_prefixed'), [ast.array(regs)]));
        }
        return xrange(0, size).map(function (index) { return (name == 'vs') ? ast.vector_vs(index) : ast.vector_vt(index); });
    };
    InstructionAst.prototype._vset_storeVD = function (st, i, type, size, generate) {
        if (size <= 0)
            size = i.ONE_TWO;
        var dest_regs = getVectorRegs(i.VD, size);
        if (this.enableStaticPrefixVfpuOptimization && this._vpfxd.known) {
            for (var n = 0; n < size; n++) {
                var dest_reg = dest_regs[n];
                st.push(VfpuPrefixes.transformStore(n, this._vpfxd.value, (type == 'float') ? vfpr(dest_reg) : vfpr_i(dest_reg), generate(n)));
            }
        }
        else {
            st.push(call_stm((type == 'float') ? 'state.storeVd_prefixed' : 'state.storeVd_prefixed_i', [
                ast.arrayNumbers(dest_regs),
                ast.array(xrange(0, size).map(function (n) { return generate(n); })),
            ]));
        }
        st.push(call_stm('state.eatPrefixes', []));
        this.eatPrefixes();
    };
    InstructionAst.prototype.vpfxs = function (i) {
        this._vpfxs.set(i.data);
        return stms([
            call_stm('state.setVpfxs', [imm32(i.data)]),
        ]);
    };
    InstructionAst.prototype.vpfxt = function (i) {
        this._vpfxt.set(i.data);
        return stms([
            call_stm('state.setVpfxt', [imm32(i.data)]),
        ]);
    };
    InstructionAst.prototype.vpfxd = function (i) {
        this._vpfxd.set(i.data);
        return stms([
            call_stm('state.setVpfxd', [imm32(i.data)]),
        ]);
    };
    InstructionAst.prototype["lv.s"] = function (i) { return assign_stm(vfpr(i.VT5_2), call('memory.lwc1', [address_RS_IMM14(i, 0)])); };
    InstructionAst.prototype["sv.s"] = function (i) { return call_stm('memory.swc1', [address_RS_IMM14(i, 0), vfpr(i.VT5_2)]); };
    InstructionAst.prototype["lv.q"] = function (i) { return setItems(readVector_f(i.VT5_1, VectorSize.Quad), getMemoryVector(address_RS_IMM14(i), 4)); };
    InstructionAst.prototype["lvl.q"] = function (i) { return call_stm('state.lvl_q', [address_RS_IMM14(i, 0), ast.array(getVectorRegs(i.VT5_1, VectorSize.Quad).map(function (item) { return imm32(item); }))]); };
    InstructionAst.prototype["lvr.q"] = function (i) { return call_stm('state.lvr_q', [address_RS_IMM14(i, 0), ast.array(getVectorRegs(i.VT5_1, VectorSize.Quad).map(function (item) { return imm32(item); }))]); };
    InstructionAst.prototype["sv.q"] = function (i) { return setMemoryVector(address_RS_IMM14(i), readVector_f(i.VT5_1, VectorSize.Quad)); };
    InstructionAst.prototype["svl.q"] = function (i) { return call_stm('state.svl_q', [address_RS_IMM14(i, 0), ast.array(getVectorRegs(i.VT5_1, VectorSize.Quad).map(function (item) { return imm32(item); }))]); };
    InstructionAst.prototype["svr.q"] = function (i) { return call_stm('state.svr_q', [address_RS_IMM14(i, 0), ast.array(getVectorRegs(i.VT5_1, VectorSize.Quad).map(function (item) { return imm32(item); }))]); };
    InstructionAst.prototype.viim = function (i) { return assign_stm(vfpr(i.VT), imm32(i.imm16)); };
    InstructionAst.prototype.vfim = function (i) { return assign_stm(vfpr(i.VT), imm_f(i.IMM_HF)); };
    InstructionAst.prototype.vcst = function (i) { return assign_stm(vfpr(i.VD), imm_f(VfpuConstants[i.IMM5].value)); };
    InstructionAst.prototype.vhdp = function (i) {
        var _this = this;
        var vectorSize = i.ONE_TWO;
        return this._vset3(i, function (_, src, target) {
            return _this._aggregateV(imm_f(0), vectorSize, function (aggregate, index) {
                return binop(aggregate, '+', binop(target[index], '*', (index == (vectorSize - 1)) ? imm_f(1.0) : src[index]));
            });
        }, 1, vectorSize, vectorSize);
    };
    InstructionAst.prototype.vmidt = function (i) { return setMatrix(getMatrixRegsVD(i), function (c, r) { return imm32((c == r) ? 1 : 0); }); };
    InstructionAst.prototype.vmzero = function (i) { return setMatrix(getMatrixRegsVD(i), function (c, r) { return imm32(0); }); };
    InstructionAst.prototype.vmone = function (i) { return setMatrix(getMatrixRegsVD(i), function (c, r) { return imm32(1); }); };
    InstructionAst.prototype._vtfm_x = function (i, vectorSize) {
        var _this = this;
        var srcMat = readMatrix(i.VS, vectorSize);
        var st = [];
        st.push(call_stm('state.loadVt_prefixed', [ast.array(readVector_f(i.VT, vectorSize))]));
        st.push(call_stm('state.storeVd_prefixed', [
            ast.arrayNumbers(getVectorRegs(i.VD, vectorSize)),
            ast.array(xrange(0, vectorSize).map(function (n) {
                return _this._aggregateV(imm_f(0), vectorSize, function (aggregated, m) { return binop(aggregated, '+', binop(srcMat[n * vectorSize + m], '*', ast.vector_vt(m))); });
            })),
        ]));
        this.eatPrefixes();
        return stms(st);
    };
    InstructionAst.prototype._vhtfm_x = function (i, vectorSize) {
        var _this = this;
        var srcMat = readMatrix(i.VS, vectorSize);
        var st = [];
        st.push(call_stm('state.loadVt_prefixed', [ast.array(readVector_f(i.VT, vectorSize))]));
        st.push(call_stm('state.storeVd_prefixed', [
            ast.arrayNumbers(getVectorRegs(i.VD, vectorSize)),
            ast.array(xrange(0, vectorSize).map(function (n) {
                return _this._aggregateV(imm_f(0), vectorSize, function (aggregated, m) { return binop(aggregated, '+', binop(srcMat[n * vectorSize + m], '*', ((m == vectorSize - 1) ? imm_f(1) : ast.vector_vt(m)))); });
            })),
        ]));
        this.eatPrefixes();
        return stms(st);
    };
    InstructionAst.prototype.vtfm2 = function (i) { return this._vtfm_x(i, 2); };
    InstructionAst.prototype.vtfm3 = function (i) { return this._vtfm_x(i, 3); };
    InstructionAst.prototype.vtfm4 = function (i) { return this._vtfm_x(i, 4); };
    InstructionAst.prototype.vhtfm2 = function (i) { return this._vhtfm_x(i, 2); };
    InstructionAst.prototype.vhtfm3 = function (i) { return this._vhtfm_x(i, 3); };
    InstructionAst.prototype.vhtfm4 = function (i) { return this._vhtfm_x(i, 4); };
    InstructionAst.prototype.vmscl = function (i) {
        var vectorSize = i.ONE_TWO;
        var src = readMatrix(i.VS, vectorSize);
        return setMatrix(getMatrixRegsVD(i), function (c, r, index) { return binop(src[index], '*', vfpr(i.VT)); });
    };
    InstructionAst.prototype.vzero = function (i) { return this._vset1(i, function (i) { return imm_f(0); }); };
    InstructionAst.prototype.vone = function (i) { return this._vset1(i, function (i) { return imm_f(1); }); };
    InstructionAst.prototype.vmov = function (i) { return this._vset3(i, function (i, s, t) { return s[i]; }); };
    InstructionAst.prototype.vrcp = function (i) { return this._vset2(i, function (i, s) { return binop(imm_f(1.0), '/', s[i]); }); };
    InstructionAst.prototype.vmul = function (i) { return this._vset3(i, function (i, s, t) { return binop(s[i], '*', t[i]); }); };
    InstructionAst.prototype.vbfy1 = function (i) {
        return this._vset2(i, function (i, src) {
            switch (i) {
                case 0: return binop(src[0], '+', src[1]);
                case 1: return binop(src[0], '-', src[1]);
                case 2: return binop(src[2], '+', src[3]);
                case 3: return binop(src[2], '-', src[3]);
                default: throw (new Error("vbfy1: Invalid operation"));
            }
        });
    };
    InstructionAst.prototype.vbfy2 = function (i) {
        return this._vset2(i, function (i, src) {
            switch (i) {
                case 0: return binop(src[0], '+', src[2]);
                case 1: return binop(src[1], '+', src[3]);
                case 2: return binop(src[0], '-', src[2]);
                case 3: return binop(src[1], '-', src[3]);
                default: throw (new Error("vbfy1: Invalid operation"));
            }
        });
    };
    InstructionAst.prototype.vsocp = function (i) {
        var vectorSize = i.ONE_TWO;
        return this._vset2(i, function (index, src) {
            switch (index) {
                case 0: return ast.call('MathFloat.sat0', [binop(imm_f(1), '-', src[0])]);
                case 1: return ast.call('MathFloat.sat0', [src[0]]);
                case 2: return ast.call('MathFloat.sat0', [binop(imm_f(1), '-', src[1])]);
                case 3: return ast.call('MathFloat.sat0', [src[1]]);
                default: throw (new Error("vsocp: " + index));
            }
        }, vectorSize * 2, vectorSize);
    };
    InstructionAst.prototype.vsrt1 = function (i) {
        return this._vset2(i, function (i, src) {
            switch (i) {
                case 0: return call('MathFloat.min', [src[0], src[1]]);
                case 1: return call('MathFloat.max', [src[0], src[1]]);
                case 2: return call('MathFloat.min', [src[2], src[3]]);
                case 3: return call('MathFloat.max', [src[2], src[3]]);
                default: throw (new Error("vsrt1: Invalid operation"));
            }
        }, i.ONE_TWO, 4);
    };
    InstructionAst.prototype.vsrt2 = function (i) {
        return this._vset2(i, function (i, src) {
            switch (i) {
                case 0: return call('MathFloat.min', [src[0], src[3]]);
                case 1: return call('MathFloat.min', [src[1], src[2]]);
                case 2: return call('MathFloat.max', [src[1], src[2]]);
                case 3: return call('MathFloat.max', [src[0], src[3]]);
                default: throw (new Error("vsrt2: Invalid operation"));
            }
        }, i.ONE_TWO, 4);
    };
    InstructionAst.prototype.vsrt3 = function (i) {
        return this._vset2(i, function (i, src) {
            switch (i) {
                case 0: return call('MathFloat.max', [src[0], src[1]]);
                case 1: return call('MathFloat.min', [src[0], src[1]]);
                case 2: return call('MathFloat.max', [src[2], src[3]]);
                case 3: return call('MathFloat.min', [src[2], src[3]]);
                default: throw (new Error("vsrt3: Invalid operation"));
            }
        }, i.ONE_TWO, 4);
    };
    InstructionAst.prototype.vsrt4 = function (i) {
        return this._vset2(i, function (i, src) {
            switch (i) {
                case 0: return call('MathFloat.max', [src[0], src[3]]);
                case 1: return call('MathFloat.max', [src[1], src[2]]);
                case 2: return call('MathFloat.min', [src[1], src[2]]);
                case 3: return call('MathFloat.min', [src[0], src[3]]);
                default: throw (new Error("vsrt4: Invalid operation"));
            }
        }, i.ONE_TWO, 4);
    };
    InstructionAst.prototype.vrnds = function (i) { return call_stm('state.vrnds', []); };
    InstructionAst.prototype.vrndi = function (i) { return this._vset1(i, function (i) { return call('state.vrndi', []); }, undefined, 'int'); };
    InstructionAst.prototype.vrndf1 = function (i) { return this._vset1(i, function (i) { return call('state.vrndf1', []); }); };
    InstructionAst.prototype.vrndf2 = function (i) { return this._vset1(i, function (i) { return call('state.vrndf2', []); }); };
    InstructionAst.prototype._aggregateV = function (val, size, generator) {
        for (var n = 0; n < size; n++)
            val = generator(val, n);
        return val;
    };
    InstructionAst.prototype.vnop = function (i) { return ast.stm(); };
    InstructionAst.prototype.vsync = function (i) { return ast.stm(); };
    InstructionAst.prototype.vflush = function (i) { return ast.stm(); };
    InstructionAst.prototype.vfad = function (i) {
        var _this = this;
        var vectorSize = i.ONE_TWO;
        return this._vset2(i, function (i, src) {
            return _this._aggregateV(imm_f(0), vectorSize, function (value, index) { return binop(value, '+', src[index]); });
        }, 1, vectorSize);
    };
    InstructionAst.prototype.vavg = function (i) {
        var _this = this;
        var vectorSize = i.ONE_TWO;
        return this._vset2(i, function (i, src) {
            return binop(_this._aggregateV(imm_f(0), vectorSize, function (value, index) { return binop(value, '+', src[index]); }), '/', imm_f(vectorSize));
        }, 1, vectorSize);
    };
    InstructionAst.prototype.vidt = function (i) {
        return this._vset1(i, function (index) { return imm_f((index == (i.IMM7 % i.ONE_TWO)) ? 1 : 0); });
    };
    InstructionAst.prototype["vcrs.t"] = function (i) {
        return this._vset3(i, function (index, src, target) {
            switch (index) {
                case 0: return binop(src[1], '*', target[2]);
                case 1: return binop(src[2], '*', target[0]);
                case 2: return binop(src[0], '*', target[1]);
                default: throw (new Error("vcrs_t not implemented"));
            }
        }, 3, 3, 3);
    };
    InstructionAst.prototype["vcrsp.t"] = function (i) {
        return this._vset3(i, function (index, src, target) {
            switch (index) {
                case 0: return binop(binop(src[1], '*', target[2]), '-', binop(src[2], '*', target[1]));
                case 1: return binop(binop(src[2], '*', target[0]), '-', binop(src[0], '*', target[2]));
                case 2: return binop(binop(src[0], '*', target[1]), '-', binop(src[1], '*', target[0]));
                default: throw (new Error("vcrs_t assert"));
            }
        }, 3, 3, 3);
    };
    InstructionAst.prototype.vc2i = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vc2i', [imm32(index), src[0]]); }, 0, 1, 'int', 'int'); };
    InstructionAst.prototype.vuc2i = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vuc2i', [imm32(index), src[0]]); }, 0, 1, 'int', 'int'); };
    InstructionAst.prototype.vs2i = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vs2i', [imm32(index), src[Math.floor(index / 2)]]); }, i.ONE_TWO * 2, i.ONE_TWO, 'int', 'int'); };
    InstructionAst.prototype.vi2f = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vi2f', [src[index], imm32(-i.IMM5)]); }, 0, 0, 'float', 'int'); };
    InstructionAst.prototype.vi2uc = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vi2uc', [src[0], src[1], src[2], src[3]]); }, 1, 4, 'int', 'int'); };
    InstructionAst.prototype.vf2id = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vf2id', [src[index], imm32(i.IMM5)]); }, 0, 0, 'int', 'float'); };
    InstructionAst.prototype.vf2in = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vf2in', [src[index], imm32(i.IMM5)]); }, 0, 0, 'int', 'float'); };
    InstructionAst.prototype.vf2iu = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vf2iu', [src[index], imm32(i.IMM5)]); }, 0, 0, 'int', 'float'); };
    InstructionAst.prototype.vf2iz = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vf2iz', [src[index], imm32(i.IMM5)]); }, 0, 0, 'int', 'float'); };
    InstructionAst.prototype.vf2h = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vf2h', [imm32(index), src[index]]); }, 0, 0, 'float', 'float'); };
    InstructionAst.prototype.vh2f = function (i) { return this._vset2(i, function (index, src) { return call('MathVfpu.vh2f', [imm32(index), src[index]]); }, 0, 0, 'float', 'float'); };
    InstructionAst.prototype.vdet = function (i) {
        return this._vset3(i, function (i, s, t) {
            return binop(binop(s[0], '*', t[1]), '-', binop(s[1], '*', t[0]));
        }, 1, 2, 2);
    };
    InstructionAst.prototype.vqmul = function (i) {
        return this._vset3(i, function (i, s, t) {
            switch (i) {
                case 0: return call('MathVfpu.vqmul0', [s[0], s[1], s[2], s[3], t[0], t[1], t[2], t[3]]);
                case 1: return call('MathVfpu.vqmul1', [s[0], s[1], s[2], s[3], t[0], t[1], t[2], t[3]]);
                case 2: return call('MathVfpu.vqmul2', [s[0], s[1], s[2], s[3], t[0], t[1], t[2], t[3]]);
                case 3: return call('MathVfpu.vqmul3', [s[0], s[1], s[2], s[3], t[0], t[1], t[2], t[3]]);
            }
        }, 4, 4, 4);
    };
    InstructionAst.prototype.vslt = function (i) { return this._vset3(i, function (i, s, t) { return call('MathFloat.vslt', [s[i], t[i]]); }); };
    InstructionAst.prototype.vsle = function (i) { return this._vset3(i, function (i, s, t) { return call('MathFloat.vsle', [s[i], t[i]]); }); };
    InstructionAst.prototype.vsge = function (i) { return this._vset3(i, function (i, s, t) { return call('MathFloat.vsge', [s[i], t[i]]); }); };
    InstructionAst.prototype.vsgt = function (i) { return this._vset3(i, function (i, s, t) { return call('MathFloat.vsgt', [s[i], t[i]]); }); };
    InstructionAst.prototype.vscmp = function (i) { return this._vset3(i, function (i, s, t) { return call('MathFloat.sign2', [s[i], t[i]]); }); };
    InstructionAst.prototype._bvtf = function (i, cond) {
        var reg = i.IMM3;
        var branchExpr = ast.VCC(reg);
        if (!cond)
            branchExpr = unop("!", branchExpr);
        return this._branch(i, branchExpr);
    };
    InstructionAst.prototype.bvf = function (i) { return this._bvtf(i, false); };
    InstructionAst.prototype.bvt = function (i) { return this._bvtf(i, true); };
    InstructionAst.prototype.bvfl = function (i) { return this.bvf(i); };
    InstructionAst.prototype.bvtl = function (i) { return this.bvt(i); };
    InstructionAst.prototype.mtv = function (i) { return this._vset1(i, function (_) { return gpr(i.rt); }, 1, 'int'); };
    InstructionAst.prototype.mfv = function (i) { return assign_stm(gpr(i.rt), vfpr_i(i.VD)); };
    InstructionAst.prototype.mtvc = function (i) {
        switch (i.IMM7) {
            case 0:
                this._vpfxs.setUnknown();
                break;
            case 1:
                this._vpfxt.setUnknown();
                break;
            case 2:
                this._vpfxd.setUnknown();
                break;
        }
        return assign_stm(vfprc(i.IMM7), gpr(i.rt));
    };
    InstructionAst.prototype.mfvc = function (i) {
        return assign_stm(gpr(i.rt), vfprc(i.IMM7));
    };
    InstructionAst.prototype._vcmovtf = function (i, True) {
        var result = call_stm('state.vcmovtf', [
            imm32(i.IMM3),
            immBool(True),
            ast.arrayNumbers(getVectorRegs(i.VD, i.ONE_TWO)),
            ast.arrayNumbers(getVectorRegs(i.VS, i.ONE_TWO))
        ]);
        this.eatPrefixes();
        return result;
    };
    InstructionAst.prototype.vcmovt = function (i) { return this._vcmovtf(i, true); };
    InstructionAst.prototype.vcmovf = function (i) { return this._vcmovtf(i, false); };
    InstructionAst.prototype.vcmp = function (i) {
        var result = call_stm('state.vcmp', [
            imm32(i.IMM4),
            ast.array(readVector_f(i.VS, i.ONE_TWO)),
            ast.array(readVector_f(i.VT, i.ONE_TWO))
        ]);
        this.eatPrefixes();
        return result;
    };
    InstructionAst.prototype.vwbn = function (i) { return ast.stm(); };
    InstructionAst.prototype.vsbn = function (i) { return ast.stm(); };
    InstructionAst.prototype.vabs = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.abs', [src[i]]); }); };
    InstructionAst.prototype.vocp = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.ocp', [src[i]]); }); };
    InstructionAst.prototype.vneg = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.neg', [src[i]]); }); };
    InstructionAst.prototype.vsgn = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.sign', [src[i]]); }); };
    InstructionAst.prototype.vsat0 = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.sat0', [src[i]]); }); };
    InstructionAst.prototype.vsat1 = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.sat1', [src[i]]); }); };
    InstructionAst.prototype.vrsq = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.rsq', [src[i]]); }); };
    InstructionAst.prototype.vsin = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.sinv1', [src[i]]); }); };
    InstructionAst.prototype.vcos = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.cosv1', [src[i]]); }); };
    InstructionAst.prototype.vexp2 = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.exp2', [src[i]]); }); };
    InstructionAst.prototype.vrexp2 = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.rexp2', [src[i]]); }); };
    InstructionAst.prototype.vlog2 = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.log2', [src[i]]); }); };
    InstructionAst.prototype.vsqrt = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.sqrt', [src[i]]); }); };
    InstructionAst.prototype.vasin = function (i) {
        return stms([
            this._vset2(i, function (i, src) { return call('MathFloat.asinv1', [src[i]]); }),
        ]);
    };
    InstructionAst.prototype.vnsin = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.nsinv1', [src[i]]); }); };
    InstructionAst.prototype.vnrcp = function (i) { return this._vset2(i, function (i, src) { return call('MathFloat.nrcp', [src[i]]); }); };
    InstructionAst.prototype.vmin = function (i) { return this._vset3(i, function (i, src, target) { return call('MathFloat.min', [src[i], target[i]]); }); };
    InstructionAst.prototype.vmax = function (i) { return this._vset3(i, function (i, src, target) { return call('MathFloat.max', [src[i], target[i]]); }); };
    InstructionAst.prototype.vdiv = function (i) { return this._vset3(i, function (i, src, target) { return binop(src[i], '/', target[i]); }); };
    InstructionAst.prototype.vadd = function (i) { return this._vset3(i, function (i, src, target) { return binop(src[i], '+', target[i]); }); };
    InstructionAst.prototype.vsub = function (i) { return this._vset3(i, function (i, src, target) { return binop(src[i], '-', target[i]); }); };
    InstructionAst.prototype.vscl = function (i) { return this._vset3(i, function (i, src, target) { return binop(src[i], '*', target[0]); }, 0, 0, 1); };
    InstructionAst.prototype.vdot = function (i) {
        var _this = this;
        var vectorSize = i.ONE_TWO;
        return this._vset3(i, function (i, s, t) {
            return _this._aggregateV(imm_f(0), vectorSize, function (sum, n) { return binop(sum, '+', binop(s[n], '*', t[n])); });
        }, 1, vectorSize, vectorSize);
    };
    InstructionAst.prototype.vrot = function (i) {
        var vectorSize = i.ONE_TWO;
        var imm5 = i.IMM5;
        var cosIndex = BitUtils.extract(imm5, 0, 2);
        var sinIndex = BitUtils.extract(imm5, 2, 2);
        var negateSin = BitUtils.extractBool(imm5, 4);
        var dest = getVectorRegs(i.VD, i.ONE_TWO);
        return this._vset2(i, function (i, s) {
            var sine = call('MathFloat.sinv1', [s[0]]);
            var cosine = call('MathFloat.cosv1', [s[0]]);
            if (negateSin)
                sine = unop('-', sine);
            if (i == cosIndex)
                return cosine;
            if (i == sinIndex)
                return sine;
            return (sinIndex == cosIndex) ? sine : imm32(0);
        }, vectorSize, 1);
    };
    InstructionAst.prototype.vmmov = function (i) {
        var vectorSize = i.ONE_TWO;
        var dest = getMatrixRegs(i.VD, vectorSize);
        var src = readMatrix(i.VS, vectorSize);
        var result = setMatrix(dest, function (column, row, index) { return src[index]; });
        this.eatPrefixes();
        return result;
    };
    InstructionAst.prototype.vmmul = function (i) {
        var VectorSize = i.ONE_TWO;
        var dest = getMatrixRegs(i.VD, VectorSize);
        var src = readMatrix(i.VS, VectorSize);
        var target = readMatrix(i.VT, VectorSize);
        var st = [];
        st.push(setMatrix(dest, function (Column, Row, Index) {
            var sum = imm_f(0);
            for (var n = 0; n < VectorSize; n++) {
                sum = binop(sum, '+', binop(src[Column * VectorSize + n], '*', target[Row * VectorSize + n]));
            }
            return sum;
        }));
        st.push(call_stm('state.eatPrefixes', []));
        this.eatPrefixes();
        return stms(st);
    };
    InstructionAst.prototype['vt4444.q'] = function (i) { return this._vtXXX_q(i, '_vt4444_step'); };
    InstructionAst.prototype['vt5551.q'] = function (i) { return this._vtXXX_q(i, '_vt5551_step'); };
    InstructionAst.prototype['vt5650.q'] = function (i) { return this._vtXXX_q(i, '_vt5650_step'); };
    InstructionAst.prototype._vtXXX_q = function (i, func) {
        var size = i.ONE_TWO;
        if (size != 4)
            throw (new Error("Not implemented _vtXXXX_q for VectorSize=" + size));
        var dest = getVectorRegs(i.VD, 2);
        var src = readVector_i(i.VS, 4);
        var result = setVector_i(dest, function (index) { return ast.call('state.' + func, [src[index * 2 + 0], src[index * 2 + 1]]); });
        this.eatPrefixes();
        return result;
    };
    InstructionAst.prototype.add = function (i) { return this.addu(i); };
    InstructionAst.prototype.addu = function (i) { return assignGpr(i.rd, binop(gpr(i.rs), '+', gpr(i.rt))); };
    InstructionAst.prototype.addi = function (i) { return this.addiu(i); };
    InstructionAst.prototype.addiu = function (i) { return assignGpr(i.rt, binop(gpr(i.rs), '+', imm32(i.imm16))); };
    InstructionAst.prototype.sub = function (i) { return this.subu(i); };
    InstructionAst.prototype.subu = function (i) { return assignGpr(i.rd, binop(gpr(i.rs), '-', gpr(i.rt))); };
    InstructionAst.prototype.sll = function (i) { return assignGpr(i.rd, binop(gpr(i.rt), '<<', imm32(i.pos))); };
    InstructionAst.prototype.sra = function (i) { return assignGpr(i.rd, binop(gpr(i.rt), '>>', imm32(i.pos))); };
    InstructionAst.prototype.srl = function (i) { return assignGpr(i.rd, binop(gpr(i.rt), '>>>', imm32(i.pos))); };
    InstructionAst.prototype.rotr = function (i) { return assignGpr(i.rd, call('BitUtils.rotr', [gpr(i.rt), imm32(i.pos)])); };
    InstructionAst.prototype.sllv = function (i) { return assignGpr(i.rd, binop(gpr(i.rt), '<<', binop(gpr(i.rs), '&', imm32(31)))); };
    InstructionAst.prototype.srav = function (i) { return assignGpr(i.rd, binop(gpr(i.rt), '>>', binop(gpr(i.rs), '&', imm32(31)))); };
    InstructionAst.prototype.srlv = function (i) { return assignGpr(i.rd, binop(gpr(i.rt), '>>>', binop(gpr(i.rs), '&', imm32(31)))); };
    InstructionAst.prototype.rotrv = function (i) { return assignGpr(i.rd, call('BitUtils.rotr', [gpr(i.rt), gpr(i.rs)])); };
    InstructionAst.prototype.bitrev = function (i) { return assignGpr(i.rd, call('BitUtils.bitrev32', [gpr(i.rt)])); };
    InstructionAst.prototype.and = function (i) { return assignGpr(i.rd, binop(gpr(i.rs), '&', gpr(i.rt))); };
    InstructionAst.prototype.or = function (i) { return assignGpr(i.rd, binop(gpr(i.rs), '|', gpr(i.rt))); };
    InstructionAst.prototype.xor = function (i) { return assignGpr(i.rd, binop(gpr(i.rs), '^', gpr(i.rt))); };
    InstructionAst.prototype.nor = function (i) { return assignGpr(i.rd, unop('~', binop(gpr(i.rs), '|', gpr(i.rt)))); };
    InstructionAst.prototype.andi = function (i) { return assignGpr(i.rt, binop(gpr(i.rs), '&', u_imm32(i.u_imm16))); };
    InstructionAst.prototype.ori = function (i) { return assignGpr(i.rt, binop(gpr(i.rs), '|', u_imm32(i.u_imm16))); };
    InstructionAst.prototype.xori = function (i) { return assignGpr(i.rt, binop(gpr(i.rs), '^', u_imm32(i.u_imm16))); };
    InstructionAst.prototype.mflo = function (i) { return assignGpr(i.rd, lo()); };
    InstructionAst.prototype.mfhi = function (i) { return assignGpr(i.rd, hi()); };
    InstructionAst.prototype.mfic = function (i) { return assignGpr(i.rt, ic()); };
    InstructionAst.prototype.mtlo = function (i) { return assign(lo(), gpr(i.rs)); };
    InstructionAst.prototype.mthi = function (i) { return assign(hi(), gpr(i.rs)); };
    InstructionAst.prototype.mtic = function (i) { return assignIC(gpr(i.rt)); };
    InstructionAst.prototype.slt = function (i) { return assignGpr(i.rd, call('state.slt', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.sltu = function (i) { return assignGpr(i.rd, call('state.sltu', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.slti = function (i) { return assignGpr(i.rt, call('state.slt', [gpr(i.rs), imm32(i.imm16)])); };
    InstructionAst.prototype.sltiu = function (i) { return assignGpr(i.rt, call('state.sltu', [gpr(i.rs), u_imm32(i.imm16)])); };
    InstructionAst.prototype.movz = function (i) { return _if(binop(gpr(i.rt), '==', imm32(0)), assignGpr(i.rd, gpr(i.rs))); };
    InstructionAst.prototype.movn = function (i) { return _if(binop(gpr(i.rt), '!=', imm32(0)), assignGpr(i.rd, gpr(i.rs))); };
    InstructionAst.prototype.ext = function (i) { return assignGpr(i.rt, call('BitUtils.extract', [gpr(i.rs), imm32(i.pos), imm32(i.size_e)])); };
    InstructionAst.prototype.ins = function (i) { return assignGpr(i.rt, call('BitUtils.insert', [gpr(i.rt), imm32(i.pos), imm32(i.size_i), gpr(i.rs)])); };
    InstructionAst.prototype.clz = function (i) { return assignGpr(i.rd, call('BitUtils.clz', [gpr(i.rs)])); };
    InstructionAst.prototype.clo = function (i) { return assignGpr(i.rd, call('BitUtils.clo', [gpr(i.rs)])); };
    InstructionAst.prototype.seb = function (i) { return assignGpr(i.rd, call('BitUtils.seb', [gpr(i.rt)])); };
    InstructionAst.prototype.seh = function (i) { return assignGpr(i.rd, call('BitUtils.seh', [gpr(i.rt)])); };
    InstructionAst.prototype.wsbh = function (i) { return assignGpr(i.rd, call('BitUtils.wsbh', [gpr(i.rt)])); };
    InstructionAst.prototype.wsbw = function (i) { return assignGpr(i.rd, call('BitUtils.wsbw', [gpr(i.rt)])); };
    InstructionAst.prototype._trace_state = function () { return stm(ast.call('state._trace_state', [])); };
    InstructionAst.prototype["mov.s"] = function (i) { return assignFpr(i.fd, fpr(i.fs)); };
    InstructionAst.prototype["add.s"] = function (i) { return assignFpr(i.fd, binop(fpr(i.fs), '+', fpr(i.ft))); };
    InstructionAst.prototype["sub.s"] = function (i) { return assignFpr(i.fd, binop(fpr(i.fs), '-', fpr(i.ft))); };
    InstructionAst.prototype["mul.s"] = function (i) { return assignFpr(i.fd, binop(fpr(i.fs), '*', fpr(i.ft))); };
    InstructionAst.prototype["div.s"] = function (i) { return assignFpr(i.fd, binop(fpr(i.fs), '/', fpr(i.ft))); };
    InstructionAst.prototype["abs.s"] = function (i) { return assignFpr(i.fd, call('Math.abs', [fpr(i.fs)])); };
    InstructionAst.prototype["sqrt.s"] = function (i) { return assignFpr(i.fd, call('Math.sqrt', [fpr(i.fs)])); };
    InstructionAst.prototype["neg.s"] = function (i) { return assignFpr(i.fd, unop('-', fpr(i.fs))); };
    InstructionAst.prototype.min = function (i) { return assignGpr(i.rd, call('state.min', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.max = function (i) { return assignGpr(i.rd, call('state.max', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.div = function (i) { return stm(call('state.div', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.divu = function (i) { return stm(call('state.divu', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.mult = function (i) { return stm(call('state.mult', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.multu = function (i) { return stm(call('state.multu', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.madd = function (i) { return stm(call('state.madd', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.maddu = function (i) { return stm(call('state.maddu', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.msub = function (i) { return stm(call('state.msub', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.msubu = function (i) { return stm(call('state.msubu', [gpr(i.rs), gpr(i.rt)])); };
    InstructionAst.prototype.cache = function (i) { return stm(call('state.cache', [gpr(i.rs), imm32(i.rt), imm32(i.imm16)])); };
    InstructionAst.prototype.syscall = function (i) { return stm(call('state.syscall', [imm32(i.syscall)])); };
    InstructionAst.prototype["break"] = function (i) { return stm(call('state.break', [])); };
    InstructionAst.prototype.dbreak = function (i) { return ast.debugger("dbreak"); };
    InstructionAst.prototype._storePC = function (_pc) {
        return assign(pc(), u_imm32(_pc));
    };
    InstructionAst.prototype._branch = function (i, cond) {
        return stms([
            stm(assign(branchflag(), cond)),
            stm(assign(branchpc(), u_imm32(i.PC + i.imm16 * 4 + 4)))
        ]);
    };
    InstructionAst.prototype.beq = function (i) { return this._branch(i, binop(gpr(i.rs), "==", gpr(i.rt))); };
    InstructionAst.prototype.bne = function (i) { return this._branch(i, binop(gpr(i.rs), "!=", gpr(i.rt))); };
    InstructionAst.prototype.bltz = function (i) { return this._branch(i, binop(gpr(i.rs), "<", imm32(0))); };
    InstructionAst.prototype.blez = function (i) { return this._branch(i, binop(gpr(i.rs), "<=", imm32(0))); };
    InstructionAst.prototype.bgtz = function (i) { return this._branch(i, binop(gpr(i.rs), ">", imm32(0))); };
    InstructionAst.prototype.bgez = function (i) { return this._branch(i, binop(gpr(i.rs), ">=", imm32(0))); };
    InstructionAst.prototype.beql = function (i) { return this.beq(i); };
    InstructionAst.prototype.bnel = function (i) { return this.bne(i); };
    InstructionAst.prototype.bltzl = function (i) { return this.bltz(i); };
    InstructionAst.prototype.blezl = function (i) { return this.blez(i); };
    InstructionAst.prototype.bgtzl = function (i) { return this.bgtz(i); };
    InstructionAst.prototype.bgezl = function (i) { return this.bgez(i); };
    InstructionAst.prototype.bltzal = function (i) { return stms([assignGpr(31, u_imm32(i.PC + 8)), this.bltz(i)]); };
    InstructionAst.prototype.bltzall = function (i) { return stms([assignGpr(31, u_imm32(i.PC + 8)), this.bltzl(i)]); };
    InstructionAst.prototype.bgezal = function (i) { return stms([assignGpr(31, u_imm32(i.PC + 8)), this.bgez(i)]); };
    InstructionAst.prototype.bgezall = function (i) { return stms([assignGpr(31, u_imm32(i.PC + 8)), this.bgezl(i)]); };
    InstructionAst.prototype.bc1t = function (i) { return this._branch(i, fcr31_cc()); };
    InstructionAst.prototype.bc1f = function (i) { return this._branch(i, unop("!", fcr31_cc())); };
    InstructionAst.prototype.bc1tl = function (i) { return this.bc1t(i); };
    InstructionAst.prototype.bc1fl = function (i) { return this.bc1f(i); };
    InstructionAst.prototype.mfc1 = function (i) { return assignGpr(i.rt, ast.fpr_i(i.fs)); };
    InstructionAst.prototype.mtc1 = function (i) { return assignFpr_I(i.fs, ast.gpr(i.rt)); };
    InstructionAst.prototype.cfc1 = function (i) { return stm(call('state._cfc1_impl', [imm32(i.rd), imm32(i.rt)])); };
    InstructionAst.prototype.ctc1 = function (i) { return stm(call('state._ctc1_impl', [imm32(i.rd), gpr(i.rt)])); };
    InstructionAst.prototype["trunc.w.s"] = function (i) { return assignFpr_I(i.fd, call('MathFloat.trunc', [fpr(i.fs)])); };
    InstructionAst.prototype["round.w.s"] = function (i) { return assignFpr_I(i.fd, call('MathFloat.round', [fpr(i.fs)])); };
    InstructionAst.prototype["ceil.w.s"] = function (i) { return assignFpr_I(i.fd, call('MathFloat.ceil', [fpr(i.fs)])); };
    InstructionAst.prototype["floor.w.s"] = function (i) { return assignFpr_I(i.fd, call('MathFloat.floor', [fpr(i.fs)])); };
    InstructionAst.prototype["cvt.s.w"] = function (i) { return assignFpr(i.fd, fpr_i(i.fs)); };
    InstructionAst.prototype["cvt.w.s"] = function (i) { return assignFpr_I(i.fd, call('state._cvt_w_s_impl', [fpr(i.fs)])); };
    InstructionAst.prototype.sb = function (i) { return stm(call('memory.sb', [rs_imm16(i), gpr(i.rt)])); };
    InstructionAst.prototype.sh = function (i) { return stm(call('memory.sh', [rs_imm16(i), gpr(i.rt)])); };
    InstructionAst.prototype.sw = function (i) { return stm(call('memory.sw', [rs_imm16(i), gpr(i.rt)])); };
    InstructionAst.prototype.swc1 = function (i) { return stm(call('memory.sw', [rs_imm16(i), fpr_i(i.ft)])); };
    InstructionAst.prototype.swl = function (i) { return stm(call('memory.swl', [rs_imm16(i), gpr(i.rt)])); };
    InstructionAst.prototype.swr = function (i) { return stm(call('memory.swr', [rs_imm16(i), gpr(i.rt)])); };
    InstructionAst.prototype.lb = function (i) { return assignGpr(i.rt, call('memory.lb', [rs_imm16(i)])); };
    InstructionAst.prototype.lbu = function (i) { return assignGpr(i.rt, call('memory.lbu', [rs_imm16(i)])); };
    InstructionAst.prototype.lh = function (i) { return assignGpr(i.rt, call('memory.lh', [rs_imm16(i)])); };
    InstructionAst.prototype.lhu = function (i) { return assignGpr(i.rt, call('memory.lhu', [rs_imm16(i)])); };
    InstructionAst.prototype.lw = function (i) { return assignGpr(i.rt, call('memory.lw', [rs_imm16(i)])); };
    InstructionAst.prototype.lwc1 = function (i) { return assignFpr_I(i.ft, call('memory.lw', [rs_imm16(i)])); };
    InstructionAst.prototype.lwl = function (i) { return assignGpr(i.rt, call('memory.lwl', [rs_imm16(i), gpr(i.rt)])); };
    InstructionAst.prototype.lwr = function (i) { return assignGpr(i.rt, call('memory.lwr', [rs_imm16(i), gpr(i.rt)])); };
    InstructionAst.prototype._callstackPush = function (i) {
        return ast.stm();
    };
    InstructionAst.prototype._callstackPop = function (i) {
        return ast.stm();
    };
    InstructionAst.prototype.j = function (i) {
        return stms([
            stm(assign(branchflag(), imm32(1))),
            stm(assign(branchpc(), u_imm32(i.jump_address)))
        ]);
    };
    InstructionAst.prototype.jr = function (i) {
        var statements = [];
        statements.push(stm(assign(branchflag(), imm32(1))));
        statements.push(stm(assign(branchpc(), gpr(i.rs))));
        if (i.rs == 31) {
            statements.push(this._callstackPop(i));
        }
        return stms(statements);
    };
    InstructionAst.prototype._jrOpt = function (i) {
        return stms([stm(assign(branchpc(), gpr(i.rs)))]);
    };
    InstructionAst.prototype.jal = function (i) { return stms([this.j(i), this._callstackPush(i), assignGpr(31, u_imm32(i.PC + 8))]); };
    InstructionAst.prototype.jalr = function (i) { return stms([this.jr(i), this._callstackPush(i), assignGpr(i.rd, u_imm32(i.PC + 8)),]); };
    InstructionAst.prototype._comp = function (i, fc02, fc3) {
        var fc_unordererd = ((fc02 & 1) != 0);
        var fc_equal = ((fc02 & 2) != 0);
        var fc_less = ((fc02 & 4) != 0);
        var fc_inv_qnan = (fc3 != 0);
        return stm(call('state._comp_impl', [fpr(i.fs), fpr(i.ft), immBool(fc_unordererd), immBool(fc_equal), immBool(fc_less), immBool(fc_inv_qnan)]));
    };
    InstructionAst.prototype["c.f.s"] = function (i) { return this._comp(i, 0, 0); };
    InstructionAst.prototype["c.un.s"] = function (i) { return this._comp(i, 1, 0); };
    InstructionAst.prototype["c.eq.s"] = function (i) { return this._comp(i, 2, 0); };
    InstructionAst.prototype["c.ueq.s"] = function (i) { return this._comp(i, 3, 0); };
    InstructionAst.prototype["c.olt.s"] = function (i) { return this._comp(i, 4, 0); };
    InstructionAst.prototype["c.ult.s"] = function (i) { return this._comp(i, 5, 0); };
    InstructionAst.prototype["c.ole.s"] = function (i) { return this._comp(i, 6, 0); };
    InstructionAst.prototype["c.ule.s"] = function (i) { return this._comp(i, 7, 0); };
    InstructionAst.prototype["c.sf.s"] = function (i) { return this._comp(i, 0, 1); };
    InstructionAst.prototype["c.ngle.s"] = function (i) { return this._comp(i, 1, 1); };
    InstructionAst.prototype["c.seq.s"] = function (i) { return this._comp(i, 2, 1); };
    InstructionAst.prototype["c.ngl.s"] = function (i) { return this._comp(i, 3, 1); };
    InstructionAst.prototype["c.lt.s"] = function (i) { return this._comp(i, 4, 1); };
    InstructionAst.prototype["c.nge.s"] = function (i) { return this._comp(i, 5, 1); };
    InstructionAst.prototype["c.le.s"] = function (i) { return this._comp(i, 6, 1); };
    InstructionAst.prototype["c.ngt.s"] = function (i) { return this._comp(i, 7, 1); };
    return InstructionAst;
})();
exports.InstructionAst = InstructionAst;

},
"src/core/cpu/cpu_core": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var _memory = require('../memory');
var _ast = require('./cpu_ast');
var _instructions = require('./cpu_instructions');
var _codegen = require('./cpu_codegen');
var Memory = _memory.Memory;
var DEBUG_FUNCGEN = false;
var DEBUG_NATIVEFUNC = false;
(function (CpuSpecialAddresses) {
    CpuSpecialAddresses[CpuSpecialAddresses["EXIT_THREAD"] = 268435455] = "EXIT_THREAD";
})(exports.CpuSpecialAddresses || (exports.CpuSpecialAddresses = {}));
var CpuSpecialAddresses = exports.CpuSpecialAddresses;
var VfpuPrefixBase = (function () {
    function VfpuPrefixBase(vfrc, index) {
        this.vfrc = vfrc;
        this.index = index;
        this.enabled = false;
    }
    VfpuPrefixBase.prototype._readInfo = function () { this._info = this.getInfo(); };
    VfpuPrefixBase.prototype.eat = function () { this.enabled = false; };
    VfpuPrefixBase.prototype.getInfo = function () { return this.vfrc[this.index]; };
    VfpuPrefixBase.prototype.setInfo = function (info) {
        this.vfrc[this.index] = info;
        this.enabled = true;
    };
    return VfpuPrefixBase;
})();
var NativeFunction = (function () {
    function NativeFunction() {
    }
    return NativeFunction;
})();
exports.NativeFunction = NativeFunction;
var SyscallManager = (function () {
    function SyscallManager(context) {
        this.context = context;
        this.calls = {};
        this.lastId = 1;
    }
    SyscallManager.prototype.register = function (nativeFunction) {
        return this.registerWithId(this.lastId++, nativeFunction);
    };
    SyscallManager.prototype.registerWithId = function (id, nativeFunction) {
        this.calls[id] = nativeFunction;
        return id;
    };
    SyscallManager.prototype.getName = function (id) {
        var c = this.calls[id];
        if (c)
            return c.name;
        return 'syscall_' + id;
    };
    SyscallManager.prototype.call = function (state, id) {
        var nativeFunction = this.calls[id];
        if (!nativeFunction)
            throw "Can't call syscall " + this.getName(id) + ": " + addressToHex(id) + "\"";
        if (DEBUG_NATIVEFUNC) {
            console.log("calling syscall " + addressToHex(id) + ", " + id + ", " + nativeFunction.name + " with cpustate:" + state.id);
        }
        nativeFunction.call(this.context, state);
    };
    return SyscallManager;
})();
exports.SyscallManager = SyscallManager;
var VfpuPrefixRead = (function (_super) {
    __extends(VfpuPrefixRead, _super);
    function VfpuPrefixRead() {
        _super.apply(this, arguments);
    }
    VfpuPrefixRead.prototype.transformValues = function (input, output) {
        this._readInfo();
        var info = this._info;
        if (!this.enabled) {
            for (var n = 0; n < input.length; n++)
                output[n] = input[n];
        }
        else {
            for (var n = 0; n < input.length; n++) {
                var sourceIndex = (info >> (0 + n * 2)) & 3;
                var sourceAbsolute = (info >> (8 + n * 1)) & 1;
                var sourceConstant = (info >> (12 + n * 1)) & 1;
                var sourceNegate = (info >> (16 + n * 1)) & 1;
                var value;
                if (sourceConstant) {
                    switch (sourceIndex) {
                        case 0:
                            value = sourceAbsolute ? (3) : (0);
                            break;
                        case 1:
                            value = sourceAbsolute ? (1 / 3) : (1);
                            break;
                        case 2:
                            value = sourceAbsolute ? (1 / 4) : (2);
                            break;
                        case 3:
                            value = sourceAbsolute ? (1 / 6) : (1 / 2);
                            break;
                        default:
                            throw (new Error("Invalid operation"));
                            break;
                    }
                }
                else {
                    value = input[sourceIndex];
                    if (sourceAbsolute)
                        value = Math.abs(value);
                }
                if (sourceNegate)
                    value = MathFloat.neg(value);
                output[n] = value;
            }
        }
    };
    return VfpuPrefixRead;
})(VfpuPrefixBase);
var VfpuPrefixWrite = (function (_super) {
    __extends(VfpuPrefixWrite, _super);
    function VfpuPrefixWrite() {
        _super.apply(this, arguments);
    }
    VfpuPrefixWrite.prototype.storeTransformedValues = function (vfpr, indices, values) {
        this._readInfo();
        var info = this._info;
        if (!this.enabled) {
            for (var n = 0; n < indices.length; n++) {
                vfpr[indices[n]] = values[n];
            }
        }
        else {
            for (var n = 0; n < indices.length; n++) {
                var destinationSaturation = (info >> (0 + n * 2)) & 3;
                var destinationMask = (info >> (8 + n * 1)) & 1;
                if (destinationMask) {
                }
                else {
                    var value = values[n];
                    switch (destinationSaturation) {
                        case 1:
                            value = MathFloat.sat0(value);
                            break;
                        case 3:
                            value = MathFloat.sat1(value);
                            break;
                        default: break;
                    }
                    vfpr[indices[n]] = value;
                }
            }
        }
    };
    return VfpuPrefixWrite;
})(VfpuPrefixBase);
(function (VFPU_CTRL) {
    VFPU_CTRL[VFPU_CTRL["SPREFIX"] = 0] = "SPREFIX";
    VFPU_CTRL[VFPU_CTRL["TPREFIX"] = 1] = "TPREFIX";
    VFPU_CTRL[VFPU_CTRL["DPREFIX"] = 2] = "DPREFIX";
    VFPU_CTRL[VFPU_CTRL["CC"] = 3] = "CC";
    VFPU_CTRL[VFPU_CTRL["INF4"] = 4] = "INF4";
    VFPU_CTRL[VFPU_CTRL["RSV5"] = 5] = "RSV5";
    VFPU_CTRL[VFPU_CTRL["RSV6"] = 6] = "RSV6";
    VFPU_CTRL[VFPU_CTRL["REV"] = 7] = "REV";
    VFPU_CTRL[VFPU_CTRL["RCX0"] = 8] = "RCX0";
    VFPU_CTRL[VFPU_CTRL["RCX1"] = 9] = "RCX1";
    VFPU_CTRL[VFPU_CTRL["RCX2"] = 10] = "RCX2";
    VFPU_CTRL[VFPU_CTRL["RCX3"] = 11] = "RCX3";
    VFPU_CTRL[VFPU_CTRL["RCX4"] = 12] = "RCX4";
    VFPU_CTRL[VFPU_CTRL["RCX5"] = 13] = "RCX5";
    VFPU_CTRL[VFPU_CTRL["RCX6"] = 14] = "RCX6";
    VFPU_CTRL[VFPU_CTRL["RCX7"] = 15] = "RCX7";
    VFPU_CTRL[VFPU_CTRL["MAX"] = 16] = "MAX";
})(exports.VFPU_CTRL || (exports.VFPU_CTRL = {}));
var VFPU_CTRL = exports.VFPU_CTRL;
(function (VCondition) {
    VCondition[VCondition["FL"] = 0] = "FL";
    VCondition[VCondition["EQ"] = 1] = "EQ";
    VCondition[VCondition["LT"] = 2] = "LT";
    VCondition[VCondition["LE"] = 3] = "LE";
    VCondition[VCondition["TR"] = 4] = "TR";
    VCondition[VCondition["NE"] = 5] = "NE";
    VCondition[VCondition["GE"] = 6] = "GE";
    VCondition[VCondition["GT"] = 7] = "GT";
    VCondition[VCondition["EZ"] = 8] = "EZ";
    VCondition[VCondition["EN"] = 9] = "EN";
    VCondition[VCondition["EI"] = 10] = "EI";
    VCondition[VCondition["ES"] = 11] = "ES";
    VCondition[VCondition["NZ"] = 12] = "NZ";
    VCondition[VCondition["NN"] = 13] = "NN";
    VCondition[VCondition["NI"] = 14] = "NI";
    VCondition[VCondition["NS"] = 15] = "NS";
})(exports.VCondition || (exports.VCondition = {}));
var VCondition = exports.VCondition;
;
var CpuState = (function () {
    function CpuState(memory, syscallManager) {
        this.memory = memory;
        this.syscallManager = syscallManager;
        this.id = CpuState.lastId++;
        this.gpr_Buffer = new ArrayBuffer(32 * 4);
        this.gpr = new Int32Array(this.gpr_Buffer);
        this.gpr_f = new Float32Array(this.gpr_Buffer);
        this.jumpCall = null;
        this.temp = new Array(16);
        this.fpr_Buffer = new ArrayBuffer(32 * 4);
        this.fpr = new Float32Array(this.fpr_Buffer);
        this.fpr_i = new Int32Array(this.fpr_Buffer);
        this.vfpr_Buffer = new ArrayBuffer(128 * 4);
        this.vfpr = new Float32Array(this.vfpr_Buffer);
        this.vfpr_i = new Int32Array(this.vfpr_Buffer);
        this.vfprc = [0, 0, 0, 0xFF, 0, 0, 0, 0, 0x3F800000, 0x3F800000, 0x3F800000, 0x3F800000, 0x3F800000, 0x3F800000, 0x3F800000, 0x3F800000];
        this.vpfxs = new VfpuPrefixRead(this.vfprc, VFPU_CTRL.SPREFIX);
        this.vpfxt = new VfpuPrefixRead(this.vfprc, VFPU_CTRL.TPREFIX);
        this.vpfxd = new VfpuPrefixWrite(this.vfprc, VFPU_CTRL.DPREFIX);
        this.vector_vs = [0, 0, 0, 0];
        this.vector_vt = [0, 0, 0, 0];
        this.vector_vd = [0, 0, 0, 0];
        this.PC = 0;
        this.IC = 0;
        this.LO = 0;
        this.HI = 0;
        this.thread = null;
        this.callstack = [];
        this.fcr31_rm = 0;
        this.fcr31_2_21 = 0;
        this.fcr31_25_7 = 0;
        this.fcr31_cc = false;
        this.fcr31_fs = false;
        this.fcr0 = 0x00003351;
        this.icache = new InstructionCache(memory, syscallManager);
        this.fcr0 = 0x00003351;
        this.fcr31 = 0x00000e00;
    }
    CpuState.prototype.clone = function () {
        var that = new CpuState(this.memory, this.syscallManager);
        that.icache = this.icache;
        that.copyRegistersFrom(this);
        return that;
    };
    CpuState.prototype.setVfrCc = function (index, value) {
        if (value) {
            this.vfprc[VFPU_CTRL.CC] |= (1 << index);
        }
        else {
            this.vfprc[VFPU_CTRL.CC] &= ~(1 << index);
        }
    };
    CpuState.prototype.vrnds = function () { };
    CpuState.prototype.vrndi = function () {
        var v = 0;
        for (var n = 0; n < 4; n++) {
            v <<= 8;
            v |= (Math.round(Math.random() * 255) & 0xFF);
        }
        return v;
    };
    CpuState.prototype.vrndf1 = function () { return Math.random() * 2; };
    CpuState.prototype.vrndf2 = function () { return Math.random() * 4; };
    CpuState.prototype.getVfrCc = function (index) {
        return ((this.vfprc[VFPU_CTRL.CC] & (1 << index)) != 0);
    };
    CpuState.prototype.vcmp = function (cond, vsValues, vtValues) {
        var vectorSize = vsValues.length;
        this.loadVs_prefixed(vsValues);
        this.loadVt_prefixed(vtValues);
        var s = this.vector_vs;
        var t = this.vector_vt;
        var cc = 0;
        var or_val = 0;
        var and_val = 1;
        var affected_bits = (1 << 4) | (1 << 5);
        for (var i = 0; i < vectorSize; i++) {
            var c = false;
            switch (cond) {
                case VCondition.FL:
                    c = false;
                    break;
                case VCondition.EQ:
                    c = s[i] == t[i];
                    break;
                case VCondition.LT:
                    c = s[i] < t[i];
                    break;
                case VCondition.LE:
                    c = s[i] <= t[i];
                    break;
                case VCondition.TR:
                    c = true;
                    break;
                case VCondition.NE:
                    c = s[i] != t[i];
                    break;
                case VCondition.GE:
                    c = s[i] >= t[i];
                    break;
                case VCondition.GT:
                    c = s[i] > t[i];
                    break;
                case VCondition.EZ:
                    c = s[i] == 0.0 || s[i] == -0.0;
                    break;
                case VCondition.EN:
                    c = MathFloat.isnan(s[i]);
                    break;
                case VCondition.EI:
                    c = MathFloat.isinf(s[i]);
                    break;
                case VCondition.ES:
                    c = MathFloat.isnanorinf(s[i]);
                    break;
                case VCondition.NZ:
                    c = s[i] != 0;
                    break;
                case VCondition.NN:
                    c = !MathFloat.isnan(s[i]);
                    break;
                case VCondition.NI:
                    c = !MathFloat.isinf(s[i]);
                    break;
                case VCondition.NS:
                    c = !(MathFloat.isnanorinf(s[i]));
                    break;
            }
            var c_i = (c ? 1 : 0);
            cc |= (c_i << i);
            or_val |= c_i;
            and_val &= c_i;
            affected_bits |= 1 << i;
        }
        this.vfprc[VFPU_CTRL.CC] = (this.vfprc[VFPU_CTRL.CC] & ~affected_bits) | ((cc | (or_val << 4) | (and_val << 5)) & affected_bits);
        this.eatPrefixes();
    };
    CpuState.prototype.vcmovtf = function (register, _true, vdRegs, vsRegs) {
        var _this = this;
        var vectorSize = vdRegs.length;
        this.loadVs_prefixed(vsRegs.map(function (reg) { return _this.vfpr[reg]; }));
        this.loadVdRegs(vdRegs);
        var compare = _true ? 1 : 0;
        var cc = this.vfprc[VFPU_CTRL.CC];
        if (register < 6) {
            if (((cc >> register) & 1) == compare) {
                for (var n = 0; n < vectorSize; n++) {
                    this.vector_vd[n] = this.vector_vs[n];
                }
            }
        }
        if (register == 6) {
            for (var n = 0; n < vectorSize; n++) {
                if (((cc >> n) & 1) == compare) {
                    this.vector_vd[n] = this.vector_vs[n];
                }
            }
        }
        else {
        }
        this.storeVdRegsWithPrefix(vdRegs);
    };
    CpuState.prototype.setVpfxt = function (value) { this.vpfxt.setInfo(value); };
    CpuState.prototype.setVpfxs = function (value) { this.vpfxs.setInfo(value); };
    CpuState.prototype.setVpfxd = function (value) { this.vpfxd.setInfo(value); };
    Object.defineProperty(CpuState.prototype, "vfpumatrix0", {
        get: function () { return this.getVfpumatrix(0); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "vfpumatrix1", {
        get: function () { return this.getVfpumatrix(1); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "vfpumatrix2", {
        get: function () { return this.getVfpumatrix(2); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "vfpumatrix3", {
        get: function () { return this.getVfpumatrix(3); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "vfpumatrix4", {
        get: function () { return this.getVfpumatrix(4); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "vfpumatrix5", {
        get: function () { return this.getVfpumatrix(5); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "vfpumatrix6", {
        get: function () { return this.getVfpumatrix(6); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "vfpumatrix7", {
        get: function () { return this.getVfpumatrix(7); },
        enumerable: true,
        configurable: true
    });
    CpuState.prototype.eatPrefixes = function () {
        this.vpfxd.eat();
        this.vpfxt.eat();
        this.vpfxs.eat();
    };
    CpuState.prototype.getVfpumatrix = function (index) {
        var values = [];
        for (var r = 0; r < 4; r++) {
            for (var c = 0; c < 4; c++) {
                values.push(this.vfpr[r * 32 + index * 4 + c]);
            }
        }
        return values;
    };
    CpuState.prototype.loadVdRegs = function (regs) {
        for (var n = 0; n < regs.length; n++) {
            this.vector_vd[n] = this.vfpr[regs[n]];
        }
    };
    CpuState.prototype.storeVdRegsWithPrefix = function (regs) {
        this.vpfxd.storeTransformedValues(this.vfpr, regs, this.vector_vd);
        this.vpfxd.eat();
        this.storeVdRegs(regs);
    };
    CpuState.prototype.storeVdRegsWithPrefix1 = function (regs) {
        this.vpfxd.storeTransformedValues(this.vfpr, regs, this.vector_vd);
        this.vpfxd.eat();
        this.storeVdRegs(regs);
    };
    CpuState.prototype.storeVdRegs = function (regs) {
        for (var n = 0; n < regs.length; n++)
            this.vfpr[regs[n]] = this.vector_vd[n];
    };
    CpuState.prototype.loadVs_prefixed = function (values) {
        this.vpfxs.transformValues(values, this.vector_vs);
        this.vpfxs.eat();
    };
    CpuState.prototype.loadVt_prefixed = function (values) {
        this.vpfxt.transformValues(values, this.vector_vt);
        this.vpfxt.eat();
    };
    CpuState.prototype.storeVd_prefixed = function (indices, values) {
        this.vpfxd.storeTransformedValues(this.vfpr, indices, values);
        this.vpfxd.eat();
    };
    CpuState.prototype.storeVd_prefixed_i = function (indices, values) {
        this.vpfxd.storeTransformedValues(this.vfpr_i, indices, values);
        this.vpfxd.eat();
    };
    CpuState.prototype._vt4444_step = function (i0, i1) {
        var o = 0;
        o |= ((i0 >> 4) & 15) << 0;
        o |= ((i0 >> 12) & 15) << 4;
        o |= ((i0 >> 20) & 15) << 8;
        o |= ((i0 >> 28) & 15) << 12;
        o |= ((i1 >> 4) & 15) << 16;
        o |= ((i1 >> 12) & 15) << 20;
        o |= ((i1 >> 20) & 15) << 24;
        o |= ((i1 >> 28) & 15) << 28;
        return o;
    };
    CpuState.prototype._vt5551_step = function (i0, i1) {
        var o = 0;
        o |= ((i0 >> 3) & 31) << 0;
        o |= ((i0 >> 11) & 31) << 5;
        o |= ((i0 >> 19) & 31) << 10;
        o |= ((i0 >> 31) & 1) << 15;
        o |= ((i1 >> 3) & 31) << 16;
        o |= ((i1 >> 11) & 31) << 21;
        o |= ((i1 >> 19) & 31) << 26;
        o |= ((i1 >> 31) & 1) << 31;
        return o;
    };
    CpuState.prototype._vt5650_step = function (i0, i1) {
        var o = 0;
        o |= ((i0 >> 3) & 31) << 0;
        o |= ((i0 >> 10) & 63) << 5;
        o |= ((i0 >> 19) & 31) << 11;
        o |= ((i1 >> 3) & 31) << 16;
        o |= ((i1 >> 10) & 63) << 21;
        o |= ((i1 >> 19) & 31) << 27;
        return o;
    };
    CpuState.prototype.svl_q = function (address, r) {
        var k = (3 - ((address >>> 2) & 3));
        address &= ~0xF;
        for (var n = k; n < 4; n++, address += 4)
            this.memory.sw(address, this.vfpr_i[r[n]]);
    };
    CpuState.prototype.svr_q = function (address, r) {
        var k = (4 - ((address >>> 2) & 3));
        for (var n = 0; n < k; n++, address += 4)
            this.memory.sw(address, this.vfpr_i[r[n]]);
    };
    CpuState.prototype.lvl_q = function (address, r) {
        var k = (3 - ((address >>> 2) & 3));
        address &= ~0xF;
        for (var n = k; n < 4; n++, address += 4)
            this.vfpr_i[r[n]] = this.memory.lw(address);
    };
    CpuState.prototype.lvr_q = function (address, r) {
        var k = (4 - ((address >>> 2) & 3));
        for (var n = 0; n < k; n++, address += 4)
            this.vfpr_i[r[n]] = this.memory.lw(address);
    };
    CpuState.prototype.storeFloats = function (address, values) {
        for (var n = 0; n < values.length; n++) {
            this.memory.writeFloat32(address + n * 4, values[n]);
        }
    };
    CpuState.prototype.vfpuStore = function (indices, values) { for (var n = 0; n < indices.length; n++)
        this.vfpr[indices[n]] = values[n]; };
    CpuState.prototype.vfpuStore_i = function (indices, values) { for (var n = 0; n < indices.length; n++)
        this.vfpr_i[indices[n]] = values[n]; };
    CpuState.prototype.vfpuSetMatrix = function (m, values) {
        this.vfpr[0] = 0;
        throw new Error("Not implemented vfpuSetMatrix!");
    };
    CpuState.prototype.preserveRegisters = function (callback) {
        var temp = new CpuState(this.memory, this.syscallManager);
        temp.copyRegistersFrom(this);
        callback();
        this.copyRegistersFrom(temp);
    };
    CpuState.prototype.copyRegistersFrom = function (other) {
        this.PC = other.PC;
        this.IC = other.IC;
        this.LO = other.LO;
        this.HI = other.HI;
        for (var n = 0; n < 32; n++)
            this.gpr[n] = other.gpr[n];
        for (var n = 0; n < 32; n++)
            this.fpr[n] = other.fpr[n];
        for (var n = 0; n < 128; n++)
            this.vfpr[n] = other.vfpr[n];
        for (var n = 0; n < 8; n++)
            this.vfprc[n] = other.vfprc[n];
    };
    Object.defineProperty(CpuState.prototype, "V0", {
        get: function () { return this.gpr[2]; },
        set: function (value) { this.gpr[2] = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "V1", {
        get: function () { return this.gpr[3]; },
        set: function (value) { this.gpr[3] = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "K0", {
        get: function () { return this.gpr[26]; },
        set: function (value) { this.gpr[26] = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "GP", {
        get: function () { return this.gpr[28]; },
        set: function (value) { this.gpr[28] = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "SP", {
        get: function () { return this.gpr[29]; },
        set: function (value) { this.gpr[29] = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "FP", {
        get: function () { return this.gpr[30]; },
        set: function (value) { this.gpr[30] = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "RA", {
        get: function () { return this.gpr[31]; },
        set: function (value) { this.gpr[31] = value; },
        enumerable: true,
        configurable: true
    });
    CpuState.prototype.getRA = function () { return this.gpr[31]; };
    CpuState.prototype.setRA = function (value) { this.gpr[31] = value; };
    CpuState.prototype.callstackPush = function (PC) {
    };
    CpuState.prototype.callstackPop = function () {
    };
    CpuState.prototype.printCallstack = function (symbolLookup) {
        if (symbolLookup === void 0) { symbolLookup = null; }
        this.getCallstack().forEach(function (PC) {
            var line = addressToHex(PC);
            if (symbolLookup) {
                line += " : " + symbolLookup.getSymbolAt(PC);
            }
            console.log(line);
        });
    };
    CpuState.prototype.getCallstack = function () {
        return this.callstack.slice(0);
    };
    CpuState.prototype._trace_state = function () {
        console.info(this);
        throw ('_trace_state');
    };
    Object.defineProperty(CpuState.prototype, "fcr31", {
        get: function () {
            var value = 0;
            value = BitUtils.insert(value, 0, 2, this.fcr31_rm);
            value = BitUtils.insert(value, 2, 21, this.fcr31_2_21);
            value = BitUtils.insert(value, 23, 1, this.fcr31_cc ? 1 : 0);
            value = BitUtils.insert(value, 24, 1, this.fcr31_fs ? 1 : 0);
            value = BitUtils.insert(value, 25, 7, this.fcr31_25_7);
            return value;
        },
        set: function (value) {
            this.fcr31_rm = BitUtils.extract(value, 0, 2);
            this.fcr31_2_21 = BitUtils.extract(value, 2, 21);
            this.fcr31_cc = (BitUtils.extract(value, 23, 1) != 0);
            this.fcr31_fs = (BitUtils.extract(value, 24, 1) != 0);
            this.fcr31_25_7 = BitUtils.extract(value, 25, 7);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "fcr0_rev", {
        get: function () { return BitUtils.extract(this.fcr0, 0, 8); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "fcr0_imp", {
        get: function () { return BitUtils.extract(this.fcr0, 8, 24); },
        enumerable: true,
        configurable: true
    });
    CpuState.prototype._cfc1_impl = function (d, t) {
        switch (d) {
            case 0:
                this.gpr[t] = this.fcr0;
                break;
            case 31:
                this.gpr[t] = this.fcr31;
                break;
            default:
                this.gpr[t] = 0;
                break;
        }
    };
    CpuState.prototype._ctc1_impl = function (d, t) {
        switch (d) {
            case 31:
                this.fcr31 = t;
                break;
        }
    };
    CpuState.prototype._comp_impl = function (s, t, fc_unordererd, fc_equal, fc_less, fc_inv_qnan) {
        if (isNaN(s) || isNaN(t)) {
            this.fcr31_cc = fc_unordererd;
        }
        else {
            var equal = (fc_equal) && (s == t);
            var less = (fc_less) && (s < t);
            this.fcr31_cc = (less || equal);
        }
    };
    CpuState.prototype._cvt_w_s_impl = function (FS) {
        switch (this.fcr31_rm) {
            case 0: return MathFloat.rint(FS);
            case 1: return MathFloat.cast(FS);
            case 2: return MathFloat.ceil(FS);
            case 3: return MathFloat.floor(FS);
        }
        throw ("RM has an invalid value!!");
    };
    CpuState.prototype.cache = function (rs, type, offset) {
    };
    CpuState.prototype.syscall = function (id) { this.syscallManager.call(this, id); };
    CpuState.prototype.min = function (a, b) { return ((a | 0) < (b | 0)) ? a : b; };
    CpuState.prototype.max = function (a, b) { return ((a | 0) > (b | 0)) ? a : b; };
    CpuState.prototype.slt = function (a, b) { return ((a | 0) < (b | 0)) ? 1 : 0; };
    CpuState.prototype.sltu = function (a, b) { return ((a >>> 0) < (b >>> 0)) ? 1 : 0; };
    CpuState.prototype.div = function (rs, rt) {
        rs |= 0;
        rt |= 0;
        this.LO = (rs / rt) | 0;
        this.HI = (rs % rt) | 0;
    };
    CpuState.prototype.divu = function (rs, rt) {
        rs >>>= 0;
        rt >>>= 0;
        this.LO = (rs / rt) | 0;
        this.HI = (rs % rt) | 0;
    };
    CpuState.prototype.mult = function (rs, rt) {
        Math.imul32_64(rs, rt, CpuState._mult_temp);
        this.LO = CpuState._mult_temp[0];
        this.HI = CpuState._mult_temp[1];
    };
    CpuState.prototype.madd = function (rs, rt) {
        var a64 = Integer64.fromInt(rs);
        var b64 = Integer64.fromInt(rt);
        var result = Integer64.fromBits(this.LO, this.HI).add(a64.multiply(b64));
        this.HI = result.high;
        this.LO = result.low;
    };
    CpuState.prototype.msub = function (rs, rt) {
        var a64 = Integer64.fromInt(rs);
        var b64 = Integer64.fromInt(rt);
        var result = Integer64.fromBits(this.LO, this.HI).sub(a64.multiply(b64));
        this.HI = result.high;
        this.LO = result.low;
    };
    CpuState.prototype.multu = function (rs, rt) {
        var info = Math.umul32_64(rs, rt, CpuState._mult_temp);
        this.LO = info[0];
        this.HI = info[1];
    };
    CpuState.prototype.maddu = function (rs, rt) {
        var a64 = Integer64.fromUnsignedInt(rs);
        var b64 = Integer64.fromUnsignedInt(rt);
        var result = Integer64.fromBits(this.LO, this.HI).add(a64.multiply(b64));
        this.HI = result.high;
        this.LO = result.low;
    };
    CpuState.prototype.msubu = function (rs, rt) {
        var a64 = Integer64.fromUnsignedInt(rs);
        var b64 = Integer64.fromUnsignedInt(rt);
        var result = Integer64.fromBits(this.LO, this.HI).sub(a64.multiply(b64));
        this.HI = result.high;
        this.LO = result.low;
    };
    CpuState.prototype.getFunction = function (pc) {
        return this.icache.getFunction(pc);
    };
    CpuState.prototype.executeAtPC = function () {
        while (true) {
            this.getFunction(this.PC).execute(this);
        }
    };
    CpuState.prototype.break = function () { throw new Error('CpuBreakException'); };
    CpuState.lastId = 0;
    CpuState._mult_temp = [0, 0];
    return CpuState;
})();
exports.CpuState = CpuState;
var ast = new _ast.MipsAstBuilder();
var PspInstructionStm = (function (_super) {
    __extends(PspInstructionStm, _super);
    function PspInstructionStm(di, code) {
        _super.call(this);
        this.di = di;
        this.code = code;
        this.PC = di.PC;
    }
    PspInstructionStm.prototype.toJs = function () {
        return this.code.toJs() + " /* " + this.di.type.name + " */";
    };
    PspInstructionStm.prototype.optimize = function () { return new PspInstructionStm(this.di, this.code.optimize()); };
    return PspInstructionStm;
})(_ast.ANodeStm);
var CpuFunctionWithArgs = (function () {
    function CpuFunctionWithArgs(func, args) {
        this.func = func;
        this.args = args;
    }
    return CpuFunctionWithArgs;
})();
var InvalidatableCpuFunction = (function () {
    function InvalidatableCpuFunction(PC, generator) {
        this.PC = PC;
        this.generator = generator;
        this.func = null;
    }
    InvalidatableCpuFunction.prototype.invalidate = function () { this.func = null; };
    InvalidatableCpuFunction.prototype.execute = function (state) {
        if (this.func == null)
            this.func = this.generator(this.PC);
        this.func.func(state);
    };
    return InvalidatableCpuFunction;
})();
exports.InvalidatableCpuFunction = InvalidatableCpuFunction;
var InstructionCache = (function () {
    function InstructionCache(memory, syscallManager) {
        this.memory = memory;
        this.syscallManager = syscallManager;
        this.cache = {};
        this.functions = {};
        this.functionGenerator = new FunctionGenerator(memory, syscallManager, this);
        this.createBind = this.create.bind(this);
    }
    InstructionCache.prototype.invalidateAll = function () {
        for (var pc in this.cache) {
            this.cache[pc].invalidate();
            delete this.functions[pc];
        }
    };
    InstructionCache.prototype.invalidateRange = function (from, to) {
        for (var pc = from; pc < to; pc += 4) {
            if (this.cache[pc])
                this.cache[pc].invalidate();
            delete this.functions[pc];
        }
    };
    InstructionCache.prototype.create = function (address) {
        var info = this.functionGenerator.getFunctionInfo(address);
        var func = this.functions[info.start];
        if (!func) {
            this.functions[info.start] = func = this.functionGenerator.getFunction(info);
            if (DEBUG_FUNCGEN) {
                console.log('****************************************');
                console.log('****************************************');
                console.log(func.info);
                console.log(func.code.code);
            }
        }
        return func.fargs;
    };
    InstructionCache.prototype.getFunction = function (address) {
        address &= Memory.MASK;
        if (!this.cache[address]) {
            this.cache[address] = new InvalidatableCpuFunction(address, this.createBind);
        }
        return this.cache[address];
    };
    return InstructionCache;
})();
exports.InstructionCache = InstructionCache;
var FunctionGeneratorResult = (function () {
    function FunctionGeneratorResult(func, code, info, fargs) {
        this.func = func;
        this.code = code;
        this.info = info;
        this.fargs = fargs;
    }
    return FunctionGeneratorResult;
})();
var FunctionCode = (function () {
    function FunctionCode(code, args) {
        this.code = code;
        this.args = args;
    }
    return FunctionCode;
})();
var FunctionGenerator = (function () {
    function FunctionGenerator(memory, syscallManager, instructionCache) {
        this.memory = memory;
        this.syscallManager = syscallManager;
        this.instructionCache = instructionCache;
        this.instructions = _instructions.Instructions.instance;
        this.instructionAst = new _codegen.InstructionAst();
        this.instructionUsageCount = {};
        this.enableJumpBranch = true;
    }
    FunctionGenerator.prototype.getInstructionUsageCount = function () {
        var items = [];
        for (var key in this.instructionUsageCount) {
            var value = this.instructionUsageCount[key];
            items.push({ name: key, count: value });
        }
        items.sort(function (a, b) { return compareNumbers(a.count, b.count); }).reverse();
        return items;
    };
    FunctionGenerator.prototype.decodeInstruction = function (address) {
        var instruction = _instructions.Instruction.fromMemoryAndPC(this.memory, address);
        var instructionType = this.getInstructionType(instruction);
        return new _instructions.DecodedInstruction(instruction, instructionType);
    };
    FunctionGenerator.prototype.getInstructionType = function (i) {
        return this.instructions.findByData(i.data, i.PC);
    };
    FunctionGenerator.prototype.generatePspInstruction = function (di) {
        return new PspInstructionStm(di, this.generateInstructionAstNode(di));
    };
    FunctionGenerator.prototype.generateInstructionAstNode = function (di) {
        var instruction = di.instruction;
        var instructionType = di.type;
        var func = this.instructionAst[instructionType.name];
        if (func === undefined)
            throw (sprintf("Not implemented '%s' at 0x%08X", instructionType, di.instruction.PC));
        return func.call(this.instructionAst, instruction, di);
    };
    FunctionGenerator.prototype.create = function (address) {
        return this.getFunction(this.getFunctionInfo(address));
    };
    FunctionGenerator.prototype.getFunction = function (info) {
        var start = performance.now();
        var code = this.getFunctionCode(info);
        try {
            var startHex = addressToHex(info.start);
            var func = (new Function('args', "return function func_" + startHex + "(state) { \"use strict\"; " + code.code + " }")(code.args));
            var result = new FunctionGeneratorResult(func, code, info, new CpuFunctionWithArgs(func, code.args));
            var end = performance.now();
            var elapsed = end - start;
            if (elapsed >= 20)
                console.warn("generated function " + startHex + " in " + (end - start) + " ms. " + addressToHex(info.min) + "-" + addressToHex(info.max) + " : " + addressToHex(info.start) + " : instructions:" + (info.max - info.start) / 4);
            return result;
        }
        catch (e) {
            console.info('code:\n', code.code);
            console.info('args:\n', code.args);
            throw (e);
        }
    };
    FunctionGenerator.prototype.getFunctionInfo = function (address) {
        if (address == CpuSpecialAddresses.EXIT_THREAD)
            return { start: address, min: address, max: address + 4, labels: {} };
        if (address == 0x00000000)
            throw (new Error("Trying to execute 0x00000000"));
        var explored = {};
        var explore = [address];
        var info = { start: address, min: address, max: address, labels: {} };
        var MAX_EXPLORE = 20000;
        var exploredCount = 0;
        function addToExplore(pc) {
            if (explored[pc])
                return;
            explored[pc] = true;
            explore.push(pc);
        }
        while (explore.length > 0) {
            var PC = explore.shift();
            var di = this.decodeInstruction(PC);
            var type = di.type;
            info.min = Math.min(info.min, PC);
            info.max = Math.max(info.max, PC + 4);
            if (++exploredCount >= MAX_EXPLORE)
                throw new Error("Function too big " + exploredCount);
            var exploreNext = true;
            var exploreTarget = type.isBranch && !type.isRegister;
            if (type.isBreak)
                exploreNext = false;
            if (type.isJumpNoLink)
                exploreNext = false;
            if (di.isUnconditional)
                exploreNext = false;
            if (exploreTarget) {
                if (di.targetAddress >= info.min - 8) {
                    info.labels[di.targetAddress] = true;
                    if (exploreNext)
                        info.labels[PC + 8] = true;
                    addToExplore(di.targetAddress);
                }
            }
            if (exploreNext) {
                addToExplore(PC + 4);
            }
        }
        info.labels[info.start] = true;
        info.labels[info.min] = true;
        return info;
    };
    FunctionGenerator.prototype.getFunctionCode = function (info) {
        var args = {};
        if (info.start == CpuSpecialAddresses.EXIT_THREAD)
            return new FunctionCode("state.thread.stop('CpuSpecialAddresses.EXIT_THREAD'); throw new Error('CpuBreakException');", args);
        var func = ast.func(info.start, ast.raw_stm('var label = 0, BRANCHPC = 0, BRANCHFLAG = false, memory = state.memory, gpr = state.gpr, gpr_f = state.gpr_f;'), ast.raw_stm('state.jumpCall = null; return;'), []);
        var labels = {};
        for (var labelPC in info.labels)
            labels[labelPC] = ast.label(labelPC);
        if (info.min != info.start) {
            func.add(ast.sjump(ast.raw('true'), info.start));
        }
        if ((info.max - info.min) == 4) {
            var di = this.decodeInstruction(info.min);
            var di2 = this.decodeInstruction(info.min + 4);
            if (di.type.name == 'jr' && di2.type.name == 'syscall') {
                return new FunctionCode("\n\t\t\t\t\t/* " + this.syscallManager.getName(di2.instruction.syscall) + " at " + addressToHex(info.start) + " */\n\t\t\t\t\tstate.PC = state.RA; state.jumpCall = null;\n\t\t\t\t\tstate.syscall(" + di2.instruction.syscall + ");\n\t\t\t\t\treturn;\n\t\t\t\t\t", args);
            }
        }
        for (var PC = info.min; PC <= info.max; PC += 4) {
            var di = this.decodeInstruction(PC);
            var type = di.type;
            var ins = this.generatePspInstruction(di);
            var delayedSlotInstruction;
            if (labels[PC])
                func.add(labels[PC]);
            if (type.name == 'syscall') {
                func.add(ast.raw("state.PC = " + (PC + 4) + ";"));
            }
            if (!type.hasDelayedBranch) {
                func.add(ins);
            }
            else {
                var di2 = this.decodeInstruction(PC + 4);
                var delayedSlotInstruction = this.generatePspInstruction(di2);
                var delayedCode = ast.stm(di.type.isLikely ? ast._if(ast.branchflag(), delayedSlotInstruction) : delayedSlotInstruction);
                var targetAddress = di.targetAddress & Memory.MASK;
                var nextAddress = (PC + 8) & Memory.MASK;
                var targetAddressHex = addressToHex(targetAddress);
                var nextAddressHex = addressToHex(nextAddress);
                if (type.name == 'jal' || type.name == 'j') {
                    var cachefuncName = "cache_" + addressToHex(targetAddress);
                    args[cachefuncName] = this.instructionCache.getFunction(targetAddress);
                    func.add(ast.raw("state.PC = " + targetAddressHex + ";"));
                    if (type.name == 'j') {
                        func.add(delayedCode);
                        if (labels[targetAddress]) {
                            func.add(ast.sjump(ast.raw('true'), targetAddress));
                        }
                        else {
                            func.add(ast.raw("state.jumpCall = args." + cachefuncName + ";"));
                            func.add(ast.raw("return;"));
                        }
                    }
                    else {
                        func.add(ast.raw("var expectedRA = state.RA = " + nextAddressHex + ";"));
                        func.add(delayedCode);
                        func.add(ast.raw("args." + cachefuncName + ".execute(state);"));
                        func.add(ast.raw("while ((state.PC != expectedRA) && (state.jumpCall != null)) state.jumpCall.execute(state);"));
                        func.add(ast.raw("if (state.PC != expectedRA) { state.jumpCall = null; return; }"));
                    }
                }
                else if (type.isJal) {
                    var cachefuncName = "cachefunc_" + addressToHex(PC);
                    args[cachefuncName] = null;
                    var cacheaddrName = "cacheaddr_" + addressToHex(PC);
                    args[cacheaddrName] = -1;
                    func.add(ins);
                    func.add(delayedCode);
                    func.add(ast.raw('if (BRANCHFLAG) {'));
                    func.add(ast.raw("state.PC = BRANCHPC & " + Memory.MASK + ";"));
                    func.add(ast.raw("var expectedRA = state.RA;"));
                    func.add(ast.raw("if (args." + cacheaddrName + " != state.PC) args." + cachefuncName + " = state.getFunction(args." + cacheaddrName + " = state.PC);"));
                    func.add(ast.raw("args." + cachefuncName + ".execute(state);"));
                    func.add(ast.raw("while ((state.PC != expectedRA) && (state.jumpCall != null)) state.jumpCall.execute(state);"));
                    func.add(ast.raw("if (state.PC != expectedRA) { state.jumpCall = null; return; }"));
                    func.add(ast.raw('}'));
                }
                else if (type.isJumpNoLink) {
                    if (type.name == 'jr') {
                        func.add(delayedCode);
                        func.add(ast.raw("state.PC = state.gpr[" + di.instruction.rs + "];"));
                        func.add(ast.raw('state.jumpCall = null;'));
                        func.add(ast.raw('return;'));
                    }
                    else {
                        func.add(ins);
                        func.add(delayedCode);
                        func.add(ast.raw('state.jumpCall = state.getFunction(state.PC = BRANCHPC);'));
                        func.add(ast.raw('return;'));
                    }
                }
                else {
                    func.add(ins);
                    func.add(delayedCode);
                    if (type.isFixedAddressJump && labels[targetAddress]) {
                        func.add(ast.sjump(ast.raw('BRANCHFLAG'), targetAddress));
                    }
                    else {
                        func.add(ast.raw("if (BRANCHFLAG) {"));
                        func.add(ast.raw("state.PC = " + targetAddressHex + ";"));
                        func.add(ast.raw('state.jumpCall = state.getFunction(state.PC);'));
                        func.add(ast.raw("return;"));
                        func.add(ast.raw("}"));
                    }
                }
                PC += 4;
            }
        }
        var code = func.toJs();
        args.code = code;
        return new FunctionCode(code, args);
    };
    return FunctionGenerator;
})();
exports.FunctionGenerator = FunctionGenerator;
function createNativeFunction(exportId, firmwareVersion, retval, argTypesString, _this, internalFunc, options) {
    var code = '';
    var V0 = "state.gpr[2]";
    var V1 = "state.gpr[3]";
    var args = [];
    var maxGprIndex = 12;
    var gprindex = 4;
    var fprindex = 0;
    function _readGpr32() {
        if (gprindex >= maxGprIndex) {
            return 'memory.lw(state.gpr[29] + ' + ((maxGprIndex - gprindex++) * 4) + ')';
        }
        else {
            return 'state.gpr[' + (gprindex++) + ']';
        }
    }
    function readFpr32() { return 'state.fpr[' + (fprindex++) + ']'; }
    function readGpr32_S() { return '(' + _readGpr32() + ' | 0)'; }
    function readGpr32_U() { return '(' + _readGpr32() + ' >>> 0)'; }
    function readGpr64() {
        gprindex = MathUtils.nextAligned(gprindex, 2);
        var gprLow = readGpr32_S();
        var gprHigh = readGpr32_S();
        return "Integer64.fromBits(" + gprLow + ", " + gprHigh + ")";
    }
    var argTypes = argTypesString.split('/').filter(function (item) { return item.length > 0; });
    if (argTypes.length != internalFunc.length)
        throw (new Error("Function arity mismatch '" + argTypesString + "' != " + String(internalFunc)));
    argTypes.forEach(function (item) {
        switch (item) {
            case 'EmulatorContext':
                args.push('context');
                break;
            case 'Thread':
                args.push('state.thread');
                break;
            case 'CpuState':
                args.push('state');
                break;
            case 'Memory':
                args.push('state.memory');
                break;
            case 'string':
                args.push('state.memory.readStringz(' + readGpr32_S() + ')');
                break;
            case 'uint':
                args.push(readGpr32_U() + ' >>> 0');
                break;
            case 'int':
                args.push(readGpr32_S() + ' | 0');
                break;
            case 'bool':
                args.push(readGpr32_S() + ' != 0');
                break;
            case 'float':
                args.push(readFpr32());
                break;
            case 'ulong':
            case 'long':
                args.push(readGpr64());
                break;
            case 'void*':
                args.push('state.memory.getPointerStream(' + readGpr32_S() + ')');
                break;
            case 'byte[]':
                args.push('state.memory.getPointerStream(' + readGpr32_S() + ', ' + readGpr32_S() + ')');
                break;
            default:
                var matches = [];
                if (matches = item.match(/^byte\[(\d+)\]$/)) {
                    args.push('state.memory.getPointerU8Array(' + readGpr32_S() + ', ' + matches[1] + ')');
                }
                else {
                    throw ('Invalid argument "' + item + '"');
                }
        }
    });
    code += 'var error = false;\n';
    if (DEBUG_NATIVEFUNC) {
        code += "console.info(nativeFunction.name);";
    }
    code += 'var result = internalFunc(' + args.join(', ') + ');\n';
    code += "\n\t\tif (result instanceof Promise2) {\n\t\t\t" + (DEBUG_NATIVEFUNC ? 'console.log("returned promise!");' : '') + "\n\t\t\tstate.thread.suspendUntilPromiseDone(result, nativeFunction);\n\t\t\tthrow new Error(\"CpuBreakException\");\n\t\t}\n\n\t";
    code += "\n\t\tif (result instanceof WaitingThreadInfo) {\n\t\t\t" + (DEBUG_NATIVEFUNC ? 'console.log("returned WaitingThreadInfo!");' : '') + "\n\t\t\tif (result.promise instanceof Promise2) {\n\t\t\t\tstate.thread.suspendUntilDone(result);\n\t\t\t\tthrow new Error(\"CpuBreakException\"); }\n\t\t\telse {\n\t\t\t\tresult = result.promise;\n\t\t\t}\n\t\t}\n\n\t";
    switch (retval) {
        case 'void': break;
        case 'uint':
        case 'int':
            code += V0 + " = result | 0;\n";
            break;
        case 'bool':
            code += V0 + " = result ? 1 : 0;\n";
            break;
        case 'float':
            code += 'state.fpr[0] = result;\n';
            break;
        case 'long':
            code += 'if (!error) {\n';
            code += 'if (!(result instanceof Integer64)) { logger.info("FUNC:", nativeFunction); throw(new Error("Invalid long result. Expecting Integer64 but found \'" + result + "\'.")); }\n';
            code += V0 + " = result.low; " + V1 + " = result.high;\n";
            code += '} else {\n';
            code += V0 + " = result; " + V1 + " = 0;\n";
            code += '}\n';
            break;
        default: throw ('Invalid return value "' + retval + '"');
    }
    var nativeFunction = new NativeFunction();
    nativeFunction.name = 'unknown';
    nativeFunction.nid = exportId;
    nativeFunction.firmwareVersion = firmwareVersion;
    if (DEBUG_FUNCGEN) {
        console.log(code);
    }
    nativeFunction.call = new Function('_this', 'logger', 'internalFunc', 'nativeFunction', "return function(context, state) { \"use strict\"; /* " + addressToHex(nativeFunction.nid) + " */\n" + code + " };")(_this, logger, internalFunc, nativeFunction);
    nativeFunction.nativeCall = internalFunc;
    return nativeFunction;
}
exports.createNativeFunction = createNativeFunction;

},
"src/core/cpu/cpu_instructions": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var IndentStringGenerator = require('../../util/IndentStringGenerator');
var ADDR_TYPE_NONE = 0;
var ADDR_TYPE_REG = 1;
var ADDR_TYPE_16 = 2;
var ADDR_TYPE_26 = 3;
var INSTR_TYPE_PSP = (1 << 0);
var INSTR_TYPE_SYSCALL = (1 << 1);
var INSTR_TYPE_B = (1 << 2);
var INSTR_TYPE_LIKELY = (1 << 3);
var INSTR_TYPE_JAL = (1 << 4);
var INSTR_TYPE_JUMP = (1 << 5);
var INSTR_TYPE_BREAK = (1 << 6);
function VM(format) {
    var counts = {
        "cstw": 1, "cstz": 1, "csty": 1, "cstx": 1,
        "absw": 1, "absz": 1, "absy": 1, "absx": 1,
        "mskw": 1, "mskz": 1, "msky": 1, "mskx": 1,
        "negw": 1, "negz": 1, "negy": 1, "negx": 1,
        "one": 1, "two": 1, "vt1": 1,
        "vt2": 2,
        "satw": 2, "satz": 2, "saty": 2, "satx": 2,
        "swzw": 2, "swzz": 2, "swzy": 2, "swzx": 2,
        "imm3": 3,
        "imm4": 4,
        "fcond": 4,
        "c0dr": 5, "c0cr": 5, "c1dr": 5, "c1cr": 5, "imm5": 5, "vt5": 5,
        "rs": 5, "rd": 5, "rt": 5, "sa": 5, "lsb": 5, "msb": 5, "fs": 5, "fd": 5, "ft": 5,
        "vs": 7, "vt": 7, "vd": 7, "imm7": 7,
        "imm8": 8,
        "imm14": 14,
        "imm16": 16,
        "imm20": 20,
        "imm26": 26
    };
    var value = 0;
    var mask = 0;
    format.split(':').forEach(function (item) {
        if (/^[01\-]+$/.test(item)) {
            for (var n = 0; n < item.length; n++) {
                value <<= 1;
                mask <<= 1;
                if (item[n] == '0') {
                    value |= 0;
                    mask |= 1;
                }
                if (item[n] == '1') {
                    value |= 1;
                    mask |= 1;
                }
                if (item[n] == '-') {
                    value |= 0;
                    mask |= 0;
                }
            }
        }
        else {
            var displacement = counts[item];
            if (displacement === undefined)
                throw ("Invalid item '" + item + "'");
            value <<= displacement;
            mask <<= displacement;
        }
    });
    return { value: value, mask: mask };
}
var InstructionType = (function () {
    function InstructionType(name, vm, format, addressType, instructionType) {
        this.name = name;
        this.vm = vm;
        this.format = format;
        this.addressType = addressType;
        this.instructionType = instructionType;
    }
    InstructionType.prototype.match = function (i32) { return (i32 & this.vm.mask) == (this.vm.value & this.vm.mask); };
    InstructionType.prototype.isInstructionType = function (mask) { return (this.instructionType & mask) != 0; };
    Object.defineProperty(InstructionType.prototype, "isSyscall", {
        get: function () { return this.isInstructionType(INSTR_TYPE_SYSCALL); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstructionType.prototype, "isBreak", {
        get: function () { return this.isInstructionType(INSTR_TYPE_BREAK); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstructionType.prototype, "isBranch", {
        get: function () { return this.isInstructionType(INSTR_TYPE_B); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstructionType.prototype, "isCall", {
        get: function () { return this.isInstructionType(INSTR_TYPE_JAL); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstructionType.prototype, "isJump", {
        get: function () { return this.isInstructionType(INSTR_TYPE_JAL) || this.isInstructionType(INSTR_TYPE_JUMP); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstructionType.prototype, "isJumpNoLink", {
        get: function () { return this.isInstructionType(INSTR_TYPE_JUMP); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstructionType.prototype, "isJal", {
        get: function () { return this.isInstructionType(INSTR_TYPE_JAL); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstructionType.prototype, "isJumpOrBranch", {
        get: function () { return this.isBranch || this.isJump; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstructionType.prototype, "isLikely", {
        get: function () { return this.isInstructionType(INSTR_TYPE_LIKELY); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstructionType.prototype, "isRegister", {
        get: function () { return this.addressType == ADDR_TYPE_REG; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstructionType.prototype, "isFixedAddressJump", {
        get: function () { return this.isJumpOrBranch && !this.isRegister; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstructionType.prototype, "hasDelayedBranch", {
        get: function () { return this.isJumpOrBranch; },
        enumerable: true,
        configurable: true
    });
    InstructionType.prototype.toString = function () { return "InstructionType('" + this.name + "', " + addressToHex(this.vm.value) + ", " + addressToHex(this.vm.mask) + ")"; };
    return InstructionType;
})();
exports.InstructionType = InstructionType;
var Instructions = (function () {
    function Instructions() {
        var _this = this;
        this.instructionTypeListByName = {};
        this.instructionTypeList = [];
        var ID = function (name, vm, format, addressType, instructionType) { _this.add(name, vm, format, addressType, instructionType); };
        ID("add", VM("000000:rs:rt:rd:00000:100000"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("addu", VM("000000:rs:rt:rd:00000:100001"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("addi", VM("001000:rs:rt:imm16"), "%t, %s, %i", ADDR_TYPE_NONE, 0);
        ID("addiu", VM("001001:rs:rt:imm16"), "%t, %s, %i", ADDR_TYPE_NONE, 0);
        ID("sub", VM("000000:rs:rt:rd:00000:100010"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("subu", VM("000000:rs:rt:rd:00000:100011"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("and", VM("000000:rs:rt:rd:00000:100100"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("andi", VM("001100:rs:rt:imm16"), "%t, %s, %I", ADDR_TYPE_NONE, 0);
        ID("nor", VM("000000:rs:rt:rd:00000:100111"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("or", VM("000000:rs:rt:rd:00000:100101"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("ori", VM("001101:rs:rt:imm16"), "%t, %s, %I", ADDR_TYPE_NONE, 0);
        ID("xor", VM("000000:rs:rt:rd:00000:100110"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("xori", VM("001110:rs:rt:imm16"), "%t, %s, %I", ADDR_TYPE_NONE, 0);
        ID("sll", VM("000000:00000:rt:rd:sa:000000"), "%d, %t, %a", ADDR_TYPE_NONE, 0);
        ID("sllv", VM("000000:rs:rt:rd:00000:000100"), "%d, %t, %s", ADDR_TYPE_NONE, 0);
        ID("sra", VM("000000:00000:rt:rd:sa:000011"), "%d, %t, %a", ADDR_TYPE_NONE, 0);
        ID("srav", VM("000000:rs:rt:rd:00000:000111"), "%d, %t, %s", ADDR_TYPE_NONE, 0);
        ID("srl", VM("000000:00000:rt:rd:sa:000010"), "%d, %t, %a", ADDR_TYPE_NONE, 0);
        ID("srlv", VM("000000:rs:rt:rd:00000:000110"), "%d, %t, %s", ADDR_TYPE_NONE, 0);
        ID("rotr", VM("000000:00001:rt:rd:sa:000010"), "%d, %t, %a", ADDR_TYPE_NONE, 0);
        ID("rotrv", VM("000000:rs:rt:rd:00001:000110"), "%d, %t, %s", ADDR_TYPE_NONE, 0);
        ID("slt", VM("000000:rs:rt:rd:00000:101010"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("slti", VM("001010:rs:rt:imm16"), "%t, %s, %i", ADDR_TYPE_NONE, 0);
        ID("sltu", VM("000000:rs:rt:rd:00000:101011"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("sltiu", VM("001011:rs:rt:imm16"), "%t, %s, %i", ADDR_TYPE_NONE, 0);
        ID("lui", VM("001111:00000:rt:imm16"), "%t, %I", ADDR_TYPE_NONE, 0);
        ID("seb", VM("011111:00000:rt:rd:10000:100000"), "%d, %t", ADDR_TYPE_NONE, 0);
        ID("seh", VM("011111:00000:rt:rd:11000:100000"), "%d, %t", ADDR_TYPE_NONE, 0);
        ID("bitrev", VM("011111:00000:rt:rd:10100:100000"), "%d, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("max", VM("000000:rs:rt:rd:00000:101100"), "%d, %s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("min", VM("000000:rs:rt:rd:00000:101101"), "%d, %s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("div", VM("000000:rs:rt:00000:00000:011010"), "%s, %t", ADDR_TYPE_NONE, 0);
        ID("divu", VM("000000:rs:rt:00000:00000:011011"), "%s, %t", ADDR_TYPE_NONE, 0);
        ID("mult", VM("000000:rs:rt:00000:00000:011000"), "%s, %t", ADDR_TYPE_NONE, 0);
        ID("multu", VM("000000:rs:rt:00000:00000:011001"), "%s, %t", ADDR_TYPE_NONE, 0);
        ID("madd", VM("000000:rs:rt:00000:00000:011100"), "%s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("maddu", VM("000000:rs:rt:00000:00000:011101"), "%s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("msub", VM("000000:rs:rt:00000:00000:101110"), "%s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("msubu", VM("000000:rs:rt:00000:00000:101111"), "%s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("mfhi", VM("000000:00000:00000:rd:00000:010000"), "%d", ADDR_TYPE_NONE, 0);
        ID("mflo", VM("000000:00000:00000:rd:00000:010010"), "%d", ADDR_TYPE_NONE, 0);
        ID("mthi", VM("000000:rs:00000:00000:00000:010001"), "%s", ADDR_TYPE_NONE, 0);
        ID("mtlo", VM("000000:rs:00000:00000:00000:010011"), "%s", ADDR_TYPE_NONE, 0);
        ID("movz", VM("000000:rs:rt:rd:00000:001010"), "%d, %s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("movn", VM("000000:rs:rt:rd:00000:001011"), "%d, %s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("ext", VM("011111:rs:rt:msb:lsb:000000"), "%t, %s, %a, %ne", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("ins", VM("011111:rs:rt:msb:lsb:000100"), "%t, %s, %a, %ni", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("clz", VM("000000:rs:00000:rd:00000:010110"), "%d, %s", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("clo", VM("000000:rs:00000:rd:00000:010111"), "%d, %s", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("wsbh", VM("011111:00000:rt:rd:00010:100000"), "%d, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("wsbw", VM("011111:00000:rt:rd:00011:100000"), "%d, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("beq", VM("000100:rs:rt:imm16"), "%s, %t, %O", ADDR_TYPE_16, INSTR_TYPE_B);
        ID("beql", VM("010100:rs:rt:imm16"), "%s, %t, %O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
        ID("bgez", VM("000001:rs:00001:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B);
        ID("bgezl", VM("000001:rs:00011:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
        ID("bgezal", VM("000001:rs:10001:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_JAL);
        ID("bgezall", VM("000001:rs:10011:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_JAL | INSTR_TYPE_LIKELY);
        ID("bltz", VM("000001:rs:00000:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B);
        ID("bltzl", VM("000001:rs:00010:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
        ID("bltzal", VM("000001:rs:10000:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_JAL);
        ID("bltzall", VM("000001:rs:10010:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_JAL | INSTR_TYPE_LIKELY);
        ID("blez", VM("000110:rs:00000:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B);
        ID("blezl", VM("010110:rs:00000:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
        ID("bgtz", VM("000111:rs:00000:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B);
        ID("bgtzl", VM("010111:rs:00000:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
        ID("bne", VM("000101:rs:rt:imm16"), "%s, %t, %O", ADDR_TYPE_16, INSTR_TYPE_B);
        ID("bnel", VM("010101:rs:rt:imm16"), "%s, %t, %O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
        ID("j", VM("000010:imm26"), "%j", ADDR_TYPE_26, INSTR_TYPE_JUMP);
        ID("jr", VM("000000:rs:00000:00000:00000:001000"), "%J", ADDR_TYPE_REG, INSTR_TYPE_JUMP);
        ID("jalr", VM("000000:rs:00000:rd:00000:001001"), "%J, %d", ADDR_TYPE_REG, INSTR_TYPE_JAL);
        ID("jal", VM("000011:imm26"), "%j", ADDR_TYPE_26, INSTR_TYPE_JAL);
        ID("bc1f", VM("010001:01000:00000:imm16"), "%O", ADDR_TYPE_16, INSTR_TYPE_B);
        ID("bc1t", VM("010001:01000:00001:imm16"), "%O", ADDR_TYPE_16, INSTR_TYPE_B);
        ID("bc1fl", VM("010001:01000:00010:imm16"), "%O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
        ID("bc1tl", VM("010001:01000:00011:imm16"), "%O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
        ID("lb", VM("100000:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("lh", VM("100001:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("lw", VM("100011:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("lwl", VM("100010:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("lwr", VM("100110:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("lbu", VM("100100:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("lhu", VM("100101:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("sb", VM("101000:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("sh", VM("101001:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("sw", VM("101011:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("swl", VM("101010:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("swr", VM("101110:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("ll", VM("110000:rs:rt:imm16"), "%t, %O", ADDR_TYPE_NONE, 0);
        ID("sc", VM("111000:rs:rt:imm16"), "%t, %O", ADDR_TYPE_NONE, 0);
        ID("lwc1", VM("110001:rs:ft:imm16"), "%T, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("swc1", VM("111001:rs:ft:imm16"), "%T, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("add.s", VM("010001:10000:ft:fs:fd:000000"), "%D, %S, %T", ADDR_TYPE_NONE, 0);
        ID("sub.s", VM("010001:10000:ft:fs:fd:000001"), "%D, %S, %T", ADDR_TYPE_NONE, 0);
        ID("mul.s", VM("010001:10000:ft:fs:fd:000010"), "%D, %S, %T", ADDR_TYPE_NONE, 0);
        ID("div.s", VM("010001:10000:ft:fs:fd:000011"), "%D, %S, %T", ADDR_TYPE_NONE, 0);
        ID("sqrt.s", VM("010001:10000:00000:fs:fd:000100"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("abs.s", VM("010001:10000:00000:fs:fd:000101"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("mov.s", VM("010001:10000:00000:fs:fd:000110"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("neg.s", VM("010001:10000:00000:fs:fd:000111"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("round.w.s", VM("010001:10000:00000:fs:fd:001100"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("trunc.w.s", VM("010001:10000:00000:fs:fd:001101"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("ceil.w.s", VM("010001:10000:00000:fs:fd:001110"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("floor.w.s", VM("010001:10000:00000:fs:fd:001111"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("cvt.s.w", VM("010001:10100:00000:fs:fd:100000"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("cvt.w.s", VM("010001:10000:00000:fs:fd:100100"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("mfc1", VM("010001:00000:rt:c1dr:00000:000000"), "%t, %S", ADDR_TYPE_NONE, 0);
        ID("mtc1", VM("010001:00100:rt:c1dr:00000:000000"), "%t, %S", ADDR_TYPE_NONE, 0);
        ID("cfc1", VM("010001:00010:rt:c1cr:00000:000000"), "%t, %p", ADDR_TYPE_NONE, 0);
        ID("ctc1", VM("010001:00110:rt:c1cr:00000:000000"), "%t, %p", ADDR_TYPE_NONE, 0);
        ID("c.f.s", VM("010001:10000:ft:fs:00000:11:0000"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.un.s", VM("010001:10000:ft:fs:00000:11:0001"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.eq.s", VM("010001:10000:ft:fs:00000:11:0010"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.ueq.s", VM("010001:10000:ft:fs:00000:11:0011"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.olt.s", VM("010001:10000:ft:fs:00000:11:0100"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.ult.s", VM("010001:10000:ft:fs:00000:11:0101"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.ole.s", VM("010001:10000:ft:fs:00000:11:0110"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.ule.s", VM("010001:10000:ft:fs:00000:11:0111"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.sf.s", VM("010001:10000:ft:fs:00000:11:1000"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.ngle.s", VM("010001:10000:ft:fs:00000:11:1001"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.seq.s", VM("010001:10000:ft:fs:00000:11:1010"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.ngl.s", VM("010001:10000:ft:fs:00000:11:1011"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.lt.s", VM("010001:10000:ft:fs:00000:11:1100"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.nge.s", VM("010001:10000:ft:fs:00000:11:1101"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.le.s", VM("010001:10000:ft:fs:00000:11:1110"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.ngt.s", VM("010001:10000:ft:fs:00000:11:1111"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("syscall", VM("000000:imm20:001100"), "%C", ADDR_TYPE_NONE, INSTR_TYPE_SYSCALL);
        ID("cache", VM("101111:rs:-----:imm16"), "%k, %o", ADDR_TYPE_NONE, 0);
        ID("sync", VM("000000:00000:00000:00000:00000:001111"), "", ADDR_TYPE_NONE, 0);
        ID("break", VM("000000:imm20:001101"), "%c", ADDR_TYPE_NONE, INSTR_TYPE_BREAK);
        ID("dbreak", VM("011100:00000:00000:00000:00000:111111"), "", ADDR_TYPE_NONE, INSTR_TYPE_PSP | INSTR_TYPE_BREAK);
        ID("halt", VM("011100:00000:00000:00000:00000:000000"), "", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("dret", VM("011100:00000:00000:00000:00000:111110"), "", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("eret", VM("010000:10000:00000:00000:00000:011000"), "", ADDR_TYPE_NONE, 0);
        ID("mfic", VM("011100:rt:00000:00000:00000:100100"), "%t, %p", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("mtic", VM("011100:rt:00000:00000:00000:100110"), "%t, %p", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("mfdr", VM("011100:00000:----------:00000:111101"), "%t, %r", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("mtdr", VM("011100:00100:----------:00000:111101"), "%t, %r", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("cfc0", VM("010000:00010:----------:00000:000000"), "%t, %p", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("ctc0", VM("010000:00110:----------:00000:000000"), "%t, %p", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("mfc0", VM("010000:00000:----------:00000:000000"), "%t, %0", ADDR_TYPE_NONE, 0);
        ID("mtc0", VM("010000:00100:----------:00000:000000"), "%t, %0", ADDR_TYPE_NONE, 0);
        ID("mfv", VM("010010:00:011:rt:0:0000000:0:vd"), "%t, %zs", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("mfvc", VM("010010:00:011:rt:0:0000000:1:vd"), "%t, %2d", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("mtv", VM("010010:00:111:rt:0:0000000:0:vd"), "%t, %zs", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("mtvc", VM("010010:00:111:rt:0:0000000:1:vd"), "%t, %2d", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("lv.s", VM("110010:rs:vt5:imm14:vt2"), "%Xs, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("lv.q", VM("110110:rs:vt5:imm14:0:vt1"), "%Xq, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("lvl.q", VM("110101:rs:vt5:imm14:0:vt1"), "%Xq, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("lvr.q", VM("110101:rs:vt5:imm14:1:vt1"), "%Xq, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("sv.q", VM("111110:rs:vt5:imm14:0:vt1"), "%Xq, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vdot", VM("011001:001:vt:two:vs:one:vd"), "%zs, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vscl", VM("011001:010:vt:two:vs:one:vd"), "%zp, %yp, %xs", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsge", VM("011011:110:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vslt", VM("011011:111:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vrot", VM("111100:111:01:imm5:two:vs:one:vd"), "%zp, %ys, %vr", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vzero", VM("110100:00:000:0:0110:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vone", VM("110100:00:000:0:0111:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmov", VM("110100:00:000:0:0000:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vabs", VM("110100:00:000:0:0001:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vneg", VM("110100:00:000:0:0010:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vocp", VM("110100:00:010:0:0100:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsgn", VM("110100:00:010:0:1010:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vrcp", VM("110100:00:000:1:0000:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vrsq", VM("110100:00:000:1:0001:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsin", VM("110100:00:000:1:0010:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vcos", VM("110100:00:000:1:0011:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vexp2", VM("110100:00:000:1:0100:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vlog2", VM("110100:00:000:1:0101:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsqrt", VM("110100:00:000:1:0110:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vasin", VM("110100:00:000:1:0111:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vnrcp", VM("110100:00:000:1:1000:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vnsin", VM("110100:00:000:1:1010:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vrexp2", VM("110100:00:000:1:1100:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsat0", VM("110100:00:000:0:0100:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsat1", VM("110100:00:000:0:0101:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vcst", VM("110100:00:011:imm5:two:0000000:one:vd"), "%zp, %vk", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmmul", VM("111100:000:vt:two:vs:one:vd"), "%zm, %tym, %xm", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vhdp", VM("011001:100:vt:two:vs:one:vd"), "%zs, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vcrs.t", VM("011001:101:vt:1:vs:0:vd"), "%zt, %yt, %xt", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vcrsp.t", VM("111100:101:vt:1:vs:0:vd"), "%zt, %yt, %xt", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vi2c", VM("110100:00:001:11:101:two:vs:one:vd"), "%zs, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vi2uc", VM("110100:00:001:11:100:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vtfm2", VM("111100:001:vt:0:vs:1:vd"), "%zp, %ym, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vtfm3", VM("111100:010:vt:1:vs:0:vd"), "%zt, %yn, %xt", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vtfm4", VM("111100:011:vt:1:vs:1:vd"), "%zq, %yo, %xq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vhtfm2", VM("111100:001:vt:0:vs:0:vd"), "%zp, %ym, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vhtfm3", VM("111100:010:vt:0:vs:1:vd"), "%zt, %yn, %xt", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vhtfm4", VM("111100:011:vt:1:vs:0:vd"), "%zq, %yo, %xq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsrt3", VM("110100:00:010:01000:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vfad", VM("110100:00:010:00110:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmin", VM("011011:010:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmax", VM("011011:011:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vadd", VM("011000:000:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsub", VM("011000:001:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vdiv", VM("011000:111:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmul", VM("011001:000:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vidt", VM("110100:00:000:0:0011:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmidt", VM("111100:111:00:00011:two:0000000:one:vd"), "%zm", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("viim", VM("110111:11:0:vd:imm16"), "%xs, %vi", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmmov", VM("111100:111:00:00000:two:vs:one:vd"), "%zm, %ym", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmzero", VM("111100:111:00:00110:two:0000000:one:vd"), "%zm", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmone", VM("111100:111:00:00111:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vnop", VM("111111:1111111111:00000:00000000000"), "", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsync", VM("111111:1111111111:00000:01100100000"), "", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vflush", VM("111111:1111111111:00000:10000001101"), "", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vpfxd", VM("110111:10:------------:mskw:mskz:msky:mskx:satw:satz:saty:satx"), "[%vp4, %vp5, %vp6, %vp7]", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vpfxs", VM("110111:00:----:negw:negz:negy:negx:cstw:cstz:csty:cstx:absw:absz:absy:absx:swzw:swzz:swzy:swzx"), "[%vp0, %vp1, %vp2, %vp3]", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vpfxt", VM("110111:01:----:negw:negz:negy:negx:cstw:cstz:csty:cstx:absw:absz:absy:absx:swzw:swzz:swzy:swzx"), "[%vp0, %vp1, %vp2, %vp3]", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vdet", VM("011001:110:vt:two:vs:one:vd"), "%zs, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vrnds", VM("110100:00:001:00:000:two:vs:one:0000000"), "%ys", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vrndi", VM("110100:00:001:00:001:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vrndf1", VM("110100:00:001:00:010:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vrndf2", VM("110100:00:001:00:011:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vcmp", VM("011011:000:vt:two:vs:one:000:imm4"), "%Zn, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vcmovf", VM("110100:10:101:01:imm3:two:vs:one:vd"), "%zp, %yp, %v3", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vcmovt", VM("110100:10:101:00:imm3:two:vs:one:vd"), "%zp, %yp, %v3", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vavg", VM("110100:00:010:00111:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vf2id", VM("110100:10:011:imm5:two:vs:one:vd"), "%zp, %yp, %v5", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vf2in", VM("110100:10:000:imm5:two:vs:one:vd"), "%zp, %yp, %v5", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vf2iu", VM("110100:10:010:imm5:two:vs:one:vd"), "%zp, %yp, %v5", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vf2iz", VM("110100:10:001:imm5:two:vs:one:vd"), "%zp, %yp, %v5", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vi2f", VM("110100:10:100:imm5:two:vs:one:vd"), "%zp, %yp, %v5", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vscmp", VM("011011:101:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmscl", VM("111100:100:vt:two:vs:one:vd"), "%zm, %ym, %xs", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vt4444.q", VM("110100:00:010:11001:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vt5551.q", VM("110100:00:010:11010:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vt5650.q", VM("110100:00:010:11011:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmfvc", VM("110100:00:010:10000:1:imm7:0:vd"), "%zs, %2s", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmtvc", VM("110100:00:010:10001:0:vs:1:imm7"), "%2d, %ys", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("mfvme", VM("011010--------------------------"), "%t, %i", ADDR_TYPE_NONE, 0);
        ID("mtvme", VM("101100--------------------------"), "%t, %i", ADDR_TYPE_NONE, 0);
        ID("sv.s", VM("111010:rs:vt5:imm14:vt2"), "%Xs, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vfim", VM("110111:11:1:vt:imm16"), "%xs, %vh", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("svl.q", VM("111101:rs:vt5:imm14:0:vt1"), "%Xq, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("svr.q", VM("111101:rs:vt5:imm14:1:vt1"), "%Xq, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vbfy1", VM("110100:00:010:00010:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vbfy2", VM("110100:00:010:00011:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vf2h", VM("110100:00:001:10:010:two:vs:one:vd"), "%zs, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vh2f", VM("110100:00:001:10:011:two:vs:one:vd"), "%zq, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vi2s", VM("110100:00:001:11:111:two:vs:one:vd"), "%zs, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vi2us", VM("110100:00:001:11:110:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vlgb", VM("110100:00:001:10:111:two:vs:one:vd"), "%zs, %ys", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vqmul", VM("111100:101:vt:1:vs:1:vd"), "%zq, %yq, %xq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vs2i", VM("110100:00:001:11:011:two:vs:one:vd"), "%zq, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vc2i", VM("110100:00:001:11:001:two:vs:one:vd"), "%zs, %ys, %xs", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vuc2i", VM("110100:00:001:11:000:two:vs:one:vd"), "%zq, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsbn", VM("011000:010:vt:two:vs:one:vd"), "%zs, %ys, %xs", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsbz", VM("110100:00:001:10110:two:vs:one:vd"), "%zs, %ys", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsocp", VM("110100:00:010:00101:two:vs:one:vd"), "%zq, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsrt1", VM("110100:00:010:00000:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsrt2", VM("110100:00:010:00001:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsrt4", VM("110100:00:010:01001:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vus2i", VM("110100:00:001:11010:two:vs:one:vd"), "%zq, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vwbn", VM("110100:11:imm8:two:vs:one:vd"), "%zs, %xs, %I", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("bvf", VM("010010:01:000:imm3:00:imm16"), "%Zc, %O", ADDR_TYPE_16, INSTR_TYPE_PSP | INSTR_TYPE_B);
        ID("bvt", VM("010010:01:000:imm3:01:imm16"), "%Zc, %O", ADDR_TYPE_16, INSTR_TYPE_PSP | INSTR_TYPE_B);
        ID("bvfl", VM("010010:01:000:imm3:10:imm16"), "%Zc, %O", ADDR_TYPE_16, INSTR_TYPE_PSP | INSTR_TYPE_B | INSTR_TYPE_LIKELY);
        ID("bvtl", VM("010010:01:000:imm3:11:imm16"), "%Zc, %O", ADDR_TYPE_16, INSTR_TYPE_PSP | INSTR_TYPE_B | INSTR_TYPE_LIKELY);
    }
    Object.defineProperty(Instructions, "instance", {
        get: function () {
            if (!Instructions._instance)
                Instructions._instance = new Instructions();
            return Instructions._instance;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instructions.prototype, "instructions", {
        get: function () { return this.instructionTypeList.slice(0); },
        enumerable: true,
        configurable: true
    });
    Instructions.prototype.add = function (name, vm, format, addressType, instructionType) {
        var it = new InstructionType(name, vm, format, addressType, instructionType);
        this.instructionTypeListByName[name] = it;
        this.instructionTypeList.push(it);
    };
    Instructions.prototype.findByName = function (name) {
        var instructionType = this.instructionTypeListByName[name];
        if (!instructionType)
            throw ("Cannot find instruction " + sprintf("%s", name));
        return instructionType;
    };
    Instructions.prototype.findByData = function (i32, pc) {
        if (pc === void 0) { pc = 0; }
        return this.fastFindByData(i32, pc);
    };
    Instructions.prototype.fastFindByData = function (i32, pc) {
        if (pc === void 0) { pc = 0; }
        if (!this.decoder) {
            var switchCode = DecodingTable.createSwitch(this.instructionTypeList);
            this.decoder = (new Function('instructionsByName', 'value', 'pc', '"use strict";' + switchCode));
        }
        return this.decoder(this.instructionTypeListByName, i32, pc);
    };
    Instructions.prototype.slowFindByData = function (i32, pc) {
        if (pc === void 0) { pc = 0; }
        for (var n = 0; n < this.instructionTypeList.length; n++) {
            var instructionType = this.instructionTypeList[n];
            if (instructionType.match(i32))
                return instructionType;
        }
        throw (sprintf("Cannot find instruction 0x%08X at 0x%08X", i32, pc));
    };
    return Instructions;
})();
exports.Instructions = Instructions;
var DecodingTable = (function () {
    function DecodingTable() {
        this.lastId = 0;
    }
    DecodingTable.prototype.getCommonMask = function (instructions, baseMask) {
        if (baseMask === void 0) { baseMask = 0xFFFFFFFF; }
        return instructions.reduce(function (left, item) { return left & item.vm.mask; }, baseMask);
    };
    DecodingTable.createSwitch = function (instructions) {
        var writer = new IndentStringGenerator();
        var decodingTable = new DecodingTable();
        decodingTable._createSwitch(writer, instructions);
        return writer.output;
    };
    DecodingTable.prototype._createSwitch = function (writer, instructions, baseMask, level) {
        var _this = this;
        if (baseMask === void 0) { baseMask = 0xFFFFFFFF; }
        if (level === void 0) { level = 0; }
        if (level >= 10)
            throw ('ERROR: Recursive detection');
        var commonMask = this.getCommonMask(instructions, baseMask);
        var groups = {};
        instructions.forEach(function (item) {
            var commonValue = item.vm.value & commonMask;
            if (!groups[commonValue])
                groups[commonValue] = [];
            groups[commonValue].push(item);
        });
        writer.write('switch ((value & ' + sprintf('0x%08X', commonMask) + ') >>> 0) {\n');
        writer.indent(function () {
            for (var groupKey in groups) {
                var group = groups[groupKey];
                writer.write('case ' + sprintf('0x%08X', groupKey) + ':');
                writer.indent(function () {
                    if (group.length == 1) {
                        writer.write(' return instructionsByName[' + JSON.stringify(group[0].name) + '];');
                    }
                    else {
                        writer.write('\n');
                        _this._createSwitch(writer, group, ~commonMask, level + 1);
                        writer.write('break;\n');
                    }
                });
            }
            writer.write('default: throw(sprintf("Invalid instruction 0x%08X at 0x%08X (' + _this.lastId++ + ') failed mask 0x%08X", value, pc, ' + commonMask + '));\n');
        });
        writer.write('}\n');
    };
    return DecodingTable;
})();
var Instruction = (function () {
    function Instruction(PC, data) {
        this.PC = PC;
        this.data = data;
    }
    Instruction.fromMemoryAndPC = function (memory, PC) { return new Instruction(PC, memory.readInt32(PC)); };
    Instruction.prototype.extract = function (offset, length) { return BitUtils.extract(this.data, offset, length); };
    Instruction.prototype.extract_s = function (offset, length) { return BitUtils.extractSigned(this.data, offset, length); };
    Instruction.prototype.insert = function (offset, length, value) { this.data = BitUtils.insert(this.data, offset, length, value); };
    Object.defineProperty(Instruction.prototype, "rd", {
        get: function () { return this.extract(11 + 5 * 0, 5); },
        set: function (value) { this.insert(11 + 5 * 0, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "rt", {
        get: function () { return this.extract(11 + 5 * 1, 5); },
        set: function (value) { this.insert(11 + 5 * 1, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "rs", {
        get: function () { return this.extract(11 + 5 * 2, 5); },
        set: function (value) { this.insert(11 + 5 * 2, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "fd", {
        get: function () { return this.extract(6 + 5 * 0, 5); },
        set: function (value) { this.insert(6 + 5 * 0, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "fs", {
        get: function () { return this.extract(6 + 5 * 1, 5); },
        set: function (value) { this.insert(6 + 5 * 1, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "ft", {
        get: function () { return this.extract(6 + 5 * 2, 5); },
        set: function (value) { this.insert(6 + 5 * 2, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "VD", {
        get: function () { return this.extract(0, 7); },
        set: function (value) { this.insert(0, 7, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "VS", {
        get: function () { return this.extract(8, 7); },
        set: function (value) { this.insert(8, 7, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "VT", {
        get: function () { return this.extract(16, 7); },
        set: function (value) { this.insert(16, 7, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "VT5_1", {
        get: function () { return this.VT5 | (this.VT1 << 5); },
        set: function (value) { this.VT5 = value; this.VT1 = (value >>> 5); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "IMM14", {
        get: function () { return this.extract_s(2, 14); },
        set: function (value) { this.insert(2, 14, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "ONE", {
        get: function () { return this.extract(7, 1); },
        set: function (value) { this.insert(7, 1, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "TWO", {
        get: function () { return this.extract(15, 1); },
        set: function (value) { this.insert(15, 1, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "ONE_TWO", {
        get: function () { return (1 + 1 * this.ONE + 2 * this.TWO); },
        set: function (value) { this.ONE = (((value - 1) >>> 0) & 1); this.TWO = (((value - 1) >>> 1) & 1); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "IMM8", {
        get: function () { return this.extract(16, 8); },
        set: function (value) { this.insert(16, 8, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "IMM5", {
        get: function () { return this.extract(16, 5); },
        set: function (value) { this.insert(16, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "IMM3", {
        get: function () { return this.extract(18, 3); },
        set: function (value) { this.insert(18, 3, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "IMM7", {
        get: function () { return this.extract(0, 7); },
        set: function (value) { this.insert(0, 7, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "IMM4", {
        get: function () { return this.extract(0, 4); },
        set: function (value) { this.insert(0, 4, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "VT1", {
        get: function () { return this.extract(0, 1); },
        set: function (value) { this.insert(0, 1, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "VT2", {
        get: function () { return this.extract(0, 2); },
        set: function (value) { this.insert(0, 2, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "VT5", {
        get: function () { return this.extract(16, 5); },
        set: function (value) { this.insert(16, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "VT5_2", {
        get: function () { return this.VT5 | (this.VT2 << 5); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "IMM_HF", {
        get: function () { return HalfFloat.toFloat(this.imm16); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "pos", {
        get: function () { return this.lsb; },
        set: function (value) { this.lsb = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "size_e", {
        get: function () { return this.msb + 1; },
        set: function (value) { this.msb = value - 1; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "size_i", {
        get: function () { return this.msb - this.lsb + 1; },
        set: function (value) { this.msb = this.lsb + value - 1; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "lsb", {
        get: function () { return this.extract(6 + 5 * 0, 5); },
        set: function (value) { this.insert(6 + 5 * 0, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "msb", {
        get: function () { return this.extract(6 + 5 * 1, 5); },
        set: function (value) { this.insert(6 + 5 * 1, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "c1cr", {
        get: function () { return this.extract(6 + 5 * 1, 5); },
        set: function (value) { this.insert(6 + 5 * 1, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "syscall", {
        get: function () { return this.extract(6, 20); },
        set: function (value) { this.insert(6, 20, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "imm16", {
        get: function () { var res = this.u_imm16; if (res & 0x8000)
            res |= 0xFFFF0000; return res; },
        set: function (value) { this.insert(0, 16, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "u_imm16", {
        get: function () { return this.extract(0, 16); },
        set: function (value) { this.insert(0, 16, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "u_imm26", {
        get: function () { return this.extract(0, 26); },
        set: function (value) { this.insert(0, 26, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "jump_bits", {
        get: function () { return this.extract(0, 26); },
        set: function (value) { this.insert(0, 26, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "jump_real", {
        get: function () { return (this.jump_bits * 4) >>> 0; },
        set: function (value) { this.jump_bits = (value / 4) >>> 0; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "branch_address", {
        get: function () { return this.PC + this.imm16 * 4 + 4; },
        set: function (value) { this.imm16 = (value - this.PC - 4) / 4; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "jump_address", {
        get: function () { return this.u_imm26 * 4; },
        set: function (value) { this.u_imm26 = value / 4; },
        enumerable: true,
        configurable: true
    });
    return Instruction;
})();
exports.Instruction = Instruction;
var DecodedInstruction = (function () {
    function DecodedInstruction(instruction, type) {
        this.instruction = instruction;
        this.type = type;
    }
    Object.defineProperty(DecodedInstruction.prototype, "PC", {
        get: function () { return this.instruction.PC; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DecodedInstruction.prototype, "isUnconditional", {
        get: function () {
            switch (this.type.name) {
                case 'j':
                case 'b': return true;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DecodedInstruction.prototype, "isUnconditionalFixedJump", {
        get: function () {
            return this.type.name == 'j';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DecodedInstruction.prototype, "targetAddress", {
        get: function () {
            if (this.type.isRegister)
                return this.PC;
            if (this.type.isBranch)
                return this.instruction.branch_address;
            if (this.type.isJump)
                return this.instruction.jump_address;
            return this.PC + 4;
        },
        enumerable: true,
        configurable: true
    });
    return DecodedInstruction;
})();
exports.DecodedInstruction = DecodedInstruction;

},
"src/core/cpu/executor": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var ProgramExecutor = (function () {
    function ProgramExecutor(state, instructionCache) {
        this.state = state;
        this.instructionCache = instructionCache;
        this.lastPC = 0;
        this.lastTime = 0;
        this.times = 0;
        this.state.executor = this;
    }
    ProgramExecutor.prototype._executeStep = function () {
        if (this.state.PC == 0)
            console.error(sprintf("Calling 0x%08X from 0x%08X", this.state.PC, this.lastPC));
        this.lastPC = this.state.PC;
        var func = this.instructionCache.getFunction(this.state.PC);
        func(this.state);
    };
    ProgramExecutor.prototype.executeUntilPCReachesWithoutCall = function (expectedPC) {
        while (this.state.PC != expectedPC) {
            this._executeStep();
            this.times++;
            if (this.times >= 100000) {
                this.times = 0;
                if ((performance.now() - this.lastTime) >= 50)
                    throw (new CpuBreakException());
                this.lastTime = performance.now();
            }
        }
    };
    ProgramExecutor.prototype.executeWithoutCatch = function (maxIterations) {
        if (maxIterations === void 0) { maxIterations = -1; }
        while (maxIterations != 0) {
            this._executeStep();
            if (maxIterations > 0)
                maxIterations--;
        }
    };
    ProgramExecutor.prototype.execute = function (maxIterations) {
        if (maxIterations === void 0) { maxIterations = -1; }
        try {
            this.executeWithoutCatch(maxIterations);
        }
        catch (e) {
            if (!(e instanceof CpuBreakException)) {
                console.log(this.state);
                this.state.printCallstack();
                throw (e);
            }
        }
    };
    return ProgramExecutor;
})();
exports.ProgramExecutor = ProgramExecutor;

},
"src/core/cpu/generator": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var codegen = require('./codegen');
var ast_builder = require('./ast_builder');
var instructions = require('./instructions');
var InstructionAst = codegen.InstructionAst;
var Instructions = instructions.Instructions;
var Instruction = instructions.Instruction;
var DecodedInstruction = instructions.DecodedInstruction;
var MipsAstBuilder = ast_builder.MipsAstBuilder;
var PspInstructionStm = (function (_super) {
    __extends(PspInstructionStm, _super);
    function PspInstructionStm(PC, code, di) {
        _super.call(this);
        this.PC = PC;
        this.code = code;
        this.di = di;
    }
    PspInstructionStm.prototype.toJs = function () {
        return "/*" + IntUtils.toHexString(this.PC, 8) + "*/ /* " + StringUtils.padLeft(this.di.type.name, ' ', 6) + " */  " + this.code.toJs();
    };
    PspInstructionStm.prototype.optimize = function () { return new PspInstructionStm(this.PC, this.code.optimize(), this.di); };
    return PspInstructionStm;
})(ast_builder.ANodeStm);
var FunctionGenerator = (function () {
    function FunctionGenerator(memory) {
        this.memory = memory;
        this.instructions = Instructions.instance;
        this.instructionAst = new InstructionAst();
        this.instructionUsageCount = {};
    }
    FunctionGenerator.prototype.getInstructionUsageCount = function () {
        var items = [];
        for (var key in this.instructionUsageCount) {
            var value = this.instructionUsageCount[key];
            items.push({ name: key, count: value });
        }
        items.sort(function (a, b) { return compareNumbers(a.count, b.count); }).reverse();
        return items;
    };
    FunctionGenerator.prototype.decodeInstruction = function (address) {
        var instruction = Instruction.fromMemoryAndPC(this.memory, address);
        var instructionType = this.getInstructionType(instruction);
        return new DecodedInstruction(instruction, instructionType);
    };
    FunctionGenerator.prototype.getInstructionType = function (i) {
        return this.instructions.findByData(i.data, i.PC);
    };
    FunctionGenerator.prototype.generateInstructionAstNode = function (di, PC) {
        var instruction = di.instruction;
        var instructionType = di.type;
        var func = this.instructionAst[instructionType.name];
        if (func === undefined)
            throw (sprintf("Not implemented '%s' at 0x%08X", instructionType, di.instruction.PC));
        return func.call(this.instructionAst, instruction, PC);
    };
    FunctionGenerator.prototype.create = function (address) {
        var code = this._create(address);
        try {
            return new Function('state', '"use strict";' + code);
        }
        catch (e) {
            console.info('code:\n', code);
            throw (e);
        }
    };
    FunctionGenerator.prototype._create = function (address) {
        var _this = this;
        var enableOptimizations = true;
        if (address == 0x00000000) {
            throw (new Error("Trying to execute 0x00000000"));
        }
        this.instructionAst.reset();
        var ast = new MipsAstBuilder();
        var startPC = address;
        var PC = address;
        var stms = new ast_builder.ANodeStmList([ast.functionPrefix()]);
        var mustDumpFunction = false;
        var pcToLabel = {};
        var emitInstruction = function () {
            var di = _this.decodeInstruction(PC);
            var result = new PspInstructionStm(PC, _this.generateInstructionAstNode(di, PC), di);
            PC += 4;
            return result;
        };
        stms.add(ast.raw_stm('var expectedRA = state.getRA();'));
        function returnWithCheck() {
            stms.add(ast.raw_stm('return;'));
        }
        for (var n = 0; n < 100000; n++) {
            var di = this.decodeInstruction(PC + 0);
            pcToLabel[PC] = stms.createLabel(PC);
            if (this.instructionUsageCount[di.type.name] === undefined) {
                this.instructionUsageCount[di.type.name] = 0;
            }
            this.instructionUsageCount[di.type.name]++;
            if (di.type.isJumpOrBranch) {
                var di2 = this.decodeInstruction(PC + 4);
                if (di2.type.isJumpOrBranch) {
                    stms.add(ast.debugger());
                    console.error("branch in delayed slot!");
                }
                var isBranch = di.type.isBranch;
                var isCall = di.type.isCall;
                var isUnconditionalNonLinkJump = (di.type.name == 'j');
                var jumpAddress = 0;
                var jumpBack = false;
                var jumpAhead = false;
                if (isBranch) {
                    jumpAddress = PC + di.instruction.imm16 * 4 + 4;
                }
                else {
                    jumpAddress = di.instruction.u_imm26 * 4;
                }
                jumpAhead = jumpAddress > PC;
                jumpBack = !jumpAhead;
                var isSimpleLoop = (isBranch || isUnconditionalNonLinkJump) && jumpBack && (jumpAddress >= startPC);
                var isFunctionCall = isCall;
                stms.add(emitInstruction());
                var delayedSlotInstruction = emitInstruction();
                if (di2.type.isSyscall) {
                    stms.add(this.instructionAst._postBranch(PC));
                    stms.add(ast.raw_stm('if (!state.BRANCHFLAG) {'));
                    returnWithCheck();
                    stms.add(ast.raw_stm('}'));
                    stms.add(this.instructionAst._likely(di.type.isLikely, delayedSlotInstruction));
                }
                else {
                    stms.add(this.instructionAst._likely(di.type.isLikely, delayedSlotInstruction));
                    stms.add(this.instructionAst._postBranch(PC));
                    stms.add(ast.raw_stm('if (!state.BRANCHFLAG) {'));
                    returnWithCheck();
                    stms.add(ast.raw_stm('}'));
                }
                if (enableOptimizations) {
                    if (isSimpleLoop) {
                        stms.add(ast.jump(pcToLabel[jumpAddress]));
                        break;
                    }
                    else if (isFunctionCall) {
                        stms.add(ast.call('state.callPC', [ast.pc()]));
                    }
                    else {
                        break;
                    }
                }
                else {
                    break;
                }
            }
            else {
                if (di.type.isSyscall) {
                    stms.add(this.instructionAst._storePC(PC + 4));
                }
                stms.add(emitInstruction());
                if (di.type.isBreak) {
                    stms.add(this.instructionAst._storePC(PC));
                    break;
                }
            }
        }
        returnWithCheck();
        if (mustDumpFunction) {
            console.debug("// function_" + IntUtils.toHexString(address, 8) + ":\n" + stms.toJs());
        }
        if (n >= 100000)
            throw (new Error(sprintf("Too large function PC=%08X", address)));
        return stms.toJs();
    };
    return FunctionGenerator;
})();
exports.FunctionGenerator = FunctionGenerator;

},
"src/core/cpu/icache": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var generator = require('./generator');
var state = require('./state');
var FunctionGenerator = generator.FunctionGenerator;
var CpuSpecialAddresses = state.CpuSpecialAddresses;
var InstructionCache = (function () {
    function InstructionCache(memory) {
        this.memory = memory;
        this.cache = {};
        this.functionGenerator = new FunctionGenerator(memory);
    }
    InstructionCache.prototype.invalidateAll = function () {
        this.cache = {};
    };
    InstructionCache.prototype.invalidateRange = function (from, to) {
        for (var n = from; n < to; n += 4)
            delete this.cache[n];
    };
    InstructionCache.prototype.getFunction = function (address) {
        var item = this.cache[address];
        if (item)
            return item;
        if (address == CpuSpecialAddresses.EXIT_THREAD) {
            return this.cache[address] = function (state) {
                //console.log(state);
                //console.log(state.thread);
                //console.warn('Thread: CpuSpecialAddresses.EXIT_THREAD: ' + state.thread.name);
                state.thread.stop('CpuSpecialAddresses.EXIT_THREAD');
                throw new CpuBreakException();
            };
        }
        else {
            return this.cache[address] = this.functionGenerator.create(address);
        }
    };
    return InstructionCache;
})();
exports.InstructionCache = InstructionCache;

},
"src/core/cpu/instructions": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var IndentStringGenerator = require('../../util/IndentStringGenerator');
var ADDR_TYPE_NONE = 0;
var ADDR_TYPE_REG = 1;
var ADDR_TYPE_16 = 2;
var ADDR_TYPE_26 = 3;
var INSTR_TYPE_PSP = (1 << 0);
var INSTR_TYPE_SYSCALL = (1 << 1);
var INSTR_TYPE_B = (1 << 2);
var INSTR_TYPE_LIKELY = (1 << 3);
var INSTR_TYPE_JAL = (1 << 4);
var INSTR_TYPE_JUMP = (1 << 5);
var INSTR_TYPE_BREAK = (1 << 6);
function VM(format) {
    var counts = {
        "cstw": 1, "cstz": 1, "csty": 1, "cstx": 1,
        "absw": 1, "absz": 1, "absy": 1, "absx": 1,
        "mskw": 1, "mskz": 1, "msky": 1, "mskx": 1,
        "negw": 1, "negz": 1, "negy": 1, "negx": 1,
        "one": 1, "two": 1, "vt1": 1,
        "vt2": 2,
        "satw": 2, "satz": 2, "saty": 2, "satx": 2,
        "swzw": 2, "swzz": 2, "swzy": 2, "swzx": 2,
        "imm3": 3,
        "imm4": 4,
        "fcond": 4,
        "c0dr": 5, "c0cr": 5, "c1dr": 5, "c1cr": 5, "imm5": 5, "vt5": 5,
        "rs": 5, "rd": 5, "rt": 5, "sa": 5, "lsb": 5, "msb": 5, "fs": 5, "fd": 5, "ft": 5,
        "vs": 7, "vt": 7, "vd": 7, "imm7": 7,
        "imm8": 8,
        "imm14": 14,
        "imm16": 16,
        "imm20": 20,
        "imm26": 26
    };
    var value = 0;
    var mask = 0;
    format.split(':').forEach(function (item) {
        if (/^[01\-]+$/.test(item)) {
            for (var n = 0; n < item.length; n++) {
                value <<= 1;
                mask <<= 1;
                if (item[n] == '0') {
                    value |= 0;
                    mask |= 1;
                }
                if (item[n] == '1') {
                    value |= 1;
                    mask |= 1;
                }
                if (item[n] == '-') {
                    value |= 0;
                    mask |= 0;
                }
            }
        }
        else {
            var displacement = counts[item];
            if (displacement === undefined)
                throw ("Invalid item '" + item + "'");
            value <<= displacement;
            mask <<= displacement;
        }
    });
    return { value: value, mask: mask };
}
var InstructionType = (function () {
    function InstructionType(name, vm, format, addressType, instructionType) {
        this.name = name;
        this.vm = vm;
        this.format = format;
        this.addressType = addressType;
        this.instructionType = instructionType;
    }
    InstructionType.prototype.match = function (i32) {
        return (i32 & this.vm.mask) == (this.vm.value & this.vm.mask);
    };
    InstructionType.prototype.isInstructionType = function (mask) {
        return (this.instructionType & mask) != 0;
    };
    Object.defineProperty(InstructionType.prototype, "isSyscall", {
        get: function () {
            return this.isInstructionType(INSTR_TYPE_SYSCALL);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstructionType.prototype, "isBreak", {
        get: function () {
            return this.isInstructionType(INSTR_TYPE_BREAK);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstructionType.prototype, "isBranch", {
        get: function () {
            return this.isInstructionType(INSTR_TYPE_B);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstructionType.prototype, "isCall", {
        get: function () {
            return this.isInstructionType(INSTR_TYPE_JAL);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstructionType.prototype, "isJump", {
        get: function () {
            return this.isInstructionType(INSTR_TYPE_JAL) || this.isInstructionType(INSTR_TYPE_JUMP);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstructionType.prototype, "isJumpOrBranch", {
        get: function () {
            return this.isBranch || this.isJump;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InstructionType.prototype, "isLikely", {
        get: function () {
            return this.isInstructionType(INSTR_TYPE_LIKELY);
        },
        enumerable: true,
        configurable: true
    });
    InstructionType.prototype.toString = function () {
        return sprintf("InstructionType('%s', %08X, %08X)", this.name, this.vm.value, this.vm.mask);
    };
    return InstructionType;
})();
exports.InstructionType = InstructionType;
var Instructions = (function () {
    function Instructions() {
        var _this = this;
        this.instructionTypeListByName = {};
        this.instructionTypeList = [];
        var ID = function (name, vm, format, addressType, instructionType) { _this.add(name, vm, format, addressType, instructionType); };
        ID("add", VM("000000:rs:rt:rd:00000:100000"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("addu", VM("000000:rs:rt:rd:00000:100001"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("addi", VM("001000:rs:rt:imm16"), "%t, %s, %i", ADDR_TYPE_NONE, 0);
        ID("addiu", VM("001001:rs:rt:imm16"), "%t, %s, %i", ADDR_TYPE_NONE, 0);
        ID("sub", VM("000000:rs:rt:rd:00000:100010"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("subu", VM("000000:rs:rt:rd:00000:100011"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("and", VM("000000:rs:rt:rd:00000:100100"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("andi", VM("001100:rs:rt:imm16"), "%t, %s, %I", ADDR_TYPE_NONE, 0);
        ID("nor", VM("000000:rs:rt:rd:00000:100111"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("or", VM("000000:rs:rt:rd:00000:100101"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("ori", VM("001101:rs:rt:imm16"), "%t, %s, %I", ADDR_TYPE_NONE, 0);
        ID("xor", VM("000000:rs:rt:rd:00000:100110"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("xori", VM("001110:rs:rt:imm16"), "%t, %s, %I", ADDR_TYPE_NONE, 0);
        ID("sll", VM("000000:00000:rt:rd:sa:000000"), "%d, %t, %a", ADDR_TYPE_NONE, 0);
        ID("sllv", VM("000000:rs:rt:rd:00000:000100"), "%d, %t, %s", ADDR_TYPE_NONE, 0);
        ID("sra", VM("000000:00000:rt:rd:sa:000011"), "%d, %t, %a", ADDR_TYPE_NONE, 0);
        ID("srav", VM("000000:rs:rt:rd:00000:000111"), "%d, %t, %s", ADDR_TYPE_NONE, 0);
        ID("srl", VM("000000:00000:rt:rd:sa:000010"), "%d, %t, %a", ADDR_TYPE_NONE, 0);
        ID("srlv", VM("000000:rs:rt:rd:00000:000110"), "%d, %t, %s", ADDR_TYPE_NONE, 0);
        ID("rotr", VM("000000:00001:rt:rd:sa:000010"), "%d, %t, %a", ADDR_TYPE_NONE, 0);
        ID("rotrv", VM("000000:rs:rt:rd:00001:000110"), "%d, %t, %s", ADDR_TYPE_NONE, 0);
        ID("slt", VM("000000:rs:rt:rd:00000:101010"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("slti", VM("001010:rs:rt:imm16"), "%t, %s, %i", ADDR_TYPE_NONE, 0);
        ID("sltu", VM("000000:rs:rt:rd:00000:101011"), "%d, %s, %t", ADDR_TYPE_NONE, 0);
        ID("sltiu", VM("001011:rs:rt:imm16"), "%t, %s, %i", ADDR_TYPE_NONE, 0);
        ID("lui", VM("001111:00000:rt:imm16"), "%t, %I", ADDR_TYPE_NONE, 0);
        ID("seb", VM("011111:00000:rt:rd:10000:100000"), "%d, %t", ADDR_TYPE_NONE, 0);
        ID("seh", VM("011111:00000:rt:rd:11000:100000"), "%d, %t", ADDR_TYPE_NONE, 0);
        ID("bitrev", VM("011111:00000:rt:rd:10100:100000"), "%d, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("max", VM("000000:rs:rt:rd:00000:101100"), "%d, %s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("min", VM("000000:rs:rt:rd:00000:101101"), "%d, %s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("div", VM("000000:rs:rt:00000:00000:011010"), "%s, %t", ADDR_TYPE_NONE, 0);
        ID("divu", VM("000000:rs:rt:00000:00000:011011"), "%s, %t", ADDR_TYPE_NONE, 0);
        ID("mult", VM("000000:rs:rt:00000:00000:011000"), "%s, %t", ADDR_TYPE_NONE, 0);
        ID("multu", VM("000000:rs:rt:00000:00000:011001"), "%s, %t", ADDR_TYPE_NONE, 0);
        ID("madd", VM("000000:rs:rt:00000:00000:011100"), "%s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("maddu", VM("000000:rs:rt:00000:00000:011101"), "%s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("msub", VM("000000:rs:rt:00000:00000:101110"), "%s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("msubu", VM("000000:rs:rt:00000:00000:101111"), "%s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("mfhi", VM("000000:00000:00000:rd:00000:010000"), "%d", ADDR_TYPE_NONE, 0);
        ID("mflo", VM("000000:00000:00000:rd:00000:010010"), "%d", ADDR_TYPE_NONE, 0);
        ID("mthi", VM("000000:rs:00000:00000:00000:010001"), "%s", ADDR_TYPE_NONE, 0);
        ID("mtlo", VM("000000:rs:00000:00000:00000:010011"), "%s", ADDR_TYPE_NONE, 0);
        ID("movz", VM("000000:rs:rt:rd:00000:001010"), "%d, %s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("movn", VM("000000:rs:rt:rd:00000:001011"), "%d, %s, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("ext", VM("011111:rs:rt:msb:lsb:000000"), "%t, %s, %a, %ne", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("ins", VM("011111:rs:rt:msb:lsb:000100"), "%t, %s, %a, %ni", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("clz", VM("000000:rs:00000:rd:00000:010110"), "%d, %s", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("clo", VM("000000:rs:00000:rd:00000:010111"), "%d, %s", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("wsbh", VM("011111:00000:rt:rd:00010:100000"), "%d, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("wsbw", VM("011111:00000:rt:rd:00011:100000"), "%d, %t", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("beq", VM("000100:rs:rt:imm16"), "%s, %t, %O", ADDR_TYPE_16, INSTR_TYPE_B);
        ID("beql", VM("010100:rs:rt:imm16"), "%s, %t, %O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
        ID("bgez", VM("000001:rs:00001:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B);
        ID("bgezl", VM("000001:rs:00011:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
        ID("bgezal", VM("000001:rs:10001:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_JAL);
        ID("bgezall", VM("000001:rs:10011:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_JAL | INSTR_TYPE_LIKELY);
        ID("bltz", VM("000001:rs:00000:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B);
        ID("bltzl", VM("000001:rs:00010:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
        ID("bltzal", VM("000001:rs:10000:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_JAL);
        ID("bltzall", VM("000001:rs:10010:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_JAL | INSTR_TYPE_LIKELY);
        ID("blez", VM("000110:rs:00000:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B);
        ID("blezl", VM("010110:rs:00000:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
        ID("bgtz", VM("000111:rs:00000:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B);
        ID("bgtzl", VM("010111:rs:00000:imm16"), "%s, %O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
        ID("bne", VM("000101:rs:rt:imm16"), "%s, %t, %O", ADDR_TYPE_16, INSTR_TYPE_B);
        ID("bnel", VM("010101:rs:rt:imm16"), "%s, %t, %O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
        ID("j", VM("000010:imm26"), "%j", ADDR_TYPE_26, INSTR_TYPE_JUMP);
        ID("jr", VM("000000:rs:00000:00000:00000:001000"), "%J", ADDR_TYPE_REG, INSTR_TYPE_JUMP);
        ID("jalr", VM("000000:rs:00000:rd:00000:001001"), "%J, %d", ADDR_TYPE_REG, INSTR_TYPE_JAL);
        ID("jal", VM("000011:imm26"), "%j", ADDR_TYPE_26, INSTR_TYPE_JAL);
        ID("bc1f", VM("010001:01000:00000:imm16"), "%O", ADDR_TYPE_16, INSTR_TYPE_B);
        ID("bc1t", VM("010001:01000:00001:imm16"), "%O", ADDR_TYPE_16, INSTR_TYPE_B);
        ID("bc1fl", VM("010001:01000:00010:imm16"), "%O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
        ID("bc1tl", VM("010001:01000:00011:imm16"), "%O", ADDR_TYPE_16, INSTR_TYPE_B | INSTR_TYPE_LIKELY);
        ID("lb", VM("100000:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("lh", VM("100001:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("lw", VM("100011:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("lwl", VM("100010:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("lwr", VM("100110:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("lbu", VM("100100:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("lhu", VM("100101:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("sb", VM("101000:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("sh", VM("101001:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("sw", VM("101011:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("swl", VM("101010:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("swr", VM("101110:rs:rt:imm16"), "%t, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("ll", VM("110000:rs:rt:imm16"), "%t, %O", ADDR_TYPE_NONE, 0);
        ID("sc", VM("111000:rs:rt:imm16"), "%t, %O", ADDR_TYPE_NONE, 0);
        ID("lwc1", VM("110001:rs:ft:imm16"), "%T, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("swc1", VM("111001:rs:ft:imm16"), "%T, %i(%s)", ADDR_TYPE_NONE, 0);
        ID("add.s", VM("010001:10000:ft:fs:fd:000000"), "%D, %S, %T", ADDR_TYPE_NONE, 0);
        ID("sub.s", VM("010001:10000:ft:fs:fd:000001"), "%D, %S, %T", ADDR_TYPE_NONE, 0);
        ID("mul.s", VM("010001:10000:ft:fs:fd:000010"), "%D, %S, %T", ADDR_TYPE_NONE, 0);
        ID("div.s", VM("010001:10000:ft:fs:fd:000011"), "%D, %S, %T", ADDR_TYPE_NONE, 0);
        ID("sqrt.s", VM("010001:10000:00000:fs:fd:000100"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("abs.s", VM("010001:10000:00000:fs:fd:000101"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("mov.s", VM("010001:10000:00000:fs:fd:000110"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("neg.s", VM("010001:10000:00000:fs:fd:000111"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("round.w.s", VM("010001:10000:00000:fs:fd:001100"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("trunc.w.s", VM("010001:10000:00000:fs:fd:001101"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("ceil.w.s", VM("010001:10000:00000:fs:fd:001110"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("floor.w.s", VM("010001:10000:00000:fs:fd:001111"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("cvt.s.w", VM("010001:10100:00000:fs:fd:100000"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("cvt.w.s", VM("010001:10000:00000:fs:fd:100100"), "%D, %S", ADDR_TYPE_NONE, 0);
        ID("mfc1", VM("010001:00000:rt:c1dr:00000:000000"), "%t, %S", ADDR_TYPE_NONE, 0);
        ID("mtc1", VM("010001:00100:rt:c1dr:00000:000000"), "%t, %S", ADDR_TYPE_NONE, 0);
        ID("cfc1", VM("010001:00010:rt:c1cr:00000:000000"), "%t, %p", ADDR_TYPE_NONE, 0);
        ID("ctc1", VM("010001:00110:rt:c1cr:00000:000000"), "%t, %p", ADDR_TYPE_NONE, 0);
        ID("c.f.s", VM("010001:10000:ft:fs:00000:11:0000"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.un.s", VM("010001:10000:ft:fs:00000:11:0001"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.eq.s", VM("010001:10000:ft:fs:00000:11:0010"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.ueq.s", VM("010001:10000:ft:fs:00000:11:0011"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.olt.s", VM("010001:10000:ft:fs:00000:11:0100"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.ult.s", VM("010001:10000:ft:fs:00000:11:0101"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.ole.s", VM("010001:10000:ft:fs:00000:11:0110"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.ule.s", VM("010001:10000:ft:fs:00000:11:0111"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.sf.s", VM("010001:10000:ft:fs:00000:11:1000"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.ngle.s", VM("010001:10000:ft:fs:00000:11:1001"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.seq.s", VM("010001:10000:ft:fs:00000:11:1010"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.ngl.s", VM("010001:10000:ft:fs:00000:11:1011"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.lt.s", VM("010001:10000:ft:fs:00000:11:1100"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.nge.s", VM("010001:10000:ft:fs:00000:11:1101"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.le.s", VM("010001:10000:ft:fs:00000:11:1110"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("c.ngt.s", VM("010001:10000:ft:fs:00000:11:1111"), "%S, %T", ADDR_TYPE_NONE, 0);
        ID("syscall", VM("000000:imm20:001100"), "%C", ADDR_TYPE_NONE, INSTR_TYPE_SYSCALL);
        ID("cache", VM("101111:rs:-----:imm16"), "%k, %o", ADDR_TYPE_NONE, 0);
        ID("sync", VM("000000:00000:00000:00000:00000:001111"), "", ADDR_TYPE_NONE, 0);
        ID("break", VM("000000:imm20:001101"), "%c", ADDR_TYPE_NONE, INSTR_TYPE_BREAK);
        ID("dbreak", VM("011100:00000:00000:00000:00000:111111"), "", ADDR_TYPE_NONE, INSTR_TYPE_PSP | INSTR_TYPE_BREAK);
        ID("halt", VM("011100:00000:00000:00000:00000:000000"), "", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("dret", VM("011100:00000:00000:00000:00000:111110"), "", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("eret", VM("010000:10000:00000:00000:00000:011000"), "", ADDR_TYPE_NONE, 0);
        ID("mfic", VM("011100:rt:00000:00000:00000:100100"), "%t, %p", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("mtic", VM("011100:rt:00000:00000:00000:100110"), "%t, %p", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("mfdr", VM("011100:00000:----------:00000:111101"), "%t, %r", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("mtdr", VM("011100:00100:----------:00000:111101"), "%t, %r", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("cfc0", VM("010000:00010:----------:00000:000000"), "%t, %p", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("ctc0", VM("010000:00110:----------:00000:000000"), "%t, %p", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("mfc0", VM("010000:00000:----------:00000:000000"), "%t, %0", ADDR_TYPE_NONE, 0);
        ID("mtc0", VM("010000:00100:----------:00000:000000"), "%t, %0", ADDR_TYPE_NONE, 0);
        ID("mfv", VM("010010:00:011:rt:0:0000000:0:vd"), "%t, %zs", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("mfvc", VM("010010:00:011:rt:0:0000000:1:vd"), "%t, %2d", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("mtv", VM("010010:00:111:rt:0:0000000:0:vd"), "%t, %zs", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("mtvc", VM("010010:00:111:rt:0:0000000:1:vd"), "%t, %2d", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("lv.s", VM("110010:rs:vt5:imm14:vt2"), "%Xs, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("lv.q", VM("110110:rs:vt5:imm14:0:vt1"), "%Xq, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("lvl.q", VM("110101:rs:vt5:imm14:0:vt1"), "%Xq, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("lvr.q", VM("110101:rs:vt5:imm14:1:vt1"), "%Xq, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("sv.q", VM("111110:rs:vt5:imm14:0:vt1"), "%Xq, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vdot", VM("011001:001:vt:two:vs:one:vd"), "%zs, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vscl", VM("011001:010:vt:two:vs:one:vd"), "%zp, %yp, %xs", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsge", VM("011011:110:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vslt", VM("011011:111:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vrot", VM("111100:111:01:imm5:two:vs:one:vd"), "%zp, %ys, %vr", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vzero", VM("110100:00:000:0:0110:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vone", VM("110100:00:000:0:0111:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmov", VM("110100:00:000:0:0000:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vabs", VM("110100:00:000:0:0001:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vneg", VM("110100:00:000:0:0010:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vocp", VM("110100:00:010:0:0100:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsgn", VM("110100:00:010:0:1010:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vrcp", VM("110100:00:000:1:0000:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vrsq", VM("110100:00:000:1:0001:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsin", VM("110100:00:000:1:0010:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vcos", VM("110100:00:000:1:0011:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vexp2", VM("110100:00:000:1:0100:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vlog2", VM("110100:00:000:1:0101:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsqrt", VM("110100:00:000:1:0110:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vasin", VM("110100:00:000:1:0111:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vnrcp", VM("110100:00:000:1:1000:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vnsin", VM("110100:00:000:1:1010:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vrexp2", VM("110100:00:000:1:1100:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsat0", VM("110100:00:000:0:0100:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsat1", VM("110100:00:000:0:0101:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vcst", VM("110100:00:011:imm5:two:0000000:one:vd"), "%zp, %vk", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmmul", VM("111100:000:vt:two:vs:one:vd"), "%zm, %tym, %xm", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vhdp", VM("011001:100:vt:two:vs:one:vd"), "%zs, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vcrs.t", VM("011001:101:vt:1:vs:0:vd"), "%zt, %yt, %xt", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vcrsp.t", VM("111100:101:vt:1:vs:0:vd"), "%zt, %yt, %xt", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vi2c", VM("110100:00:001:11:101:two:vs:one:vd"), "%zs, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vi2uc", VM("110100:00:001:11:100:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vtfm2", VM("111100:001:vt:0:vs:1:vd"), "%zp, %ym, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vtfm3", VM("111100:010:vt:1:vs:0:vd"), "%zt, %yn, %xt", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vtfm4", VM("111100:011:vt:1:vs:1:vd"), "%zq, %yo, %xq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vhtfm2", VM("111100:001:vt:0:vs:0:vd"), "%zp, %ym, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vhtfm3", VM("111100:010:vt:0:vs:1:vd"), "%zt, %yn, %xt", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vhtfm4", VM("111100:011:vt:1:vs:0:vd"), "%zq, %yo, %xq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsrt3", VM("110100:00:010:01000:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vfad", VM("110100:00:010:00110:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmin", VM("011011:010:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmax", VM("011011:011:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vadd", VM("011000:000:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsub", VM("011000:001:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vdiv", VM("011000:111:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmul", VM("011001:000:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vidt", VM("110100:00:000:0:0011:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmidt", VM("111100:111:00:00011:two:0000000:one:vd"), "%zm", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("viim", VM("110111:11:0:vd:imm16"), "%xs, %vi", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmmov", VM("111100:111:00:00000:two:vs:one:vd"), "%zm, %ym", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmzero", VM("111100:111:00:00110:two:0000000:one:vd"), "%zm", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmone", VM("111100:111:00:00111:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vnop", VM("111111:1111111111:00000:00000000000"), "", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsync", VM("111111:1111111111:00000:01100100000"), "", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vflush", VM("111111:1111111111:00000:10000001101"), "", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vpfxd", VM("110111:10:------------:mskw:mskz:msky:mskx:satw:satz:saty:satx"), "[%vp4, %vp5, %vp6, %vp7]", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vpfxs", VM("110111:00:----:negw:negz:negy:negx:cstw:cstz:csty:cstx:absw:absz:absy:absx:swzw:swzz:swzy:swzx"), "[%vp0, %vp1, %vp2, %vp3]", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vpfxt", VM("110111:01:----:negw:negz:negy:negx:cstw:cstz:csty:cstx:absw:absz:absy:absx:swzw:swzz:swzy:swzx"), "[%vp0, %vp1, %vp2, %vp3]", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vdet", VM("011001:110:vt:two:vs:one:vd"), "%zs, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vrnds", VM("110100:00:001:00:000:two:vs:one:0000000"), "%ys", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vrndi", VM("110100:00:001:00:001:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vrndf1", VM("110100:00:001:00:010:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vrndf2", VM("110100:00:001:00:011:two:0000000:one:vd"), "%zp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vcmp", VM("011011:000:vt:two:vs:one:000:imm4"), "%Zn, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vcmovf", VM("110100:10:101:01:imm3:two:vs:one:vd"), "%zp, %yp, %v3", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vcmovt", VM("110100:10:101:00:imm3:two:vs:one:vd"), "%zp, %yp, %v3", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vavg", VM("110100:00:010:00111:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vf2id", VM("110100:10:011:imm5:two:vs:one:vd"), "%zp, %yp, %v5", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vf2in", VM("110100:10:000:imm5:two:vs:one:vd"), "%zp, %yp, %v5", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vf2iu", VM("110100:10:010:imm5:two:vs:one:vd"), "%zp, %yp, %v5", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vf2iz", VM("110100:10:001:imm5:two:vs:one:vd"), "%zp, %yp, %v5", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vi2f", VM("110100:10:100:imm5:two:vs:one:vd"), "%zp, %yp, %v5", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vscmp", VM("011011:101:vt:two:vs:one:vd"), "%zp, %yp, %xp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmscl", VM("111100:100:vt:two:vs:one:vd"), "%zm, %ym, %xs", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vt4444.q", VM("110100:00:010:11001:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vt5551.q", VM("110100:00:010:11010:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vt5650.q", VM("110100:00:010:11011:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmfvc", VM("110100:00:010:10000:1:imm7:0:vd"), "%zs, %2s", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vmtvc", VM("110100:00:010:10001:0:vs:1:imm7"), "%2d, %ys", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("mfvme", VM("011010--------------------------"), "%t, %i", ADDR_TYPE_NONE, 0);
        ID("mtvme", VM("101100--------------------------"), "%t, %i", ADDR_TYPE_NONE, 0);
        ID("sv.s", VM("111010:rs:vt5:imm14:vt2"), "%Xs, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vfim", VM("110111:11:1:vt:imm16"), "%xs, %vh", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("svl.q", VM("111101:rs:vt5:imm14:0:vt1"), "%Xq, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("svr.q", VM("111101:rs:vt5:imm14:1:vt1"), "%Xq, %Y", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vbfy1", VM("110100:00:010:00010:two:vs:one:vd"), "%zp, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vbfy2", VM("110100:00:010:00011:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vf2h", VM("110100:00:001:10:010:two:vs:one:vd"), "%zs, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vh2f", VM("110100:00:001:10:011:two:vs:one:vd"), "%zq, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vi2s", VM("110100:00:001:11:111:two:vs:one:vd"), "%zs, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vi2us", VM("110100:00:001:11:110:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vlgb", VM("110100:00:001:10:111:two:vs:one:vd"), "%zs, %ys", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vqmul", VM("111100:101:vt:1:vs:1:vd"), "%zq, %yq, %xq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vs2i", VM("110100:00:001:11:011:two:vs:one:vd"), "%zq, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vc2i", VM("110100:00:001:11:001:two:vs:one:vd"), "%zs, %ys, %xs", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vuc2i", VM("110100:00:001:11:000:two:vs:one:vd"), "%zq, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsbn", VM("011000:010:vt:two:vs:one:vd"), "%zs, %ys, %xs", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsbz", VM("110100:00:001:10110:two:vs:one:vd"), "%zs, %ys", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsocp", VM("110100:00:010:00101:two:vs:one:vd"), "%zq, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsrt1", VM("110100:00:010:00000:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsrt2", VM("110100:00:010:00001:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vsrt4", VM("110100:00:010:01001:two:vs:one:vd"), "%zq, %yq", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vus2i", VM("110100:00:001:11010:two:vs:one:vd"), "%zq, %yp", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("vwbn", VM("110100:11:imm8:two:vs:one:vd"), "%zs, %xs, %I", ADDR_TYPE_NONE, INSTR_TYPE_PSP);
        ID("bvf", VM("010010:01:000:imm3:00:imm16"), "%Zc, %O", ADDR_TYPE_16, INSTR_TYPE_PSP | INSTR_TYPE_B);
        ID("bvt", VM("010010:01:000:imm3:01:imm16"), "%Zc, %O", ADDR_TYPE_16, INSTR_TYPE_PSP | INSTR_TYPE_B);
        ID("bvfl", VM("010010:01:000:imm3:10:imm16"), "%Zc, %O", ADDR_TYPE_16, INSTR_TYPE_PSP | INSTR_TYPE_B | INSTR_TYPE_LIKELY);
        ID("bvtl", VM("010010:01:000:imm3:11:imm16"), "%Zc, %O", ADDR_TYPE_16, INSTR_TYPE_PSP | INSTR_TYPE_B | INSTR_TYPE_LIKELY);
    }
    Object.defineProperty(Instructions, "instance", {
        get: function () {
            if (!Instructions._instance)
                Instructions._instance = new Instructions();
            return Instructions._instance;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instructions.prototype, "instructions", {
        get: function () {
            return this.instructionTypeList.slice(0);
        },
        enumerable: true,
        configurable: true
    });
    Instructions.prototype.add = function (name, vm, format, addressType, instructionType) {
        var it = new InstructionType(name, vm, format, addressType, instructionType);
        this.instructionTypeListByName[name] = it;
        this.instructionTypeList.push(it);
    };
    Instructions.prototype.findByName = function (name) {
        var instructionType = this.instructionTypeListByName[name];
        if (!instructionType)
            throw ("Cannot find instruction " + sprintf("%s", name));
        return instructionType;
    };
    Instructions.prototype.findByData = function (i32, pc) {
        if (pc === void 0) { pc = 0; }
        return this.fastFindByData(i32, pc);
    };
    Instructions.prototype.fastFindByData = function (i32, pc) {
        if (pc === void 0) { pc = 0; }
        if (!this.decoder) {
            var switchCode = DecodingTable.createSwitch(this.instructionTypeList);
            this.decoder = (new Function('instructionsByName', 'value', 'pc', '"use strict";' + switchCode));
        }
        return this.decoder(this.instructionTypeListByName, i32, pc);
    };
    Instructions.prototype.slowFindByData = function (i32, pc) {
        if (pc === void 0) { pc = 0; }
        for (var n = 0; n < this.instructionTypeList.length; n++) {
            var instructionType = this.instructionTypeList[n];
            if (instructionType.match(i32))
                return instructionType;
        }
        throw (sprintf("Cannot find instruction 0x%08X at 0x%08X", i32, pc));
    };
    return Instructions;
})();
exports.Instructions = Instructions;
var DecodingTable = (function () {
    function DecodingTable() {
        this.lastId = 0;
    }
    DecodingTable.prototype.getCommonMask = function (instructions, baseMask) {
        if (baseMask === void 0) { baseMask = 0xFFFFFFFF; }
        return instructions.reduce(function (left, item) { return left & item.vm.mask; }, baseMask);
    };
    DecodingTable.createSwitch = function (instructions) {
        var writer = new IndentStringGenerator();
        var decodingTable = new DecodingTable();
        decodingTable._createSwitch(writer, instructions);
        return writer.output;
    };
    DecodingTable.prototype._createSwitch = function (writer, instructions, baseMask, level) {
        var _this = this;
        if (baseMask === void 0) { baseMask = 0xFFFFFFFF; }
        if (level === void 0) { level = 0; }
        if (level >= 10)
            throw ('ERROR: Recursive detection');
        var commonMask = this.getCommonMask(instructions, baseMask);
        var groups = {};
        instructions.forEach(function (item) {
            var commonValue = item.vm.value & commonMask;
            if (!groups[commonValue])
                groups[commonValue] = [];
            groups[commonValue].push(item);
        });
        writer.write('switch ((value & ' + sprintf('0x%08X', commonMask) + ') >>> 0) {\n');
        writer.indent(function () {
            for (var groupKey in groups) {
                var group = groups[groupKey];
                writer.write('case ' + sprintf('0x%08X', groupKey) + ':');
                writer.indent(function () {
                    if (group.length == 1) {
                        writer.write(' return instructionsByName[' + JSON.stringify(group[0].name) + '];');
                    }
                    else {
                        writer.write('\n');
                        _this._createSwitch(writer, group, ~commonMask, level + 1);
                        writer.write('break;\n');
                    }
                });
            }
            writer.write('default: throw(sprintf("Invalid instruction 0x%08X at 0x%08X (' + _this.lastId++ + ') failed mask 0x%08X", value, pc, ' + commonMask + '));\n');
        });
        writer.write('}\n');
    };
    return DecodingTable;
})();
var Instruction = (function () {
    function Instruction(PC, data) {
        this.PC = PC;
        this.data = data;
    }
    Instruction.fromMemoryAndPC = function (memory, PC) { return new Instruction(PC, memory.readInt32(PC)); };
    Instruction.prototype.extract = function (offset, length) { return BitUtils.extract(this.data, offset, length); };
    Instruction.prototype.extract_s = function (offset, length) { return BitUtils.extractSigned(this.data, offset, length); };
    Instruction.prototype.insert = function (offset, length, value) { this.data = BitUtils.insert(this.data, offset, length, value); };
    Object.defineProperty(Instruction.prototype, "rd", {
        get: function () { return this.extract(11 + 5 * 0, 5); },
        set: function (value) { this.insert(11 + 5 * 0, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "rt", {
        get: function () { return this.extract(11 + 5 * 1, 5); },
        set: function (value) { this.insert(11 + 5 * 1, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "rs", {
        get: function () { return this.extract(11 + 5 * 2, 5); },
        set: function (value) { this.insert(11 + 5 * 2, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "fd", {
        get: function () { return this.extract(6 + 5 * 0, 5); },
        set: function (value) { this.insert(6 + 5 * 0, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "fs", {
        get: function () { return this.extract(6 + 5 * 1, 5); },
        set: function (value) { this.insert(6 + 5 * 1, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "ft", {
        get: function () { return this.extract(6 + 5 * 2, 5); },
        set: function (value) { this.insert(6 + 5 * 2, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "VD", {
        get: function () { return this.extract(0, 7); },
        set: function (value) { this.insert(0, 7, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "VS", {
        get: function () { return this.extract(8, 7); },
        set: function (value) { this.insert(8, 7, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "VT", {
        get: function () { return this.extract(16, 7); },
        set: function (value) { this.insert(16, 7, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "VT5_1", {
        get: function () { return this.VT5 | (this.VT1 << 5); },
        set: function (value) { this.VT5 = value; this.VT1 = (value >>> 5); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "IMM14", {
        get: function () { return this.extract_s(2, 14); },
        set: function (value) { this.insert(2, 14, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "ONE", {
        get: function () { return this.extract(7, 1); },
        set: function (value) { this.insert(7, 1, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "TWO", {
        get: function () { return this.extract(15, 1); },
        set: function (value) { this.insert(15, 1, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "ONE_TWO", {
        get: function () { return (1 + 1 * this.ONE + 2 * this.TWO); },
        set: function (value) { this.ONE = (((value - 1) >>> 0) & 1); this.TWO = (((value - 1) >>> 1) & 1); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "IMM8", {
        get: function () { return this.extract(16, 8); },
        set: function (value) { this.insert(16, 8, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "IMM5", {
        get: function () { return this.extract(16, 5); },
        set: function (value) { this.insert(16, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "IMM3", {
        get: function () { return this.extract(18, 3); },
        set: function (value) { this.insert(18, 3, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "IMM7", {
        get: function () { return this.extract(0, 7); },
        set: function (value) { this.insert(0, 7, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "IMM4", {
        get: function () { return this.extract(0, 4); },
        set: function (value) { this.insert(0, 4, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "VT1", {
        get: function () { return this.extract(0, 1); },
        set: function (value) { this.insert(0, 1, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "VT2", {
        get: function () { return this.extract(0, 2); },
        set: function (value) { this.insert(0, 2, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "VT5", {
        get: function () { return this.extract(16, 5); },
        set: function (value) { this.insert(16, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "VT5_2", {
        get: function () { return this.VT5 | (this.VT2 << 5); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "IMM_HF", {
        get: function () { return HalfFloat.toFloat(this.imm16); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "pos", {
        get: function () { return this.lsb; },
        set: function (value) { this.lsb = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "size_e", {
        get: function () { return this.msb + 1; },
        set: function (value) { this.msb = value - 1; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "size_i", {
        get: function () { return this.msb - this.lsb + 1; },
        set: function (value) { this.msb = this.lsb + value - 1; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "lsb", {
        get: function () { return this.extract(6 + 5 * 0, 5); },
        set: function (value) { this.insert(6 + 5 * 0, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "msb", {
        get: function () { return this.extract(6 + 5 * 1, 5); },
        set: function (value) { this.insert(6 + 5 * 1, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "c1cr", {
        get: function () { return this.extract(6 + 5 * 1, 5); },
        set: function (value) { this.insert(6 + 5 * 1, 5, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "syscall", {
        get: function () { return this.extract(6, 20); },
        set: function (value) { this.insert(6, 20, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "imm16", {
        get: function () { var res = this.u_imm16; if (res & 0x8000)
            res |= 0xFFFF0000; return res; },
        set: function (value) { this.insert(0, 16, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "u_imm16", {
        get: function () { return this.extract(0, 16); },
        set: function (value) { this.insert(0, 16, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "u_imm26", {
        get: function () { return this.extract(0, 26); },
        set: function (value) { this.insert(0, 26, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "jump_bits", {
        get: function () { return this.extract(0, 26); },
        set: function (value) { this.insert(0, 26, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Instruction.prototype, "jump_real", {
        get: function () { return (this.jump_bits * 4) >>> 0; },
        set: function (value) { this.jump_bits = (value / 4) >>> 0; },
        enumerable: true,
        configurable: true
    });
    return Instruction;
})();
exports.Instruction = Instruction;
var DecodedInstruction = (function () {
    function DecodedInstruction(instruction, type) {
        this.instruction = instruction;
        this.type = type;
    }
    return DecodedInstruction;
})();
exports.DecodedInstruction = DecodedInstruction;

},
"src/core/cpu/state": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
(function (CpuSpecialAddresses) {
    CpuSpecialAddresses[CpuSpecialAddresses["EXIT_THREAD"] = 268435455] = "EXIT_THREAD";
})(exports.CpuSpecialAddresses || (exports.CpuSpecialAddresses = {}));
var CpuSpecialAddresses = exports.CpuSpecialAddresses;
var VfpuPrefixBase = (function () {
    function VfpuPrefixBase(vfrc, index) {
        this.vfrc = vfrc;
        this.index = index;
        this.enabled = false;
    }
    VfpuPrefixBase.prototype._readInfo = function () {
        this._info = this.getInfo();
    };
    VfpuPrefixBase.prototype.eat = function () {
        this.enabled = false;
    };
    VfpuPrefixBase.prototype.getInfo = function () {
        return this.vfrc[this.index];
    };
    VfpuPrefixBase.prototype.setInfo = function (info) {
        this.vfrc[this.index] = info;
        this.enabled = true;
    };
    return VfpuPrefixBase;
})();
var VfpuPrefixRead = (function (_super) {
    __extends(VfpuPrefixRead, _super);
    function VfpuPrefixRead() {
        _super.apply(this, arguments);
    }
    VfpuPrefixRead.prototype.transformValues = function (input, output) {
        this._readInfo();
        var info = this._info;
        if (!this.enabled) {
            for (var n = 0; n < input.length; n++)
                output[n] = input[n];
        }
        else {
            for (var n = 0; n < input.length; n++) {
                var sourceIndex = (info >> (0 + n * 2)) & 3;
                var sourceAbsolute = (info >> (8 + n * 1)) & 1;
                var sourceConstant = (info >> (12 + n * 1)) & 1;
                var sourceNegate = (info >> (16 + n * 1)) & 1;
                var value;
                if (sourceConstant) {
                    switch (sourceIndex) {
                        case 0:
                            value = sourceAbsolute ? (3) : (0);
                            break;
                        case 1:
                            value = sourceAbsolute ? (1 / 3) : (1);
                            break;
                        case 2:
                            value = sourceAbsolute ? (1 / 4) : (2);
                            break;
                        case 3:
                            value = sourceAbsolute ? (1 / 6) : (1 / 2);
                            break;
                        default:
                            throw (new Error("Invalid operation"));
                            break;
                    }
                }
                else {
                    value = input[sourceIndex];
                    if (sourceAbsolute)
                        value = Math.abs(value);
                }
                if (sourceNegate)
                    value = MathFloat.neg(value);
                output[n] = value;
            }
        }
    };
    return VfpuPrefixRead;
})(VfpuPrefixBase);
var VfpuPrefixWrite = (function (_super) {
    __extends(VfpuPrefixWrite, _super);
    function VfpuPrefixWrite() {
        _super.apply(this, arguments);
    }
    VfpuPrefixWrite.prototype.storeTransformedValues = function (vfpr, indices, values) {
        this._readInfo();
        var info = this._info;
        if (!this.enabled) {
            for (var n = 0; n < indices.length; n++) {
                vfpr[indices[n]] = values[n];
            }
        }
        else {
            for (var n = 0; n < indices.length; n++) {
                var destinationSaturation = (info >> (0 + n * 2)) & 3;
                var destinationMask = (info >> (8 + n * 1)) & 1;
                if (destinationMask) {
                }
                else {
                    var value = values[n];
                    switch (destinationSaturation) {
                        case 1:
                            value = MathFloat.sat0(value);
                            break;
                        case 3:
                            value = MathFloat.sat1(value);
                            break;
                        default: break;
                    }
                    vfpr[indices[n]] = value;
                }
            }
        }
    };
    return VfpuPrefixWrite;
})(VfpuPrefixBase);
(function (VFPU_CTRL) {
    VFPU_CTRL[VFPU_CTRL["SPREFIX"] = 0] = "SPREFIX";
    VFPU_CTRL[VFPU_CTRL["TPREFIX"] = 1] = "TPREFIX";
    VFPU_CTRL[VFPU_CTRL["DPREFIX"] = 2] = "DPREFIX";
    VFPU_CTRL[VFPU_CTRL["CC"] = 3] = "CC";
    VFPU_CTRL[VFPU_CTRL["INF4"] = 4] = "INF4";
    VFPU_CTRL[VFPU_CTRL["RSV5"] = 5] = "RSV5";
    VFPU_CTRL[VFPU_CTRL["RSV6"] = 6] = "RSV6";
    VFPU_CTRL[VFPU_CTRL["REV"] = 7] = "REV";
    VFPU_CTRL[VFPU_CTRL["RCX0"] = 8] = "RCX0";
    VFPU_CTRL[VFPU_CTRL["RCX1"] = 9] = "RCX1";
    VFPU_CTRL[VFPU_CTRL["RCX2"] = 10] = "RCX2";
    VFPU_CTRL[VFPU_CTRL["RCX3"] = 11] = "RCX3";
    VFPU_CTRL[VFPU_CTRL["RCX4"] = 12] = "RCX4";
    VFPU_CTRL[VFPU_CTRL["RCX5"] = 13] = "RCX5";
    VFPU_CTRL[VFPU_CTRL["RCX6"] = 14] = "RCX6";
    VFPU_CTRL[VFPU_CTRL["RCX7"] = 15] = "RCX7";
    VFPU_CTRL[VFPU_CTRL["MAX"] = 16] = "MAX";
})(exports.VFPU_CTRL || (exports.VFPU_CTRL = {}));
var VFPU_CTRL = exports.VFPU_CTRL;
(function (VCondition) {
    VCondition[VCondition["FL"] = 0] = "FL";
    VCondition[VCondition["EQ"] = 1] = "EQ";
    VCondition[VCondition["LT"] = 2] = "LT";
    VCondition[VCondition["LE"] = 3] = "LE";
    VCondition[VCondition["TR"] = 4] = "TR";
    VCondition[VCondition["NE"] = 5] = "NE";
    VCondition[VCondition["GE"] = 6] = "GE";
    VCondition[VCondition["GT"] = 7] = "GT";
    VCondition[VCondition["EZ"] = 8] = "EZ";
    VCondition[VCondition["EN"] = 9] = "EN";
    VCondition[VCondition["EI"] = 10] = "EI";
    VCondition[VCondition["ES"] = 11] = "ES";
    VCondition[VCondition["NZ"] = 12] = "NZ";
    VCondition[VCondition["NN"] = 13] = "NN";
    VCondition[VCondition["NI"] = 14] = "NI";
    VCondition[VCondition["NS"] = 15] = "NS";
})(exports.VCondition || (exports.VCondition = {}));
var VCondition = exports.VCondition;
;
var CpuState = (function () {
    function CpuState(memory, syscallManager) {
        this.memory = memory;
        this.syscallManager = syscallManager;
        this.gpr_Buffer = new ArrayBuffer(32 * 4);
        this.gpr = new Int32Array(this.gpr_Buffer);
        this.gpr_f = new Float32Array(this.gpr_Buffer);
        this.temp = new Array(16);
        this.fpr_Buffer = new ArrayBuffer(32 * 4);
        this.fpr = new Float32Array(this.fpr_Buffer);
        this.fpr_i = new Int32Array(this.fpr_Buffer);
        this.vfpr_Buffer = new ArrayBuffer(128 * 4);
        this.vfpr = new Float32Array(this.vfpr_Buffer);
        this.vfpr_i = new Int32Array(this.vfpr_Buffer);
        this.vfprc = [0, 0, 0, 0xFF, 0, 0, 0, 0, 0x3F800000, 0x3F800000, 0x3F800000, 0x3F800000, 0x3F800000, 0x3F800000, 0x3F800000, 0x3F800000];
        this.vpfxs = new VfpuPrefixRead(this.vfprc, VFPU_CTRL.SPREFIX);
        this.vpfxt = new VfpuPrefixRead(this.vfprc, VFPU_CTRL.TPREFIX);
        this.vpfxd = new VfpuPrefixWrite(this.vfprc, VFPU_CTRL.DPREFIX);
        this.vector_vs = [0, 0, 0, 0];
        this.vector_vt = [0, 0, 0, 0];
        this.vector_vd = [0, 0, 0, 0];
        this.BRANCHFLAG = false;
        this.BRANCHPC = 0;
        this.PC = 0;
        this.IC = 0;
        this.LO = 0;
        this.HI = 0;
        this.thread = null;
        this.callstack = [];
        this.fcr31_rm = 0;
        this.fcr31_2_21 = 0;
        this.fcr31_25_7 = 0;
        this.fcr31_cc = false;
        this.fcr31_fs = false;
        this.fcr0 = 0x00003351;
        this.fcr0 = 0x00003351;
        this.fcr31 = 0x00000e00;
    }
    CpuState.prototype.setVfrCc = function (index, value) {
        if (value) {
            this.vfprc[VFPU_CTRL.CC] |= (1 << index);
        }
        else {
            this.vfprc[VFPU_CTRL.CC] &= ~(1 << index);
        }
    };
    CpuState.prototype.vrnds = function () { };
    CpuState.prototype.vrndi = function () {
        var v = 0;
        for (var n = 0; n < 4; n++) {
            v <<= 8;
            v |= (Math.round(Math.random() * 255) & 0xFF);
        }
        return v;
    };
    CpuState.prototype.vrndf1 = function () { return Math.random() * 2; };
    CpuState.prototype.vrndf2 = function () { return Math.random() * 4; };
    CpuState.prototype.getVfrCc = function (index) {
        return ((this.vfprc[VFPU_CTRL.CC] & (1 << index)) != 0);
    };
    CpuState.prototype.vcmp = function (cond, vsValues, vtValues) {
        var vectorSize = vsValues.length;
        this.loadVs_prefixed(vsValues);
        this.loadVt_prefixed(vtValues);
        var s = this.vector_vs;
        var t = this.vector_vt;
        var cc = 0;
        var or_val = 0;
        var and_val = 1;
        var affected_bits = (1 << 4) | (1 << 5);
        for (var i = 0; i < vectorSize; i++) {
            var c = false;
            switch (cond) {
                case VCondition.FL:
                    c = false;
                    break;
                case VCondition.EQ:
                    c = s[i] == t[i];
                    break;
                case VCondition.LT:
                    c = s[i] < t[i];
                    break;
                case VCondition.LE:
                    c = s[i] <= t[i];
                    break;
                case VCondition.TR:
                    c = true;
                    break;
                case VCondition.NE:
                    c = s[i] != t[i];
                    break;
                case VCondition.GE:
                    c = s[i] >= t[i];
                    break;
                case VCondition.GT:
                    c = s[i] > t[i];
                    break;
                case VCondition.EZ:
                    c = s[i] == 0.0 || s[i] == -0.0;
                    break;
                case VCondition.EN:
                    c = MathFloat.isnan(s[i]);
                    break;
                case VCondition.EI:
                    c = MathFloat.isinf(s[i]);
                    break;
                case VCondition.ES:
                    c = MathFloat.isnanorinf(s[i]);
                    break;
                case VCondition.NZ:
                    c = s[i] != 0;
                    break;
                case VCondition.NN:
                    c = !MathFloat.isnan(s[i]);
                    break;
                case VCondition.NI:
                    c = !MathFloat.isinf(s[i]);
                    break;
                case VCondition.NS:
                    c = !(MathFloat.isnanorinf(s[i]));
                    break;
            }
            var c_i = (c ? 1 : 0);
            cc |= (c_i << i);
            or_val |= c_i;
            and_val &= c_i;
            affected_bits |= 1 << i;
        }
        this.vfprc[VFPU_CTRL.CC] = (this.vfprc[VFPU_CTRL.CC] & ~affected_bits) | ((cc | (or_val << 4) | (and_val << 5)) & affected_bits);
        this.eatPrefixes();
    };
    CpuState.prototype.vcmovtf = function (register, _true, vdRegs, vsRegs) {
        var _this = this;
        var vectorSize = vdRegs.length;
        this.loadVs_prefixed(vsRegs.map(function (reg) { return _this.vfpr[reg]; }));
        this.loadVdRegs(vdRegs);
        var compare = _true ? 1 : 0;
        var cc = this.vfprc[VFPU_CTRL.CC];
        if (register < 6) {
            if (((cc >> register) & 1) == compare) {
                for (var n = 0; n < vectorSize; n++) {
                    this.vector_vd[n] = this.vector_vs[n];
                }
            }
        }
        if (register == 6) {
            for (var n = 0; n < vectorSize; n++) {
                if (((cc >> n) & 1) == compare) {
                    this.vector_vd[n] = this.vector_vs[n];
                }
            }
        }
        else {
        }
        this.storeVdRegsWithPrefix(vdRegs);
    };
    CpuState.prototype.setVpfxt = function (value) { this.vpfxt.setInfo(value); };
    CpuState.prototype.setVpfxs = function (value) { this.vpfxs.setInfo(value); };
    CpuState.prototype.setVpfxd = function (value) { this.vpfxd.setInfo(value); };
    Object.defineProperty(CpuState.prototype, "vfpumatrix0", {
        get: function () { return this.getVfpumatrix(0); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "vfpumatrix1", {
        get: function () { return this.getVfpumatrix(1); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "vfpumatrix2", {
        get: function () { return this.getVfpumatrix(2); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "vfpumatrix3", {
        get: function () { return this.getVfpumatrix(3); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "vfpumatrix4", {
        get: function () { return this.getVfpumatrix(4); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "vfpumatrix5", {
        get: function () { return this.getVfpumatrix(5); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "vfpumatrix6", {
        get: function () { return this.getVfpumatrix(6); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "vfpumatrix7", {
        get: function () { return this.getVfpumatrix(7); },
        enumerable: true,
        configurable: true
    });
    CpuState.prototype.eatPrefixes = function () {
        this.vpfxd.eat();
        this.vpfxt.eat();
        this.vpfxs.eat();
    };
    CpuState.prototype.getVfpumatrix = function (index) {
        var values = [];
        for (var r = 0; r < 4; r++) {
            for (var c = 0; c < 4; c++) {
                values.push(this.vfpr[r * 32 + index * 4 + c]);
            }
        }
        return values;
    };
    CpuState.prototype.loadVdRegs = function (regs) {
        for (var n = 0; n < regs.length; n++) {
            this.vector_vd[n] = this.vfpr[regs[n]];
        }
    };
    CpuState.prototype.storeVdRegsWithPrefix = function (regs) {
        this.vpfxd.storeTransformedValues(this.vfpr, regs, this.vector_vd);
        this.vpfxd.eat();
        this.storeVdRegs(regs);
    };
    CpuState.prototype.storeVdRegsWithPrefix1 = function (regs) {
        this.vpfxd.storeTransformedValues(this.vfpr, regs, this.vector_vd);
        this.vpfxd.eat();
        this.storeVdRegs(regs);
    };
    CpuState.prototype.storeVdRegs = function (regs) {
        for (var n = 0; n < regs.length; n++)
            this.vfpr[regs[n]] = this.vector_vd[n];
    };
    CpuState.prototype.loadVs_prefixed = function (values) {
        this.vpfxs.transformValues(values, this.vector_vs);
        this.vpfxs.eat();
    };
    CpuState.prototype.loadVt_prefixed = function (values) {
        this.vpfxt.transformValues(values, this.vector_vt);
        this.vpfxt.eat();
    };
    CpuState.prototype.storeVd_prefixed = function (indices, values) {
        this.vpfxd.storeTransformedValues(this.vfpr, indices, values);
        this.vpfxd.eat();
    };
    CpuState.prototype.storeVd_prefixed_i = function (indices, values) {
        this.vpfxd.storeTransformedValues(this.vfpr_i, indices, values);
        this.vpfxd.eat();
    };
    CpuState.prototype._vt4444_step = function (i0, i1) {
        var o = 0;
        o |= ((i0 >> 4) & 15) << 0;
        o |= ((i0 >> 12) & 15) << 4;
        o |= ((i0 >> 20) & 15) << 8;
        o |= ((i0 >> 28) & 15) << 12;
        o |= ((i1 >> 4) & 15) << 16;
        o |= ((i1 >> 12) & 15) << 20;
        o |= ((i1 >> 20) & 15) << 24;
        o |= ((i1 >> 28) & 15) << 28;
        return o;
    };
    CpuState.prototype._vt5551_step = function (i0, i1) {
        var o = 0;
        o |= ((i0 >> 3) & 31) << 0;
        o |= ((i0 >> 11) & 31) << 5;
        o |= ((i0 >> 19) & 31) << 10;
        o |= ((i0 >> 31) & 1) << 15;
        o |= ((i1 >> 3) & 31) << 16;
        o |= ((i1 >> 11) & 31) << 21;
        o |= ((i1 >> 19) & 31) << 26;
        o |= ((i1 >> 31) & 1) << 31;
        return o;
    };
    CpuState.prototype._vt5650_step = function (i0, i1) {
        var o = 0;
        o |= ((i0 >> 3) & 31) << 0;
        o |= ((i0 >> 10) & 63) << 5;
        o |= ((i0 >> 19) & 31) << 11;
        o |= ((i1 >> 3) & 31) << 16;
        o |= ((i1 >> 10) & 63) << 21;
        o |= ((i1 >> 19) & 31) << 27;
        return o;
    };
    CpuState.prototype.svl_q = function (address, r) {
        var k = (3 - ((address >>> 2) & 3));
        address &= ~0xF;
        for (var n = k; n < 4; n++, address += 4)
            this.memory.writeInt32(address, this.vfpr_i[r[n]]);
    };
    CpuState.prototype.svr_q = function (address, r) {
        var k = (4 - ((address >>> 2) & 3));
        for (var n = 0; n < k; n++, address += 4)
            this.memory.writeInt32(address, this.vfpr_i[r[n]]);
    };
    CpuState.prototype.lvl_q = function (address, r) {
        var k = (3 - ((address >>> 2) & 3));
        address &= ~0xF;
        for (var n = k; n < 4; n++, address += 4)
            this.vfpr_i[r[n]] = this.memory.readInt32(address);
    };
    CpuState.prototype.lvr_q = function (address, r) {
        var k = (4 - ((address >>> 2) & 3));
        for (var n = 0; n < k; n++, address += 4)
            this.vfpr_i[r[n]] = this.memory.readInt32(address);
    };
    CpuState.prototype.storeFloats = function (address, values) {
        for (var n = 0; n < values.length; n++) {
            this.memory.writeFloat32(address + n * 4, values[n]);
        }
    };
    CpuState.prototype.vfpuStore = function (indices, values) { for (var n = 0; n < indices.length; n++)
        this.vfpr[indices[n]] = values[n]; };
    CpuState.prototype.vfpuStore_i = function (indices, values) { for (var n = 0; n < indices.length; n++)
        this.vfpr_i[indices[n]] = values[n]; };
    CpuState.prototype.vfpuSetMatrix = function (m, values) {
        this.vfpr[0] = 0;
        throw new Error("Not implemented vfpuSetMatrix!");
    };
    CpuState.prototype.preserveRegisters = function (callback) {
        var temp = new CpuState(this.memory, this.syscallManager);
        temp.copyRegistersFrom(this);
        try {
            callback();
        }
        finally {
            this.copyRegistersFrom(temp);
        }
    };
    CpuState.prototype.copyRegistersFrom = function (other) {
        this.PC = other.PC;
        this.IC = other.IC;
        this.LO = other.LO;
        this.HI = other.HI;
        for (var n = 0; n < 32; n++)
            this.gpr[n] = other.gpr[n];
        for (var n = 0; n < 32; n++)
            this.fpr[n] = other.fpr[n];
        for (var n = 0; n < 128; n++)
            this.vfpr[n] = other.vfpr[n];
        for (var n = 0; n < 8; n++)
            this.vfprc[n] = other.vfprc[n];
    };
    Object.defineProperty(CpuState.prototype, "V0", {
        get: function () { return this.gpr[2]; },
        set: function (value) { this.gpr[2] = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "V1", {
        get: function () { return this.gpr[3]; },
        set: function (value) { this.gpr[3] = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "K0", {
        get: function () { return this.gpr[26]; },
        set: function (value) { this.gpr[26] = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "GP", {
        get: function () { return this.gpr[28]; },
        set: function (value) { this.gpr[28] = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "SP", {
        get: function () { return this.gpr[29]; },
        set: function (value) { this.gpr[29] = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "FP", {
        get: function () { return this.gpr[30]; },
        set: function (value) { this.gpr[30] = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "RA", {
        get: function () { return this.gpr[31]; },
        set: function (value) { this.gpr[31] = value; },
        enumerable: true,
        configurable: true
    });
    CpuState.prototype.getRA = function () { return this.gpr[31]; };
    CpuState.prototype.setRA = function (value) { this.gpr[31] = value; };
    CpuState.prototype.callstackPush = function (PC) {
    };
    CpuState.prototype.callstackPop = function () {
    };
    CpuState.prototype.printCallstack = function (symbolLookup) {
        if (symbolLookup === void 0) { symbolLookup = null; }
        this.getCallstack().forEach(function (PC) {
            var line = sprintf("%08X", PC);
            if (symbolLookup) {
                line += sprintf(' : %s', symbolLookup.getSymbolAt(PC));
            }
            console.log(line);
        });
    };
    CpuState.prototype.getCallstack = function () {
        return this.callstack.slice(0);
    };
    CpuState.prototype.getPointerStream = function (address, size) {
        return this.memory.getPointerStream(address, size);
    };
    CpuState.prototype.getPointerU8Array = function (address, size) {
        return this.memory.getPointerU8Array(address, size);
    };
    Object.defineProperty(CpuState.prototype, "REGS", {
        get: function () {
            return sprintf('r1: %08X, r2: %08X, r3: %08X, r3: %08X', this.gpr[1], this.gpr[2], this.gpr[3], this.gpr[4]);
        },
        enumerable: true,
        configurable: true
    });
    CpuState.prototype._trace_state = function () {
        console.info(this);
        throw ('_trace_state');
    };
    Object.defineProperty(CpuState.prototype, "fcr31", {
        get: function () {
            var value = 0;
            value = BitUtils.insert(value, 0, 2, this.fcr31_rm);
            value = BitUtils.insert(value, 2, 21, this.fcr31_2_21);
            value = BitUtils.insert(value, 23, 1, this.fcr31_cc ? 1 : 0);
            value = BitUtils.insert(value, 24, 1, this.fcr31_fs ? 1 : 0);
            value = BitUtils.insert(value, 25, 7, this.fcr31_25_7);
            return value;
        },
        set: function (value) {
            this.fcr31_rm = BitUtils.extract(value, 0, 2);
            this.fcr31_2_21 = BitUtils.extract(value, 2, 21);
            this.fcr31_cc = (BitUtils.extract(value, 23, 1) != 0);
            this.fcr31_fs = (BitUtils.extract(value, 24, 1) != 0);
            this.fcr31_25_7 = BitUtils.extract(value, 25, 7);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "fcr0_rev", {
        get: function () { return BitUtils.extract(this.fcr0, 0, 8); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CpuState.prototype, "fcr0_imp", {
        get: function () { return BitUtils.extract(this.fcr0, 8, 24); },
        enumerable: true,
        configurable: true
    });
    CpuState.prototype._cfc1_impl = function (d, t) {
        switch (d) {
            case 0:
                this.gpr[t] = this.fcr0;
                break;
            case 31:
                this.gpr[t] = this.fcr31;
                break;
            default:
                this.gpr[t] = 0;
                break;
        }
    };
    CpuState.prototype._ctc1_impl = function (d, t) {
        switch (d) {
            case 31:
                this.fcr31 = t;
                break;
        }
    };
    CpuState.prototype._comp_impl = function (s, t, fc_unordererd, fc_equal, fc_less, fc_inv_qnan) {
        if (isNaN(s) || isNaN(t)) {
            this.fcr31_cc = fc_unordererd;
        }
        else {
            var equal = (fc_equal) && (s == t);
            var less = (fc_less) && (s < t);
            this.fcr31_cc = (less || equal);
        }
    };
    CpuState.prototype._cvt_w_s_impl = function (FS) {
        switch (this.fcr31_rm) {
            case 0: return MathFloat.rint(FS);
            case 1: return MathFloat.cast(FS);
            case 2: return MathFloat.ceil(FS);
            case 3: return MathFloat.floor(FS);
        }
        throw ("RM has an invalid value!!");
    };
    CpuState.prototype.cache = function (rs, type, offset) {
    };
    CpuState.prototype.syscall = function (id) { this.syscallManager.call(this, id); };
    CpuState.prototype.sb = function (value, address) { this.memory.writeInt8(address, value); };
    CpuState.prototype.sh = function (value, address) { this.memory.writeInt16(address, value); };
    CpuState.prototype.sw = function (value, address) { this.memory.writeInt32(address, value); };
    CpuState.prototype.swc1 = function (value, address) { this.memory.writeFloat32(address, value); };
    CpuState.prototype.lb = function (address) { return this.memory.readInt8(address); };
    CpuState.prototype.lbu = function (address) { return this.memory.readUInt8(address); };
    CpuState.prototype.lh = function (address) { return this.memory.readInt16(address); };
    CpuState.prototype.lhu = function (address) { return this.memory.readUInt16(address); };
    CpuState.prototype.lw = function (address) { return this.memory.readInt32(address); };
    CpuState.prototype.lwc1 = function (address) { return this.memory.readFloat32(address); };
    CpuState.prototype.min = function (a, b) { return ((a | 0) < (b | 0)) ? a : b; };
    CpuState.prototype.max = function (a, b) { return ((a | 0) > (b | 0)) ? a : b; };
    CpuState.prototype.slt = function (a, b) { return ((a | 0) < (b | 0)) ? 1 : 0; };
    CpuState.prototype.sltu = function (a, b) { return ((a >>> 0) < (b >>> 0)) ? 1 : 0; };
    CpuState.prototype.lwl = function (RS, Offset, ValueToWrite) {
        var Address = (RS + Offset);
        var AddressAlign = Address & 3;
        var Value = this.memory.readInt32(Address & ~3);
        return ((Value << CpuState.LwlShift[AddressAlign]) | (ValueToWrite & CpuState.LwlMask[AddressAlign]));
    };
    CpuState.prototype.lwr = function (RS, Offset, ValueToWrite) {
        var Address = (RS + Offset);
        var AddressAlign = Address & 3;
        var Value = this.memory.readInt32(Address & ~3);
        return ((Value >>> CpuState.LwrShift[AddressAlign]) | (ValueToWrite & CpuState.LwrMask[AddressAlign]));
    };
    CpuState.prototype.swl = function (RS, Offset, ValueToWrite) {
        var Address = (RS + Offset);
        var AddressAlign = Address & 3;
        var AddressPointer = Address & ~3;
        var WordToWrite = (ValueToWrite >>> CpuState.SwlShift[AddressAlign]) | (this.memory.readInt32(AddressPointer) & CpuState.SwlMask[AddressAlign]);
        this.memory.writeInt32(AddressPointer, WordToWrite);
    };
    CpuState.prototype.swr = function (RS, Offset, ValueToWrite) {
        var Address = (RS + Offset);
        var AddressAlign = Address & 3;
        var AddressPointer = Address & ~3;
        var WordToWrite = (ValueToWrite << CpuState.SwrShift[AddressAlign]) | (this.memory.readInt32(AddressPointer) & CpuState.SwrMask[AddressAlign]);
        this.memory.writeInt32(AddressPointer, WordToWrite);
    };
    CpuState.prototype.div = function (rs, rt) {
        rs |= 0;
        rt |= 0;
        this.LO = (rs / rt) | 0;
        this.HI = (rs % rt) | 0;
    };
    CpuState.prototype.divu = function (rs, rt) {
        rs >>>= 0;
        rt >>>= 0;
        this.LO = (rs / rt) | 0;
        this.HI = (rs % rt) | 0;
    };
    CpuState.prototype.mult = function (rs, rt) {
        Math.imul32_64(rs, rt, CpuState._mult_temp);
        this.LO = CpuState._mult_temp[0];
        this.HI = CpuState._mult_temp[1];
    };
    CpuState.prototype.madd = function (rs, rt) {
        var a64 = Integer64.fromInt(rs);
        var b64 = Integer64.fromInt(rt);
        var result = Integer64.fromBits(this.LO, this.HI).add(a64.multiply(b64));
        this.HI = result.high;
        this.LO = result.low;
    };
    CpuState.prototype.msub = function (rs, rt) {
        var a64 = Integer64.fromInt(rs);
        var b64 = Integer64.fromInt(rt);
        var result = Integer64.fromBits(this.LO, this.HI).sub(a64.multiply(b64));
        this.HI = result.high;
        this.LO = result.low;
    };
    CpuState.prototype.multu = function (rs, rt) {
        var info = Math.umul32_64(rs, rt, CpuState._mult_temp);
        this.LO = info[0];
        this.HI = info[1];
    };
    CpuState.prototype.maddu = function (rs, rt) {
        var a64 = Integer64.fromUnsignedInt(rs);
        var b64 = Integer64.fromUnsignedInt(rt);
        var result = Integer64.fromBits(this.LO, this.HI).add(a64.multiply(b64));
        this.HI = result.high;
        this.LO = result.low;
    };
    CpuState.prototype.msubu = function (rs, rt) {
        var a64 = Integer64.fromUnsignedInt(rs);
        var b64 = Integer64.fromUnsignedInt(rt);
        var result = Integer64.fromBits(this.LO, this.HI).sub(a64.multiply(b64));
        this.HI = result.high;
        this.LO = result.low;
    };
    CpuState.prototype.callPC = function (pc) {
        this.PC = pc;
        var ra = this.getRA();
        this.executor.executeUntilPCReachesWithoutCall(ra);
    };
    CpuState.prototype.callPCSafe = function (pc) {
        this.PC = pc;
        var ra = this.getRA();
        while (this.PC != ra) {
            try {
                this.executor.executeUntilPCReachesWithoutCall(ra);
            }
            catch (e) {
                if (!(e instanceof CpuBreakException)) {
                    console.error(e);
                    console.error(e['stack']);
                    throw (e);
                }
            }
        }
    };
    CpuState.prototype.break = function () { throw (new CpuBreakException()); };
    CpuState.LwrMask = [0x00000000, 0xFF000000, 0xFFFF0000, 0xFFFFFF00];
    CpuState.LwrShift = [0, 8, 16, 24];
    CpuState.LwlMask = [0x00FFFFFF, 0x0000FFFF, 0x000000FF, 0x00000000];
    CpuState.LwlShift = [24, 16, 8, 0];
    CpuState.SwlMask = [0xFFFFFF00, 0xFFFF0000, 0xFF000000, 0x00000000];
    CpuState.SwlShift = [24, 16, 8, 0];
    CpuState.SwrMask = [0x00000000, 0x000000FF, 0x0000FFFF, 0x00FFFFFF];
    CpuState.SwrShift = [0, 8, 16, 24];
    CpuState._mult_temp = [0, 0];
    return CpuState;
})();
exports.CpuState = CpuState;

},
"src/core/cpu/syscall": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var NativeFunction = (function () {
    function NativeFunction() {
    }
    return NativeFunction;
})();
exports.NativeFunction = NativeFunction;
var SyscallManager = (function () {
    function SyscallManager(context) {
        this.context = context;
        this.calls = {};
        this.lastId = 1;
    }
    SyscallManager.prototype.register = function (nativeFunction) {
        return this.registerWithId(this.lastId++, nativeFunction);
    };
    SyscallManager.prototype.registerWithId = function (id, nativeFunction) {
        this.calls[id] = nativeFunction;
        return id;
    };
    SyscallManager.prototype.call = function (state, id) {
        var nativeFunction = this.calls[id];
        if (!nativeFunction)
            throw (sprintf("Can't call syscall %s: 0x%06X", id));
        nativeFunction.call(this.context, state);
    };
    return SyscallManager;
})();
exports.SyscallManager = SyscallManager;

},
"src/core/display": function(module, exports, require) {
///<reference path="../global.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var memory = require('./memory');
var pixelformat = require('./pixelformat');
var _interrupt = require('./interrupt');
var PspInterrupts = _interrupt.PspInterrupts;
var Memory = memory.Memory;
var PixelFormat = pixelformat.PixelFormat;
var PixelConverter = pixelformat.PixelConverter;
var BasePspDisplay = (function () {
    function BasePspDisplay() {
        this.address = Memory.DEFAULT_FRAME_ADDRESS;
        this.bufferWidth = 512;
        this.pixelFormat = PixelFormat.RGBA_8888;
        this.sync = 1;
    }
    return BasePspDisplay;
})();
exports.BasePspDisplay = BasePspDisplay;
var DummyPspDisplay = (function (_super) {
    __extends(DummyPspDisplay, _super);
    function DummyPspDisplay() {
        _super.call(this);
        this.vblankCount = 0;
        this.hcountTotal = 0;
        this.secondsLeftForVblank = 0.1;
        this.secondsLeftForVblankStart = 0.1;
        this.vblank = new Signal();
    }
    DummyPspDisplay.prototype.updateTime = function () {
    };
    DummyPspDisplay.prototype.waitVblankAsync = function (waiter) {
        return waiter.delayMicrosecondsAsync(20000, true);
    };
    DummyPspDisplay.prototype.waitVblankStartAsync = function (waiter) {
        return waiter.delayMicrosecondsAsync(20000, true);
    };
    DummyPspDisplay.prototype.setEnabledDisplay = function (enable) {
    };
    DummyPspDisplay.prototype.startAsync = function () {
        return Promise2.resolve();
    };
    DummyPspDisplay.prototype.stopAsync = function () {
        return Promise2.resolve();
    };
    return DummyPspDisplay;
})(BasePspDisplay);
exports.DummyPspDisplay = DummyPspDisplay;
var PspDisplay = (function (_super) {
    __extends(PspDisplay, _super);
    function PspDisplay(memory, interruptManager, canvas, webglcanvas) {
        _super.call(this);
        this.memory = memory;
        this.interruptManager = interruptManager;
        this.canvas = canvas;
        this.webglcanvas = webglcanvas;
        this.vblank = new Signal();
        this.interval = -1;
        this.enabled = true;
        this._hcount = 0;
        this.hcountTotal = 0;
        this.hcountCurrent = 0;
        this.vblankCount = 0;
        this.isInVblank = false;
        this.rowsLeftForVblank = 0;
        this.secondsLeftForVblank = 0;
        this.rowsLeftForVblankStart = 0;
        this.secondsLeftForVblankStart = 0;
        this.mustWaitVBlank = true;
        this.lastTimeVblank = 0;
        if (this.canvas) {
            this.context = this.canvas.getContext('2d');
            this.imageData = this.context.createImageData(512, 272);
            this.setEnabledDisplay(true);
        }
        else {
            this.context = null;
            this.setEnabledDisplay(false);
        }
    }
    PspDisplay.prototype.getCurrentMs = function () {
        return performance.now();
    };
    PspDisplay.prototype.updateTime = function () {
        this.currentMs = this.getCurrentMs();
        this.elapsedSeconds = (this.currentMs - this.startTime) / 1000;
        this.hcountTotal = (this.elapsedSeconds * PspDisplay.HORIZONTAL_SYNC_HZ) | 0;
        this.hcountCurrent = (((this.elapsedSeconds % 1.00002) * PspDisplay.HORIZONTAL_SYNC_HZ) | 0) % PspDisplay.NUMBER_OF_ROWS;
        this.vblankCount = (this.elapsedSeconds * PspDisplay.VERTICAL_SYNC_HZ) | 0;
        if (this.hcountCurrent >= PspDisplay.VSYNC_ROW) {
            this.isInVblank = true;
            this.rowsLeftForVblank = 0;
            this.rowsLeftForVblankStart = (PspDisplay.NUMBER_OF_ROWS - this.hcountCurrent) + PspDisplay.VSYNC_ROW;
        }
        else {
            this.isInVblank = false;
            this.rowsLeftForVblank = PspDisplay.VSYNC_ROW - this.hcountCurrent;
            this.rowsLeftForVblankStart = this.rowsLeftForVblank;
        }
        this.secondsLeftForVblank = this.rowsLeftForVblank * PspDisplay.HORIZONTAL_SECONDS;
        this.secondsLeftForVblankStart = this.rowsLeftForVblankStart * PspDisplay.HORIZONTAL_SECONDS;
    };
    PspDisplay.prototype.update = function () {
        if (!this.context || !this.imageData)
            return;
        if (!this.enabled)
            return;
        var count = 512 * 272;
        var imageData = this.imageData;
        var w8 = imageData.data;
        var baseAddress = this.address & 0x0FFFFFFF;
        PixelConverter.decode(this.pixelFormat, this.memory.getPointerU8Array(baseAddress), w8, 0, count, false);
        this.context.putImageData(imageData, 0, 0);
    };
    PspDisplay.prototype.setEnabledDisplay = function (enable) {
        this.enabled = enable;
        if (this.canvas)
            this.canvas.style.display = enable ? 'block' : 'none';
        if (this.webglcanvas)
            this.webglcanvas.style.display = !enable ? 'block' : 'none';
    };
    PspDisplay.prototype.startAsync = function () {
        var _this = this;
        this.startTime = this.getCurrentMs();
        this.updateTime();
        this.interval = setInterval(function () {
            _this.updateTime();
            _this.vblankCount++;
            _this.update();
            _this.vblank.dispatch(_this.vblankCount);
            _this.interruptManager.interrupt(PspInterrupts.PSP_VBLANK_INT);
        }, 1000 / PspDisplay.VERTICAL_SYNC_HZ);
        return Promise2.resolve();
    };
    PspDisplay.prototype.stopAsync = function () {
        clearInterval(this.interval);
        this.interval = -1;
        return Promise2.resolve();
    };
    PspDisplay.prototype.checkVblankThrottle = function () {
        var currentTime = performance.now();
        if ((currentTime - this.lastTimeVblank) >= (PspDisplay.VERTICAL_SECONDS * 1000)) {
            this.lastTimeVblank = currentTime;
            return true;
        }
        return false;
    };
    PspDisplay.prototype.waitVblankAsync = function (waiter) {
        this.updateTime();
        if (!this.mustWaitVBlank)
            return Promise2.resolve(0);
        if (this.checkVblankThrottle())
            return Promise2.resolve(0);
        return waiter.delayMicrosecondsAsync(this.secondsLeftForVblank * 1000000, true);
    };
    PspDisplay.prototype.waitVblankStartAsync = function (waiter) {
        this.updateTime();
        if (!this.mustWaitVBlank)
            return Promise2.resolve(0);
        if (this.checkVblankThrottle())
            return Promise2.resolve(0);
        return waiter.delayMicrosecondsAsync(this.secondsLeftForVblankStart * 1000000, true);
    };
    PspDisplay.PROCESSED_PIXELS_PER_SECOND = 9000000;
    PspDisplay.CYCLES_PER_PIXEL = 1;
    PspDisplay.PIXELS_IN_A_ROW = 525;
    PspDisplay.VSYNC_ROW = 272;
    PspDisplay.NUMBER_OF_ROWS = 286;
    PspDisplay.HCOUNT_PER_VBLANK = 285.72;
    PspDisplay.HORIZONTAL_SYNC_HZ = (PspDisplay.PROCESSED_PIXELS_PER_SECOND * PspDisplay.CYCLES_PER_PIXEL) / PspDisplay.PIXELS_IN_A_ROW;
    PspDisplay.HORIZONTAL_SECONDS = 1 / PspDisplay.HORIZONTAL_SYNC_HZ;
    PspDisplay.VERTICAL_SYNC_HZ = PspDisplay.HORIZONTAL_SYNC_HZ / PspDisplay.HCOUNT_PER_VBLANK;
    PspDisplay.VERTICAL_SECONDS = 1 / PspDisplay.VERTICAL_SYNC_HZ;
    return PspDisplay;
})(BasePspDisplay);
exports.PspDisplay = PspDisplay;

},
"src/core/gpu": function(module, exports, require) {
///<reference path="../global.d.ts" />
var _gpu = require('./gpu/gpu');
_gpu.PspGpu;
var _state = require('./gpu/state');
_state.AlphaTest;
var _vertex = require('./gpu/vertex');
_vertex.VertexReader;
exports.PspGpuCallback = _gpu.PspGpuCallback;
_gpu.PspGpuCallback;
exports.PspGpu = _gpu.PspGpu;
exports.SyncType = _state.SyncType;
exports.DisplayListStatus = _state.DisplayListStatus;
exports.VertexReader = _vertex.VertexReader;
exports.VertexState = _state.VertexState;
exports.VertexReaderFactory = _vertex.VertexReaderFactory;

},
"src/core/gpu/driver": function(module, exports, require) {
///<reference path="../../global.d.ts" />

},
"src/core/gpu/gpu": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _memory = require('../memory');
var _instructions = require('./instructions');
var _state = require('./state');
var _vertex = require('./vertex');
var _cpu = require('../cpu');
_cpu.CpuState;
var DisplayListStatus = _state.DisplayListStatus;
var Memory = _memory.Memory;
var GpuOpCodes = _instructions.GpuOpCodes;
var WebGlPspDrawDriver = require('./webgl/driver');
var DummyDrawDriver = require('./webgl/driver_dummy');
var vertexBuffer = new _vertex.VertexBuffer();
var singleCallTest = false;
function bool1(p) { return p != 0; }
function param1(p, offset) { return (p >> offset) & 0x1; }
function param2(p, offset) { return (p >> offset) & 0x3; }
function param3(p, offset) { return (p >> offset) & 0x7; }
function param4(p, offset) { return (p >> offset) & 0xF; }
function param5(p, offset) { return (p >> offset) & 0x1F; }
function param8(p, offset) { return (p >> offset) & 0xFF; }
function param10(p, offset) { return (p >> offset) & 0x3FF; }
function param16(p, offset) { return (p >> offset) & 0xFFFF; }
function float1(p) { return MathFloat.reinterpretIntAsFloat(p << 8); }
var PspGpuExecutor = (function () {
    function PspGpuExecutor() {
        this.table = new Array(0x100);
        for (var n = 0; n < 0x100; n++) {
            this.table[n] = null;
            var func = this[GpuOpCodes[n]];
            this.table[n] = func ? func.bind(this) : this.UNKNOWN.bind(this);
        }
    }
    PspGpuExecutor.prototype.setList = function (list) {
        this.list = list;
        this.state = list.state;
    };
    PspGpuExecutor.prototype.NOP = function (p) { };
    PspGpuExecutor.prototype.DUMMY = function (p) { };
    PspGpuExecutor.prototype.IADDR = function (p) { this.state.indexAddress = p; };
    PspGpuExecutor.prototype.OFFSETADDR = function (p) { this.state.baseOffset = (p << 8); };
    PspGpuExecutor.prototype.FRAMEBUFPTR = function (p) { this.state.frameBuffer.lowAddress = p; };
    PspGpuExecutor.prototype.BASE = function (p) { this.state.baseAddress = ((p << 8) & 0xff000000); };
    PspGpuExecutor.prototype.JUMP = function (p) {
        this.list.jumpRelativeOffset(p & ~3);
    };
    PspGpuExecutor.prototype.CALL = function (p, current) {
        this.list.callstack[this.list.callstackIndex++] = ((current << 2) + 4);
        this.list.callstack[this.list.callstackIndex++] = (((this.state.baseOffset >>> 2) & Memory.MASK));
        this.list.jumpRelativeOffset(p & ~3);
    };
    PspGpuExecutor.prototype.RET = function (p) {
        if (this.list.callstackIndex > 0 && this.list.callstackIndex < 1024) {
            this.list.state.baseOffset = this.list.callstack[--this.list.callstackIndex];
            this.list.jumpAbsolute(this.list.callstack[--this.list.callstackIndex]);
        }
        else {
            console.info('gpu callstack empty or overflow');
        }
    };
    PspGpuExecutor.prototype.VERTEXTYPE = function (p) {
        if (this.list.state.vertex.getValue() == p)
            return;
        this.list.finishPrimBatch();
        this.list.state.vertex.setValue(p);
    };
    PspGpuExecutor.prototype.VADDR = function (p) {
        this.list.state.vertex.address = p;
    };
    PspGpuExecutor.prototype.FINISH = function (p) {
        this.list.finish();
        var callback = this.list.gpu.callbacks.get(this.list.callbackId);
        if (callback && callback.cpuState && callback.finishFunction) {
            this.list.cpuExecutor.execute(callback.cpuState, callback.finishFunction, [p, callback.finishArgument]);
        }
    };
    PspGpuExecutor.prototype.SIGNAL = function (p) {
        console.warn('Not implemented: GPU SIGNAL');
    };
    PspGpuExecutor.prototype.END = function (p) {
        this.invalidatePrim();
        this.list.gpu.driver.end();
        this.list.complete();
        return true;
    };
    PspGpuExecutor.prototype.PROJMATRIXNUMBER = function (p) {
        this.state.projectionMatrix.reset(p);
    };
    PspGpuExecutor.prototype.PROJMATRIXDATA = function (p) {
        var v = float1(p);
        if (this.state.projectionMatrix.check(v))
            return;
        this.invalidatePrim();
        this.state.projectionMatrix.put(v);
    };
    PspGpuExecutor.prototype.VIEWMATRIXNUMBER = function (p) {
        this.state.viewMatrix.reset(p);
    };
    PspGpuExecutor.prototype.VIEWMATRIXDATA = function (p) {
        var v = float1(p);
        if (this.state.viewMatrix.check(v))
            return;
        this.invalidatePrim();
        this.state.viewMatrix.put(v);
    };
    PspGpuExecutor.prototype.WORLDMATRIXNUMBER = function (p) {
        this.state.worldMatrix.reset(p);
    };
    PspGpuExecutor.prototype.WORLDMATRIXDATA = function (p) {
        var v = float1(p);
        if (this.state.worldMatrix.check(v))
            return;
        this.invalidatePrim();
        this.state.worldMatrix.put(v);
    };
    PspGpuExecutor.prototype.BONEMATRIXNUMBER = function (p) {
        this.state.skinning.setCurrentBoneIndex(p);
    };
    PspGpuExecutor.prototype.BONEMATRIXDATA = function (p) {
        var v = float1(p);
        if (this.state.skinning.check(v))
            return;
        this.invalidatePrim();
        this.state.skinning.write(v);
    };
    PspGpuExecutor.prototype.TGENMATRIXNUMBER = function (p) {
        this.state.texture.matrix.reset(p);
    };
    PspGpuExecutor.prototype.TGENMATRIXDATA = function (p) {
        var v = float1(p);
        if (this.state.texture.matrix.check(v))
            return;
        this.invalidatePrim();
        this.state.texture.matrix.put(v);
    };
    PspGpuExecutor.prototype.TEXOFFSETU = function (p) {
        var v = float1(p);
        if (this.state.texture.offsetU == v)
            return;
        this.invalidatePrim();
        this.state.texture.offsetU = v;
    };
    PspGpuExecutor.prototype.TEXOFFSETV = function (p) {
        var v = float1(p);
        if (this.state.texture.offsetV == v)
            return;
        this.invalidatePrim();
        this.state.texture.offsetV = float1(p);
    };
    PspGpuExecutor.prototype.TEXSCALEU = function (p) {
        var v = float1(p);
        if (this.state.texture.scaleU == v)
            return;
        this.invalidatePrim();
        this.state.texture.scaleU = float1(p);
    };
    PspGpuExecutor.prototype.TEXSCALEV = function (p) {
        var v = float1(p);
        if (this.state.texture.scaleV == v)
            return;
        this.invalidatePrim();
        this.state.texture.scaleV = float1(p);
    };
    PspGpuExecutor.prototype.TBIAS = function (p) {
        if (this.state.texture._tbias == p)
            return;
        this.invalidatePrim();
        this.state.texture._tbias = p;
        this.state.texture.levelMode = param8(p, 0);
        this.state.texture.mipmapBias = param8(p, 16) / 16;
    };
    PspGpuExecutor.prototype.TSLOPE = function (p) {
        var v = float1(p);
        if (this.state.texture.slopeLevel == v)
            return;
        this.invalidatePrim();
        this.state.texture.slopeLevel = v;
    };
    PspGpuExecutor.prototype.FCOL = function (p) {
        if (this.state.fog._color == p)
            return;
        this.invalidatePrim();
        this.state.fog._color = p;
        this.state.fog.color.setRGB(p);
    };
    PspGpuExecutor.prototype.FFAR = function (p) {
        var v = float1(p);
        if (this.state.fog.far == v)
            return;
        this.invalidatePrim();
        this.state.fog.far = v;
    };
    PspGpuExecutor.prototype.FDIST = function (p) {
        var v = float1(p);
        if (this.state.fog.dist == v)
            return;
        this.invalidatePrim();
        this.state.fog.dist = v;
    };
    PspGpuExecutor.prototype.invalidatePrim = function () {
        this.list.finishPrimBatch();
    };
    PspGpuExecutor.prototype.FOGENABLE = function (p) { if (this.state.fog.enabled != bool1(p)) {
        this.invalidatePrim();
        this.state.fog.enabled = bool1(p);
    } };
    PspGpuExecutor.prototype.VIEWPORTX1 = function (p) { if (this.state.viewport.width != float1(p)) {
        this.invalidatePrim();
        this.state.viewport.width = float1(p);
    } };
    PspGpuExecutor.prototype.VIEWPORTY1 = function (p) { if (this.state.viewport.height != float1(p)) {
        this.invalidatePrim();
        this.state.viewport.height = float1(p);
    } };
    PspGpuExecutor.prototype.VIEWPORTZ1 = function (p) { if (this.state.viewport.depth != float1(p)) {
        this.invalidatePrim();
        this.state.viewport.depth = float1(p);
    } };
    PspGpuExecutor.prototype.VIEWPORTX2 = function (p) { if (this.state.viewport.x == float1(p))
        return; this.invalidatePrim(); this.state.viewport.x = float1(p); };
    PspGpuExecutor.prototype.VIEWPORTY2 = function (p) { if (this.state.viewport.y == float1(p))
        return; this.invalidatePrim(); this.state.viewport.y = float1(p); };
    PspGpuExecutor.prototype.VIEWPORTZ2 = function (p) { if (this.state.viewport.z == float1(p))
        return; this.invalidatePrim(); this.state.viewport.z = float1(p); };
    PspGpuExecutor.prototype.OFFSETX = function (p) { if (this.state.offset.x == param4(p, 0))
        return; this.invalidatePrim(); this.state.offset.x = param4(p, 0); };
    PspGpuExecutor.prototype.OFFSETY = function (p) { if (this.state.offset.y == param4(p, 0))
        return; this.invalidatePrim(); this.state.offset.y = param4(p, 0); };
    PspGpuExecutor.prototype.REGION1 = function (p) {
        if (this.state.region._xy1 == p)
            return;
        this.invalidatePrim();
        this.state.region._xy1 = p;
        this.state.region.x1 = param10(p, 0);
        this.state.region.y1 = param10(p, 10);
    };
    PspGpuExecutor.prototype.REGION2 = function (p) {
        if (this.state.region._xy2 == p)
            return;
        this.invalidatePrim();
        this.state.region._xy2 = p;
        this.state.region.x2 = param10(p, 0);
        this.state.region.y2 = param10(p, 10);
    };
    PspGpuExecutor.prototype.CLIPENABLE = function (p) {
        if (this.state.clipPlane.enabled == bool1(p))
            return;
        this.invalidatePrim();
        this.state.clipPlane.enabled = bool1(p);
        this.state.clipPlane.updated = false;
    };
    PspGpuExecutor.prototype.SCISSOR1 = function (p) {
        if (this.state.clipPlane._scissorLeftTop == p)
            return;
        this.invalidatePrim();
        this.state.clipPlane._scissorLeftTop = p;
        this.state.clipPlane.scissor.left = param10(p, 0);
        this.state.clipPlane.scissor.top = param10(p, 10);
        this.state.clipPlane.updated = false;
    };
    PspGpuExecutor.prototype.SCISSOR2 = function (p) {
        if (this.state.clipPlane._scissorRightBottom == p)
            return;
        this.invalidatePrim();
        this.state.clipPlane._scissorRightBottom = p;
        this.state.clipPlane.scissor.right = param10(p, 0);
        this.state.clipPlane.scissor.bottom = param10(p, 10);
        this.state.clipPlane.updated = false;
    };
    PspGpuExecutor.prototype.TMODE = function (p) {
        if (this.state.texture.tmode == p)
            return;
        this.invalidatePrim();
        this.state.texture.tmode = p;
        this.state.texture.swizzled = param8(p, 0) != 0;
        this.state.texture.mipmapShareClut = param8(p, 8) != 0;
        this.state.texture.mipmapMaxLevel = param8(p, 16);
    };
    PspGpuExecutor.prototype.TFLT = function (p) {
        if (this.state.texture.tflt == p)
            return;
        this.invalidatePrim();
        this.state.texture.tflt = p;
        this.state.texture.filterMinification = param8(p, 0);
        this.state.texture.filterMagnification = param8(p, 8);
    };
    PspGpuExecutor.prototype.TWRAP = function (p) {
        if (this.state.texture.twrap == p)
            return;
        this.invalidatePrim();
        this.state.texture.twrap = p;
        this.state.texture.wrapU = param8(p, 0);
        this.state.texture.wrapV = param8(p, 8);
    };
    PspGpuExecutor.prototype.TEXTUREMAPENABLE = function (p) {
        var v = bool1(p);
        if (this.state.texture.enabled == v)
            return;
        this.invalidatePrim();
        this.state.texture.enabled = v;
    };
    PspGpuExecutor.prototype.TMAP = function (p) {
        if (this.state.texture.tmap == p)
            return;
        this.invalidatePrim();
        this.state.texture.tmap = p;
        this.state.texture.textureMapMode = param8(p, 0);
        this.state.texture.textureProjectionMapMode = param8(p, 8);
        this.state.vertex.textureComponentCount = this.state.texture.getTextureComponentsCount();
    };
    PspGpuExecutor.prototype.TSIZE_ = function (p, index) {
        var mipMap = this.state.texture.mipmaps[index];
        if (mipMap.tsizeValue == p)
            return;
        this.invalidatePrim();
        var widthExp = param4(p, 0);
        var heightExp = param4(p, 8);
        var unknownFlag = param1(p, 15);
        widthExp = Math.min(widthExp, 9);
        heightExp = Math.min(heightExp, 9);
        mipMap.tsizeValue = p;
        mipMap.textureWidth = 1 << widthExp;
        mipMap.textureHeight = 1 << heightExp;
    };
    PspGpuExecutor.prototype.TEXADDR_ = function (p, index) {
        var mipMap = this.state.texture.mipmaps[index];
        var address = (mipMap.address & 0xFF000000) | (p & 0x00FFFFFF);
        if (mipMap.address == address)
            return;
        this.invalidatePrim();
        mipMap.address = address;
    };
    PspGpuExecutor.prototype.TEXBUFWIDTH_ = function (p, index) {
        var mipMap = this.state.texture.mipmaps[index];
        var bufferWidth = param16(p, 0);
        var address = (mipMap.address & 0x00FFFFFF) | ((param8(p, 16) << 24) & 0xFF000000);
        if ((mipMap.bufferWidth == bufferWidth) && (mipMap.address == address))
            return;
        this.invalidatePrim();
        mipMap.bufferWidth = bufferWidth;
        mipMap.address = address;
    };
    PspGpuExecutor.prototype.SOP = function (p) {
        if (this.state.stencil.sop == p)
            return;
        this.invalidatePrim();
        this.state.stencil.sop = p;
        this.state.stencil.fail = param8(p, 0);
        this.state.stencil.zfail = param8(p, 8);
        this.state.stencil.zpass = param8(p, 16);
    };
    PspGpuExecutor.prototype.STST = function (p) {
        if (this.state.stencil.stst == p)
            return;
        this.invalidatePrim();
        this.state.stencil.stst = p;
        this.state.stencil.func = param8(p, 0);
        this.state.stencil.funcRef = param8(p, 8);
        this.state.stencil.funcMask = param8(p, 16);
    };
    PspGpuExecutor.prototype.ZTST = function (p) {
        var v = param8(p, 0);
        if (this.state.depthTest.func == v)
            return;
        this.invalidatePrim();
        this.state.depthTest.func = v;
        this.state.depthTest.updated = false;
    };
    PspGpuExecutor.prototype.ZTESTENABLE = function (p) {
        var v = bool1(p);
        if (this.state.depthTest.enabled == v)
            return;
        this.invalidatePrim();
        this.state.depthTest.enabled = v;
        this.state.depthTest.updated = false;
    };
    PspGpuExecutor.prototype.ZMSK = function (p) {
        var v = param16(p, 0);
        if (this.state.depthTest.mask == v)
            return;
        this.invalidatePrim();
        this.state.depthTest.mask = v;
        this.state.depthTest.updated = false;
    };
    PspGpuExecutor.prototype.MINZ = function (p) {
        var v = (p & 0xFFFF) / 65536;
        if (this.state.depthTest.rangeFar == v)
            return;
        this.invalidatePrim();
        this.state.depthTest.rangeFar = v;
        this.state.depthTest.updated = false;
    };
    PspGpuExecutor.prototype.MAXZ = function (p) {
        var v = (p & 0xFFFF) / 65536;
        if (this.state.depthTest.rangeNear == v)
            return;
        this.invalidatePrim();
        this.state.depthTest.rangeNear = v;
        this.state.depthTest.updated = false;
    };
    PspGpuExecutor.prototype.FRAMEBUFWIDTH = function (p) {
        if (this.state.frameBuffer._widthHighAddress == p)
            return;
        this.invalidatePrim();
        this.state.frameBuffer._widthHighAddress = p;
        this.state.frameBuffer.width = param16(p, 0);
        this.state.frameBuffer.highAddress = param8(p, 16);
    };
    PspGpuExecutor.prototype.SHADEMODE = function (p) {
        if (this.state.shadeModel == param16(p, 0))
            return;
        this.invalidatePrim();
        this.state.shadeModel = param16(p, 0);
    };
    PspGpuExecutor.prototype.LIGHTINGENABLE = function (p) {
        if (this.state.lightning.enabled == bool1(p))
            return;
        this.invalidatePrim();
        this.state.lightning.enabled = bool1(p);
    };
    PspGpuExecutor.prototype.ALPHATESTENABLE = function (p) {
        if (this.state.alphaTest.enabled == bool1(p))
            return;
        this.invalidatePrim();
        this.state.alphaTest.enabled = bool1(p);
    };
    PspGpuExecutor.prototype.ATST = function (p) {
        if (this.state.alphaTest._atst == p)
            return;
        this.invalidatePrim();
        this.state.alphaTest._atst = p;
        this.state.alphaTest.func = param8(p, 0);
        this.state.alphaTest.value = param8(p, 8);
        this.state.alphaTest.mask = param8(p, 16);
    };
    PspGpuExecutor.prototype.ALPHABLENDENABLE = function (p) {
        if (this.state.blending.enabled == bool1(p))
            return;
        this.invalidatePrim();
        this.state.blending.enabled = bool1(p);
        this.state.blending.updated = false;
    };
    PspGpuExecutor.prototype.ALPHA = function (p) {
        if (this.state.blending._alpha == p)
            return;
        this.invalidatePrim();
        this.state.blending._alpha = p;
        this.state.blending.functionSource = param4(p, 0);
        this.state.blending.functionDestination = param4(p, 4);
        this.state.blending.equation = param4(p, 8);
        this.state.blending.updated = false;
    };
    PspGpuExecutor.prototype.REVERSENORMAL = function (p) {
        if (this.state.vertex.reversedNormal == bool1(p))
            return;
        this.invalidatePrim();
        this.state.vertex.reversedNormal = bool1(p);
    };
    PspGpuExecutor.prototype.PATCHCULLENABLE = function (p) {
        if (this.state.patchCullingState.enabled == bool1(p))
            return;
        this.invalidatePrim();
        this.state.patchCullingState.enabled = bool1(p);
    };
    PspGpuExecutor.prototype.PATCHFACING = function (p) {
        if (this.state.patchCullingState.faceFlag == bool1(p))
            return;
        this.invalidatePrim();
        this.state.patchCullingState.faceFlag = bool1(p);
    };
    PspGpuExecutor.prototype.ANTIALIASENABLE = function (p) {
        if (this.state.lineSmoothState.enabled == bool1(p))
            return;
        this.invalidatePrim();
        this.state.lineSmoothState.enabled = bool1(p);
    };
    PspGpuExecutor.prototype.TEXTURE_ENV_MAP_MATRIX = function (p) {
        if (this.state.texture._shadeUV == p)
            return;
        this.invalidatePrim();
        this.state.texture._shadeUV = p;
        this.state.texture.shadeU = param2(p, 0);
        this.state.texture.shadeV = param2(p, 8);
    };
    PspGpuExecutor.prototype.TEC = function (p) {
        if (this.state.texture._envColor == p)
            return;
        this.invalidatePrim();
        this.state.texture._envColor = p;
        this.state.texture.envColor.r = BitUtils.extractScalei(p, 0, 8, 1);
        this.state.texture.envColor.g = BitUtils.extractScalei(p, 8, 8, 1);
        this.state.texture.envColor.b = BitUtils.extractScalei(p, 16, 8, 1);
    };
    PspGpuExecutor.prototype.TFUNC = function (p) {
        if (this.state.texture._tfunc == p)
            return;
        this.invalidatePrim();
        this.state.texture._tfunc = p;
        this.state.texture.effect = param8(p, 0);
        this.state.texture.colorComponent = param8(p, 8);
        this.state.texture.fragment2X = (param8(p, 16) != 0);
    };
    PspGpuExecutor.prototype.TFLUSH = function (p) {
        this.invalidatePrim();
        this.list.drawDriver.textureFlush(this.state);
    };
    PspGpuExecutor.prototype.TSYNC = function (p) {
        this.list.drawDriver.textureSync(this.state);
    };
    PspGpuExecutor.prototype.TPSM = function (p) {
        if (this.state.texture.pixelFormat == param4(p, 0))
            return;
        this.invalidatePrim();
        this.state.texture.pixelFormat = param4(p, 0);
    };
    PspGpuExecutor.prototype.PSM = function (p) {
        if (this.state.drawPixelFormat == param4(p, 0))
            return;
        this.invalidatePrim();
        this.state.drawPixelFormat = param4(p, 0);
    };
    PspGpuExecutor.prototype.PMSKC = function (p) {
        if (this.state.blending._colorMask == p)
            return;
        this.invalidatePrim();
        this.state.blending._colorMask = p;
        this.state.blending.colorMask.r = param8(p, 0);
        this.state.blending.colorMask.g = param8(p, 8);
        this.state.blending.colorMask.b = param8(p, 16);
        this.state.blending.updated = false;
    };
    PspGpuExecutor.prototype.PMSKA = function (p) {
        if (this.state.blending._colorMaskA == p)
            return;
        this.invalidatePrim();
        this.state.blending._colorMaskA = p;
        this.state.blending.colorMask.a = param8(p, 0);
        this.state.blending.updated = false;
    };
    PspGpuExecutor.prototype.MATERIALSPECULARCOEF = function (p) {
        var v = float1(p);
        if (this.state.lightning.specularPower == v)
            return;
        this.invalidatePrim();
        this.state.lightning.specularPower = v;
    };
    PspGpuExecutor.prototype.MATERIALAMBIENT = function (p) {
        if (this.state._ambientModelColor == p)
            return;
        this.invalidatePrim();
        this.state._ambientModelColor = p;
        this.state.ambientModelColor.r = BitUtils.extractScalef(p, 0, 8, 1);
        this.state.ambientModelColor.g = BitUtils.extractScalef(p, 8, 8, 1);
        this.state.ambientModelColor.b = BitUtils.extractScalef(p, 16, 8, 1);
        this.state.ambientModelColor.a = 1;
    };
    PspGpuExecutor.prototype.MATERIALALPHA = function (p) {
        if (this.state._ambientModelColorAlpha == p)
            return;
        this.invalidatePrim();
        this.state._ambientModelColorAlpha = p;
        this.state.ambientModelColor.a = BitUtils.extractScalef(p, 0, 8, 1);
    };
    PspGpuExecutor.prototype.AMBIENTCOLOR = function (p) {
        if (this.state.lightning._ambientLightColor == p)
            return;
        this.invalidatePrim();
        this.state.lightning._ambientLightColor = p;
        this.state.lightning.ambientLightColor.r = BitUtils.extractScalef(p, 0, 8, 1);
        this.state.lightning.ambientLightColor.g = BitUtils.extractScalef(p, 8, 8, 1);
        this.state.lightning.ambientLightColor.b = BitUtils.extractScalef(p, 16, 8, 1);
        this.state.lightning.ambientLightColor.a = 1;
    };
    PspGpuExecutor.prototype.AMBIENTALPHA = function (p) {
        if (this.state.lightning._ambientLightColorAlpha == p)
            return;
        this.invalidatePrim();
        this.state.lightning._ambientLightColorAlpha = p;
        this.state.lightning.ambientLightColor.a = BitUtils.extractScalef(p, 0, 8, 1);
    };
    PspGpuExecutor.prototype.LOGICOPENABLE = function (p) {
        if (this.state.logicOp.enabled == bool1(p))
            return;
        this.invalidatePrim();
        this.state.logicOp.enabled = bool1(p);
    };
    PspGpuExecutor.prototype.MATERIALDIFFUSE = function (p) {
        if (this.state._diffuseModelColor == p)
            return;
        this.invalidatePrim();
        this.state._diffuseModelColor = p;
        this.state.diffuseModelColor.r = BitUtils.extractScalef(p, 0, 8, 1);
        this.state.diffuseModelColor.g = BitUtils.extractScalef(p, 8, 8, 1);
        this.state.diffuseModelColor.b = BitUtils.extractScalef(p, 16, 8, 1);
        this.state.diffuseModelColor.a = 1;
    };
    PspGpuExecutor.prototype.MATERIALSPECULAR = function (p) {
        if (this.state._specularModelColor == p)
            return;
        this.invalidatePrim();
        this.state._specularModelColor = p;
        this.state.specularModelColor.r = BitUtils.extractScalef(p, 0, 8, 1);
        this.state.specularModelColor.g = BitUtils.extractScalef(p, 8, 8, 1);
        this.state.specularModelColor.b = BitUtils.extractScalef(p, 16, 8, 1);
        this.state.specularModelColor.a = 1;
    };
    PspGpuExecutor.prototype.CLUTADDR = function (p) {
        var v = (this.state.texture.clut.adress & 0xFF000000) | ((p << 0) & 0x00FFFFFF);
        if (this.state.texture.clut.adress == v)
            return;
        this.invalidatePrim();
        this.state.texture.clut.adress = v;
    };
    PspGpuExecutor.prototype.CLUTADDRUPPER = function (p) {
        var v = (this.state.texture.clut.adress & 0x00FFFFFF) | ((p << 8) & 0xFF000000);
        if (this.state.texture.clut.adress == v)
            return;
        this.invalidatePrim();
        this.state.texture.clut.adress = v;
    };
    PspGpuExecutor.prototype.CLOAD = function (p) {
        var v = param8(p, 0) * 8;
        if (this.state.texture.clut.numberOfColors == v)
            return;
        this.invalidatePrim();
        this.state.texture.clut.numberOfColors = v;
    };
    PspGpuExecutor.prototype.CMODE = function (p) {
        if (this.state.texture.clut.info == p)
            return;
        this.invalidatePrim();
        this.state.texture.clut.info = p;
        this.state.texture.clut.pixelFormat = param2(p, 0);
        this.state.texture.clut.shift = param5(p, 2);
        this.state.texture.clut.mask = param8(p, 8);
        this.state.texture.clut.start = param5(p, 16);
    };
    PspGpuExecutor.prototype.STENCILTESTENABLE = function (p) {
        if (this.state.stencil.enabled == bool1(p))
            return;
        this.invalidatePrim();
        this.state.stencil.enabled = bool1(p);
    };
    PspGpuExecutor.prototype.TSIZE0 = function (p) { this.TSIZE_(p, 0); };
    PspGpuExecutor.prototype.TSIZE1 = function (p) { this.TSIZE_(p, 1); };
    PspGpuExecutor.prototype.TSIZE2 = function (p) { this.TSIZE_(p, 2); };
    PspGpuExecutor.prototype.TSIZE3 = function (p) { this.TSIZE_(p, 3); };
    PspGpuExecutor.prototype.TSIZE4 = function (p) { this.TSIZE_(p, 4); };
    PspGpuExecutor.prototype.TSIZE5 = function (p) { this.TSIZE_(p, 5); };
    PspGpuExecutor.prototype.TSIZE6 = function (p) { this.TSIZE_(p, 6); };
    PspGpuExecutor.prototype.TSIZE7 = function (p) { this.TSIZE_(p, 7); };
    PspGpuExecutor.prototype.TEXADDR0 = function (p) { this.TEXADDR_(p, 0); };
    PspGpuExecutor.prototype.TEXADDR1 = function (p) { this.TEXADDR_(p, 1); };
    PspGpuExecutor.prototype.TEXADDR2 = function (p) { this.TEXADDR_(p, 2); };
    PspGpuExecutor.prototype.TEXADDR3 = function (p) { this.TEXADDR_(p, 3); };
    PspGpuExecutor.prototype.TEXADDR4 = function (p) { this.TEXADDR_(p, 4); };
    PspGpuExecutor.prototype.TEXADDR5 = function (p) { this.TEXADDR_(p, 5); };
    PspGpuExecutor.prototype.TEXADDR6 = function (p) { this.TEXADDR_(p, 6); };
    PspGpuExecutor.prototype.TEXADDR7 = function (p) { this.TEXADDR_(p, 7); };
    PspGpuExecutor.prototype.TEXBUFWIDTH0 = function (p) { return this.TEXBUFWIDTH_(p, 0); };
    PspGpuExecutor.prototype.TEXBUFWIDTH1 = function (p) { return this.TEXBUFWIDTH_(p, 1); };
    PspGpuExecutor.prototype.TEXBUFWIDTH2 = function (p) { return this.TEXBUFWIDTH_(p, 2); };
    PspGpuExecutor.prototype.TEXBUFWIDTH3 = function (p) { return this.TEXBUFWIDTH_(p, 3); };
    PspGpuExecutor.prototype.TEXBUFWIDTH4 = function (p) { return this.TEXBUFWIDTH_(p, 4); };
    PspGpuExecutor.prototype.TEXBUFWIDTH5 = function (p) { return this.TEXBUFWIDTH_(p, 5); };
    PspGpuExecutor.prototype.TEXBUFWIDTH6 = function (p) { return this.TEXBUFWIDTH_(p, 6); };
    PspGpuExecutor.prototype.TEXBUFWIDTH7 = function (p) { return this.TEXBUFWIDTH_(p, 7); };
    PspGpuExecutor.prototype.MORPHWEIGHT_ = function (p, index) {
        var morphWeight = float1(p);
        if (this.state.morphWeights[index] == morphWeight)
            return;
        this.invalidatePrim();
        this.state.morphWeights[index] = morphWeight;
    };
    PspGpuExecutor.prototype.MORPHWEIGHT0 = function (p) { return this.MORPHWEIGHT_(p, 0); };
    PspGpuExecutor.prototype.MORPHWEIGHT1 = function (p) { return this.MORPHWEIGHT_(p, 1); };
    PspGpuExecutor.prototype.MORPHWEIGHT2 = function (p) { return this.MORPHWEIGHT_(p, 2); };
    PspGpuExecutor.prototype.MORPHWEIGHT3 = function (p) { return this.MORPHWEIGHT_(p, 3); };
    PspGpuExecutor.prototype.MORPHWEIGHT4 = function (p) { return this.MORPHWEIGHT_(p, 4); };
    PspGpuExecutor.prototype.MORPHWEIGHT5 = function (p) { return this.MORPHWEIGHT_(p, 5); };
    PspGpuExecutor.prototype.MORPHWEIGHT6 = function (p) { return this.MORPHWEIGHT_(p, 6); };
    PspGpuExecutor.prototype.MORPHWEIGHT7 = function (p) { return this.MORPHWEIGHT_(p, 7); };
    PspGpuExecutor.prototype.CLEAR = function (p) {
        if (this.state._clearingWord == p)
            return;
        this.invalidatePrim();
        this.state._clearingWord = p;
        this.state.clearing = (param1(p, 0) != 0);
        this.state.clearFlags = param8(p, 8);
    };
    PspGpuExecutor.prototype.COLORTESTENABLE = function (p) {
        if (this.state.colorTest.enabled == bool1(p))
            return;
        this.invalidatePrim();
        this.state.colorTest.enabled = bool1(p);
    };
    PspGpuExecutor.prototype.DITHERENABLE = function (p) {
        if (this.state.dithering.enabled == bool1(p))
            return;
        this.invalidatePrim();
        this.state.dithering.enabled = bool1(p);
    };
    PspGpuExecutor.prototype.CULLFACEENABLE = function (p) {
        if (this.state.culling.enabled == bool1(p))
            return;
        this.invalidatePrim();
        this.state.culling.enabled = bool1(p);
    };
    PspGpuExecutor.prototype.CULL = function (p) {
        if (this.state.culling.direction == p)
            return;
        this.invalidatePrim();
        this.state.culling.direction = p;
    };
    PspGpuExecutor.prototype.SFIX = function (p) {
        if (this.state.blending._fixColorSourceWord == p)
            return;
        this.invalidatePrim();
        this.state.blending._fixColorSourceWord = p;
        this.state.blending.fixColorSource.setRGB(p);
        this.state.blending.updated = false;
    };
    PspGpuExecutor.prototype.DFIX = function (p) {
        if (this.state.blending._fixColorDestinationWord == p)
            return;
        this.invalidatePrim();
        this.state.blending._fixColorDestinationWord = p;
        this.state.blending.fixColorDestination.setRGB(p);
        this.state.blending.updated = false;
    };
    PspGpuExecutor.prototype.UNKNOWN = function (p, current, op) {
        this.invalidatePrim();
        this.list.errorCount++;
        if (this.list.errorCount >= 400) {
            if (this.list.errorCount == 400) {
                console.error(sprintf('Stop showing gpu errors'));
            }
        }
        else {
        }
    };
    PspGpuExecutor.prototype.PRIM = function (p) {
        var primitiveType = param3(p, 16);
        var vertexCount = param16(p, 0);
        var list = this.list;
        if (list.primBatchPrimitiveType != primitiveType)
            list.finishPrimBatch();
        if (vertexCount <= 0)
            return false;
        list.primBatchPrimitiveType = primitiveType;
        list.primCount++;
        var vertexState = this.state.vertex;
        var vertexSize = vertexState.size;
        var vertexAddress = this.state.getAddressRelativeToBaseOffset(vertexState.address);
        var indicesAddress = this.state.getAddressRelativeToBaseOffset(this.state.indexAddress);
        var vertexReader = _vertex.VertexReaderFactory.get(vertexState);
        var indices = null;
        switch (vertexState.index) {
            case _state.IndexEnum.Byte:
                indices = list.memory.getU8Array(indicesAddress);
                break;
            case _state.IndexEnum.Short:
                indices = list.memory.getU16Array(indicesAddress);
                break;
        }
        var vertexInput = list.memory.getPointerDataView(vertexAddress);
        if (vertexState.address) {
            if (!vertexState.hasIndex) {
                vertexState.address += vertexState.size * vertexCount;
            }
        }
        var drawType = PrimDrawType.SINGLE_DRAW;
        switch (primitiveType) {
            case _state.PrimitiveType.Lines:
            case _state.PrimitiveType.Points:
            case _state.PrimitiveType.Triangles:
            case _state.PrimitiveType.Sprites:
                drawType = PrimDrawType.BATCH_DRAW;
                break;
            case _state.PrimitiveType.TriangleStrip:
            case _state.PrimitiveType.LineStrip:
                drawType = PrimDrawType.BATCH_DRAW_DEGENERATE;
                break;
        }
        if ((list.batchPrimCount > 0) && (drawType == PrimDrawType.BATCH_DRAW_DEGENERATE))
            vertexBuffer.startDegenerateTriangleStrip();
        {
            var verticesOffset = vertexBuffer.ensureAndTake(vertexCount);
            vertexReader.readCount(vertexBuffer.vertices, verticesOffset, vertexInput, indices, vertexCount, vertexState.hasIndex);
        }
        if ((list.batchPrimCount > 0) && (drawType == PrimDrawType.BATCH_DRAW_DEGENERATE))
            vertexBuffer.endDegenerateTriangleStrip();
        if (drawType == PrimDrawType.SINGLE_DRAW) {
            list.finishPrimBatch();
        }
        else {
            list.batchPrimCount++;
        }
    };
    PspGpuExecutor.prototype.PATCHDIVISION = function (p) {
        if (this.state.patch._divst == p)
            return;
        this.invalidatePrim();
        this.state.patch._divst = p;
        this.state.patch.divs = param8(p, 0);
        this.state.patch.divt = param8(p, 8);
    };
    PspGpuExecutor.prototype.BEZIER = function (p) {
        var _this = this;
        this.invalidatePrim();
        var ucount = param8(p, 0);
        var vcount = param8(p, 8);
        var divs = this.state.patch.divs;
        var divt = this.state.patch.divt;
        var vertexState = this.state.vertex;
        var vertexReader = _vertex.VertexReaderFactory.get(vertexState);
        var vertexAddress = this.state.getAddressRelativeToBaseOffset(this.state.vertex.address);
        var vertexInput = this.list.memory.getPointerDataView(vertexAddress);
        var vertexState2 = vertexState.clone();
        vertexState2.texture = _state.NumericEnum.Float;
        var getBezierControlPoints = function (ucount, vcount) {
            var controlPoints = ArrayUtils.create2D(ucount, vcount);
            var mipmap = _this.state.texture.mipmaps[0];
            var scale = mipmap.textureWidth / mipmap.bufferWidth;
            for (var u = 0; u < ucount; u++) {
                for (var v = 0; v < vcount; v++) {
                    var vertex = vertexReader.readOne(vertexInput, v * ucount + u);
                    ;
                    controlPoints[u][v] = vertex;
                    vertex.tx = (u / (ucount - 1)) * scale;
                    vertex.ty = (v / (vcount - 1));
                }
            }
            return controlPoints;
        };
        var controlPoints = getBezierControlPoints(ucount, vcount);
        var vertices2 = [];
        vertices2.push(controlPoints[0][0]);
        vertices2.push(controlPoints[ucount - 1][0]);
        vertices2.push(controlPoints[0][vcount - 1]);
        vertices2.push(controlPoints[ucount - 1][0]);
        vertices2.push(controlPoints[ucount - 1][vcount - 1]);
        vertices2.push(controlPoints[0][vcount - 1]);
        this.list.drawDriver.drawElements(_state, _state.PrimitiveType.Triangles, vertices2, vertices2.length, vertexState2);
    };
    PspGpuExecutor.prototype.light = function (index) {
        return this.state.lightning.lights[index];
    };
    PspGpuExecutor.prototype.LIGHTENABLE_ = function (p, index) {
        if (this.light(index).enabled == bool1(p))
            return;
        this.invalidatePrim();
        this.light(index).enabled = bool1(p);
    };
    PspGpuExecutor.prototype.LIGHTMODE = function (p) {
        if (this.state.lightning.lightModel != param8(p, 0))
            return;
        this.invalidatePrim();
        this.state.lightning.lightModel = param8(p, 0);
    };
    PspGpuExecutor.prototype.LIGHTTYPE_ = function (p, index) {
        var light = this.light(index);
        if (light._type == p)
            return;
        this.invalidatePrim();
        light._type = p;
        var kind = param8(p, 0);
        var type = param8(p, 0);
        light.kind = kind;
        light.type = type;
        switch (light.type) {
            case _state.LightTypeEnum.Directional:
                light.pw = 0;
                break;
            case _state.LightTypeEnum.PointLight:
                light.pw = 1;
                light.cutoff = 180;
                break;
            case _state.LightTypeEnum.SpotLight:
                light.pw = 1;
                break;
        }
    };
    PspGpuExecutor.prototype.LCA_ = function (p, index) {
        var v = float1(p);
        if (this.light(index).constantAttenuation == v)
            return;
        this.invalidatePrim();
        this.light(index).constantAttenuation = v;
    };
    PspGpuExecutor.prototype.LLA_ = function (p, index) {
        var v = float1(p);
        if (this.light(index).linearAttenuation == v)
            return;
        this.invalidatePrim();
        this.light(index).linearAttenuation = v;
    };
    PspGpuExecutor.prototype.LQA_ = function (p, index) {
        var v = float1(p);
        if (this.light(index).quadraticAttenuation == v)
            return;
        this.invalidatePrim();
        this.light(index).quadraticAttenuation = v;
    };
    PspGpuExecutor.prototype.SPOTEXP_ = function (p, index) {
        var v = float1(p);
        if (this.light(index).spotExponent == v)
            return;
        this.invalidatePrim();
        this.light(index).spotExponent = v;
    };
    PspGpuExecutor.prototype.SPOTCUT_ = function (p, index) {
        var v = float1(p);
        if (this.light(index).spotCutoff == v)
            return;
        this.invalidatePrim();
        this.light(index).spotCutoff = v;
    };
    PspGpuExecutor.prototype.LXP_ = function (p, index) { var v = float1(p); if (this.light(index).px == float1(p))
        return; this.invalidatePrim(); this.light(index).px = float1(p); };
    PspGpuExecutor.prototype.LYP_ = function (p, index) { var v = float1(p); if (this.light(index).py == float1(p))
        return; this.invalidatePrim(); this.light(index).py = float1(p); };
    PspGpuExecutor.prototype.LZP_ = function (p, index) { var v = float1(p); if (this.light(index).pz == float1(p))
        return; this.invalidatePrim(); this.light(index).pz = float1(p); };
    PspGpuExecutor.prototype.LXD_ = function (p, index) { var v = float1(p); if (this.light(index).dx == float1(p))
        return; this.invalidatePrim(); this.light(index).dx = float1(p); };
    PspGpuExecutor.prototype.LYD_ = function (p, index) { var v = float1(p); if (this.light(index).dy == float1(p))
        return; this.invalidatePrim(); this.light(index).dy = float1(p); };
    PspGpuExecutor.prototype.LZD_ = function (p, index) { var v = float1(p); if (this.light(index).dz == float1(p))
        return; this.invalidatePrim(); this.light(index).dz = float1(p); };
    PspGpuExecutor.prototype.LIGHTENABLE0 = function (p) { this.LIGHTENABLE_(p, 0); };
    PspGpuExecutor.prototype.LIGHTENABLE1 = function (p) { this.LIGHTENABLE_(p, 1); };
    PspGpuExecutor.prototype.LIGHTENABLE2 = function (p) { this.LIGHTENABLE_(p, 2); };
    PspGpuExecutor.prototype.LIGHTENABLE3 = function (p) { this.LIGHTENABLE_(p, 3); };
    PspGpuExecutor.prototype.LIGHTTYPE0 = function (p) { this.LIGHTTYPE_(p, 0); };
    PspGpuExecutor.prototype.LIGHTTYPE1 = function (p) { this.LIGHTTYPE_(p, 1); };
    PspGpuExecutor.prototype.LIGHTTYPE2 = function (p) { this.LIGHTTYPE_(p, 2); };
    PspGpuExecutor.prototype.LIGHTTYPE3 = function (p) { this.LIGHTTYPE_(p, 3); };
    PspGpuExecutor.prototype.LCA0 = function (p) { this.LCA_(p, 0); };
    PspGpuExecutor.prototype.LCA1 = function (p) { this.LCA_(p, 1); };
    PspGpuExecutor.prototype.LCA2 = function (p) { this.LCA_(p, 2); };
    PspGpuExecutor.prototype.LCA3 = function (p) { this.LCA_(p, 3); };
    PspGpuExecutor.prototype.LLA0 = function (p) { this.LLA_(p, 0); };
    PspGpuExecutor.prototype.LLA1 = function (p) { this.LLA_(p, 1); };
    PspGpuExecutor.prototype.LLA2 = function (p) { this.LLA_(p, 2); };
    PspGpuExecutor.prototype.LLA3 = function (p) { this.LLA_(p, 3); };
    PspGpuExecutor.prototype.LQA0 = function (p) { this.LQA_(p, 0); };
    PspGpuExecutor.prototype.LQA1 = function (p) { this.LQA_(p, 1); };
    PspGpuExecutor.prototype.LQA2 = function (p) { this.LQA_(p, 2); };
    PspGpuExecutor.prototype.LQA3 = function (p) { this.LQA_(p, 3); };
    PspGpuExecutor.prototype.SPOTEXP0 = function (p) { this.SPOTEXP_(p, 0); };
    PspGpuExecutor.prototype.SPOTEXP1 = function (p) { this.SPOTEXP_(p, 1); };
    PspGpuExecutor.prototype.SPOTEXP2 = function (p) { this.SPOTEXP_(p, 2); };
    PspGpuExecutor.prototype.SPOTEXP3 = function (p) { this.SPOTEXP_(p, 3); };
    PspGpuExecutor.prototype.SPOTCUT0 = function (p) { this.SPOTCUT_(p, 0); };
    PspGpuExecutor.prototype.SPOTCUT1 = function (p) { this.SPOTCUT_(p, 1); };
    PspGpuExecutor.prototype.SPOTCUT2 = function (p) { this.SPOTCUT_(p, 2); };
    PspGpuExecutor.prototype.SPOTCUT3 = function (p) { this.SPOTCUT_(p, 3); };
    PspGpuExecutor.prototype.LXP0 = function (p) { this.LXP_(p, 0); };
    PspGpuExecutor.prototype.LXP1 = function (p) { this.LXP_(p, 1); };
    PspGpuExecutor.prototype.LXP2 = function (p) { this.LXP_(p, 2); };
    PspGpuExecutor.prototype.LXP3 = function (p) { this.LXP_(p, 3); };
    PspGpuExecutor.prototype.LYP0 = function (p) { this.LYP_(p, 0); };
    PspGpuExecutor.prototype.LYP1 = function (p) { this.LYP_(p, 1); };
    PspGpuExecutor.prototype.LYP2 = function (p) { this.LYP_(p, 2); };
    PspGpuExecutor.prototype.LYP3 = function (p) { this.LYP_(p, 3); };
    PspGpuExecutor.prototype.LZP0 = function (p) { this.LZP_(p, 0); };
    PspGpuExecutor.prototype.LZP1 = function (p) { this.LZP_(p, 1); };
    PspGpuExecutor.prototype.LZP2 = function (p) { this.LZP_(p, 2); };
    PspGpuExecutor.prototype.LZP3 = function (p) { this.LZP_(p, 3); };
    PspGpuExecutor.prototype.LXD0 = function (p) { this.LXD_(p, 0); };
    PspGpuExecutor.prototype.LXD1 = function (p) { this.LXD_(p, 1); };
    PspGpuExecutor.prototype.LXD2 = function (p) { this.LXD_(p, 2); };
    PspGpuExecutor.prototype.LXD3 = function (p) { this.LXD_(p, 3); };
    PspGpuExecutor.prototype.LYD0 = function (p) { this.LYD_(p, 0); };
    PspGpuExecutor.prototype.LYD1 = function (p) { this.LYD_(p, 1); };
    PspGpuExecutor.prototype.LYD2 = function (p) { this.LYD_(p, 2); };
    PspGpuExecutor.prototype.LYD3 = function (p) { this.LYD_(p, 3); };
    PspGpuExecutor.prototype.LZD0 = function (p) { this.LZD_(p, 0); };
    PspGpuExecutor.prototype.LZD1 = function (p) { this.LZD_(p, 1); };
    PspGpuExecutor.prototype.LZD2 = function (p) { this.LZD_(p, 2); };
    PspGpuExecutor.prototype.LZD3 = function (p) { this.LZD_(p, 3); };
    PspGpuExecutor.prototype.ALC_ = function (p, index) {
        if (this.light(index)._ambientColor == p)
            return;
        this.invalidatePrim();
        this.light(index)._ambientColor = p;
        this.light(index).ambientColor.setRGB(p);
    };
    PspGpuExecutor.prototype.DLC_ = function (p, index) {
        if (this.light(index)._diffuseColor == p)
            return;
        this.invalidatePrim();
        this.light(index)._diffuseColor = p;
        this.light(index).diffuseColor.setRGB(p);
    };
    PspGpuExecutor.prototype.SLC_ = function (p, index) {
        if (this.light(index)._specularColor == p)
            return;
        this.invalidatePrim();
        this.light(index)._specularColor = p;
        this.light(index).specularColor.setRGB(p);
    };
    PspGpuExecutor.prototype.ALC0 = function (p) { this.ALC_(p, 0); };
    PspGpuExecutor.prototype.ALC1 = function (p) { this.ALC_(p, 1); };
    PspGpuExecutor.prototype.ALC2 = function (p) { this.ALC_(p, 2); };
    PspGpuExecutor.prototype.ALC3 = function (p) { this.ALC_(p, 3); };
    PspGpuExecutor.prototype.DLC0 = function (p) { this.DLC_(p, 0); };
    PspGpuExecutor.prototype.DLC1 = function (p) { this.DLC_(p, 1); };
    PspGpuExecutor.prototype.DLC2 = function (p) { this.DLC_(p, 2); };
    PspGpuExecutor.prototype.DLC3 = function (p) { this.DLC_(p, 3); };
    PspGpuExecutor.prototype.SLC0 = function (p) { this.SLC_(p, 0); };
    PspGpuExecutor.prototype.SLC1 = function (p) { this.SLC_(p, 1); };
    PspGpuExecutor.prototype.SLC2 = function (p) { this.SLC_(p, 2); };
    PspGpuExecutor.prototype.SLC3 = function (p) { this.SLC_(p, 3); };
    return PspGpuExecutor;
})();
var PspGpuList = (function () {
    function PspGpuList(id, memory, drawDriver, executor, runner, gpu, cpuExecutor, state) {
        this.id = id;
        this.memory = memory;
        this.drawDriver = drawDriver;
        this.executor = executor;
        this.runner = runner;
        this.gpu = gpu;
        this.cpuExecutor = cpuExecutor;
        this.state = state;
        this.completed = false;
        this.status = DisplayListStatus.Paused;
        this.errorCount = 0;
        this.callstack = new Int32Array(1024);
        this.callstackIndex = 0;
        this.primBatchPrimitiveType = -1;
        this.batchPrimCount = 0;
        this.primCount = 0;
        this.showOpcodes = false;
        this.opcodes = [];
    }
    PspGpuList.prototype.complete = function () {
        this.completed = true;
        this.runner.deallocate(this);
        this.promiseResolve(0);
    };
    PspGpuList.prototype.jumpRelativeOffset = function (offset) {
        this.current4 = (((this.state.baseAddress + offset) >> 2) & Memory.MASK);
    };
    PspGpuList.prototype.jumpAbsolute = function (address) {
        this.current4 = ((address >>> 2) & Memory.MASK);
    };
    PspGpuList.prototype.finishPrimBatch = function () {
        if (vertexBuffer.offsetLength == 0)
            return;
        this.batchPrimCount = 0;
        this.drawDriver.drawElements(this.state, this.primBatchPrimitiveType, vertexBuffer.vertices, vertexBuffer.offsetLength, this.state.vertex);
        vertexBuffer.reset();
        this.primBatchPrimitiveType = -1;
    };
    PspGpuList.prototype.finish = function () {
        if (this.showOpcodes) {
            $('#output').text('finish:' + this.primCount + ';' + this.opcodes.join(","));
            if (this.opcodes.length)
                this.opcodes = [];
        }
        this.primCount = 0;
    };
    Object.defineProperty(PspGpuList.prototype, "isStalled", {
        get: function () {
            return ((this.stall4 != 0) && (this.current4 >= this.stall4));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PspGpuList.prototype, "hasMoreInstructions", {
        get: function () {
            return !this.completed && !this.isStalled;
        },
        enumerable: true,
        configurable: true
    });
    PspGpuList.prototype.runUntilStallInner = function () {
        var mem = this.memory;
        var showOpcodes = this.showOpcodes;
        var table = this.executor.table;
        var stall4 = this.stall4;
        while (!this.completed && ((stall4 == 0) || (this.current4 < stall4))) {
            var instructionPC4 = this.current4++;
            var instruction = mem.readUInt32_2(instructionPC4);
            var op = (instruction >>> 24);
            var params24 = (instruction & 0x00FFFFFF);
            if (showOpcodes)
                this.opcodes.push(GpuOpCodes[op]);
            if (table[op](params24, instructionPC4, op))
                return;
        }
        this.status = (this.isStalled) ? DisplayListStatus.Stalling : DisplayListStatus.Completed;
    };
    PspGpuList.prototype.runUntilStall = function () {
        this.status = DisplayListStatus.Drawing;
        this.executor.setList(this);
        while (this.hasMoreInstructions) {
            try {
                this.runUntilStallInner();
            }
            catch (e) {
                console.log(e);
                console.log(e['stack']);
            }
        }
    };
    PspGpuList.prototype.enqueueRunUntilStall = function () {
        var _this = this;
        Microtask.queue(function () {
            _this.runUntilStall();
        });
    };
    PspGpuList.prototype.updateStall = function (stall) {
        this.stall4 = ((stall >>> 2) & Memory.MASK);
        this.enqueueRunUntilStall();
    };
    PspGpuList.prototype.start = function () {
        var _this = this;
        this.status = DisplayListStatus.Queued;
        this.promise = new Promise2(function (resolve, reject) {
            _this.promiseResolve = resolve;
            _this.promiseReject = reject;
        });
        this.completed = false;
        this.enqueueRunUntilStall();
    };
    PspGpuList.prototype.waitAsync = function () {
        return this.promise;
    };
    return PspGpuList;
})();
var PrimDrawType;
(function (PrimDrawType) {
    PrimDrawType[PrimDrawType["SINGLE_DRAW"] = 0] = "SINGLE_DRAW";
    PrimDrawType[PrimDrawType["BATCH_DRAW"] = 1] = "BATCH_DRAW";
    PrimDrawType[PrimDrawType["BATCH_DRAW_DEGENERATE"] = 2] = "BATCH_DRAW_DEGENERATE";
})(PrimDrawType || (PrimDrawType = {}));
var PspGpuListRunner = (function () {
    function PspGpuListRunner(memory, drawDriver, gpu, callbackManager) {
        this.memory = memory;
        this.drawDriver = drawDriver;
        this.gpu = gpu;
        this.callbackManager = callbackManager;
        this.lists = [];
        this.freeLists = [];
        this.runningLists = [];
        this.state = new _state.GpuState();
        this.executor = new PspGpuExecutor();
        for (var n = 0; n < 32; n++) {
            var list = new PspGpuList(n, memory, drawDriver, this.executor, this, gpu, callbackManager, this.state);
            this.lists.push(list);
            this.freeLists.push(list);
        }
    }
    PspGpuListRunner.prototype.allocate = function () {
        if (!this.freeLists.length)
            throw ('Out of gpu free lists');
        var list = this.freeLists.pop();
        this.runningLists.push(list);
        return list;
    };
    PspGpuListRunner.prototype.getById = function (id) {
        return this.lists[id];
    };
    PspGpuListRunner.prototype.deallocate = function (list) {
        this.freeLists.push(list);
        this.runningLists.remove(list);
    };
    PspGpuListRunner.prototype.peek = function () {
        var _this = this;
        var _peek = (function () {
            for (var n = 0; n < _this.runningLists.length; n++) {
                var list = _this.runningLists[n];
                if (list.status != DisplayListStatus.Completed)
                    return list.status;
            }
            return DisplayListStatus.Completed;
        });
        var result = _peek();
        console.warn('not implemented gpu list peeking -> ' + result);
        return result;
    };
    PspGpuListRunner.prototype.waitAsync = function () {
        return Promise2.all(this.runningLists.map(function (list) { return list.waitAsync(); })).then(function () { return _state.DisplayListStatus.Completed; });
    };
    return PspGpuListRunner;
})();
var PspGpuCallback = (function () {
    function PspGpuCallback(cpuState, signalFunction, signalArgument, finishFunction, finishArgument) {
        this.cpuState = cpuState;
        this.signalFunction = signalFunction;
        this.signalArgument = signalArgument;
        this.finishFunction = finishFunction;
        this.finishArgument = finishArgument;
    }
    return PspGpuCallback;
})();
exports.PspGpuCallback = PspGpuCallback;
var PspGpu = (function () {
    function PspGpu(memory, display, canvas, cpuExecutor) {
        this.memory = memory;
        this.display = display;
        this.canvas = canvas;
        this.cpuExecutor = cpuExecutor;
        this.callbacks = new UidCollection(1);
        try {
            this.driver = new WebGlPspDrawDriver(memory, display, canvas);
        }
        catch (e) {
            this.driver = new DummyDrawDriver();
        }
        this.listRunner = new PspGpuListRunner(memory, this.driver, this, this.cpuExecutor);
    }
    PspGpu.prototype.startAsync = function () {
        return this.driver.initAsync();
    };
    PspGpu.prototype.stopAsync = function () {
        return Promise2.resolve();
    };
    PspGpu.prototype.listEnqueue = function (start, stall, callbackId, argsPtr) {
        var list = this.listRunner.allocate();
        list.current4 = ((start >>> 2) & Memory.MASK);
        list.stall4 = stall;
        list.callbackId = callbackId;
        list.argsPtr = argsPtr;
        list.start();
        return list.id;
    };
    PspGpu.prototype.listSync = function (displayListId, syncType) {
        return this.listRunner.getById(displayListId).waitAsync();
    };
    PspGpu.prototype.updateStallAddr = function (displayListId, stall) {
        this.listRunner.getById(displayListId).updateStall(stall);
        return 0;
    };
    PspGpu.prototype.drawSync = function (syncType) {
        return this.listRunner.waitAsync();
        switch (syncType) {
            case _state.SyncType.Peek: return this.listRunner.peek();
            case _state.SyncType.WaitForCompletion: return this.listRunner.waitAsync();
            default: throw (new Error("Not implemented SyncType." + syncType));
        }
    };
    return PspGpu;
})();
exports.PspGpu = PspGpu;

},
"src/core/gpu/instructions": function(module, exports, require) {
///<reference path="../../global.d.ts" />
(function (GpuOpCodes) {
    GpuOpCodes[GpuOpCodes["NOP"] = 0] = "NOP";
    GpuOpCodes[GpuOpCodes["VADDR"] = 1] = "VADDR";
    GpuOpCodes[GpuOpCodes["IADDR"] = 2] = "IADDR";
    GpuOpCodes[GpuOpCodes["Unknown0x03"] = 3] = "Unknown0x03";
    GpuOpCodes[GpuOpCodes["PRIM"] = 4] = "PRIM";
    GpuOpCodes[GpuOpCodes["BEZIER"] = 5] = "BEZIER";
    GpuOpCodes[GpuOpCodes["SPLINE"] = 6] = "SPLINE";
    GpuOpCodes[GpuOpCodes["BOUNDINGBOX"] = 7] = "BOUNDINGBOX";
    GpuOpCodes[GpuOpCodes["JUMP"] = 8] = "JUMP";
    GpuOpCodes[GpuOpCodes["BJUMP"] = 9] = "BJUMP";
    GpuOpCodes[GpuOpCodes["CALL"] = 10] = "CALL";
    GpuOpCodes[GpuOpCodes["RET"] = 11] = "RET";
    GpuOpCodes[GpuOpCodes["END"] = 12] = "END";
    GpuOpCodes[GpuOpCodes["Unknown0x0D"] = 13] = "Unknown0x0D";
    GpuOpCodes[GpuOpCodes["SIGNAL"] = 14] = "SIGNAL";
    GpuOpCodes[GpuOpCodes["FINISH"] = 15] = "FINISH";
    GpuOpCodes[GpuOpCodes["BASE"] = 16] = "BASE";
    GpuOpCodes[GpuOpCodes["Unknown0x11"] = 17] = "Unknown0x11";
    GpuOpCodes[GpuOpCodes["VERTEXTYPE"] = 18] = "VERTEXTYPE";
    GpuOpCodes[GpuOpCodes["OFFSETADDR"] = 19] = "OFFSETADDR";
    GpuOpCodes[GpuOpCodes["ORIGIN"] = 20] = "ORIGIN";
    GpuOpCodes[GpuOpCodes["REGION1"] = 21] = "REGION1";
    GpuOpCodes[GpuOpCodes["REGION2"] = 22] = "REGION2";
    GpuOpCodes[GpuOpCodes["LIGHTINGENABLE"] = 23] = "LIGHTINGENABLE";
    GpuOpCodes[GpuOpCodes["LIGHTENABLE0"] = 24] = "LIGHTENABLE0";
    GpuOpCodes[GpuOpCodes["LIGHTENABLE1"] = 25] = "LIGHTENABLE1";
    GpuOpCodes[GpuOpCodes["LIGHTENABLE2"] = 26] = "LIGHTENABLE2";
    GpuOpCodes[GpuOpCodes["LIGHTENABLE3"] = 27] = "LIGHTENABLE3";
    GpuOpCodes[GpuOpCodes["CLIPENABLE"] = 28] = "CLIPENABLE";
    GpuOpCodes[GpuOpCodes["CULLFACEENABLE"] = 29] = "CULLFACEENABLE";
    GpuOpCodes[GpuOpCodes["TEXTUREMAPENABLE"] = 30] = "TEXTUREMAPENABLE";
    GpuOpCodes[GpuOpCodes["FOGENABLE"] = 31] = "FOGENABLE";
    GpuOpCodes[GpuOpCodes["DITHERENABLE"] = 32] = "DITHERENABLE";
    GpuOpCodes[GpuOpCodes["ALPHABLENDENABLE"] = 33] = "ALPHABLENDENABLE";
    GpuOpCodes[GpuOpCodes["ALPHATESTENABLE"] = 34] = "ALPHATESTENABLE";
    GpuOpCodes[GpuOpCodes["ZTESTENABLE"] = 35] = "ZTESTENABLE";
    GpuOpCodes[GpuOpCodes["STENCILTESTENABLE"] = 36] = "STENCILTESTENABLE";
    GpuOpCodes[GpuOpCodes["ANTIALIASENABLE"] = 37] = "ANTIALIASENABLE";
    GpuOpCodes[GpuOpCodes["PATCHCULLENABLE"] = 38] = "PATCHCULLENABLE";
    GpuOpCodes[GpuOpCodes["COLORTESTENABLE"] = 39] = "COLORTESTENABLE";
    GpuOpCodes[GpuOpCodes["LOGICOPENABLE"] = 40] = "LOGICOPENABLE";
    GpuOpCodes[GpuOpCodes["Unknown0x29"] = 41] = "Unknown0x29";
    GpuOpCodes[GpuOpCodes["BONEMATRIXNUMBER"] = 42] = "BONEMATRIXNUMBER";
    GpuOpCodes[GpuOpCodes["BONEMATRIXDATA"] = 43] = "BONEMATRIXDATA";
    GpuOpCodes[GpuOpCodes["MORPHWEIGHT0"] = 44] = "MORPHWEIGHT0";
    GpuOpCodes[GpuOpCodes["MORPHWEIGHT1"] = 45] = "MORPHWEIGHT1";
    GpuOpCodes[GpuOpCodes["MORPHWEIGHT2"] = 46] = "MORPHWEIGHT2";
    GpuOpCodes[GpuOpCodes["MORPHWEIGHT3"] = 47] = "MORPHWEIGHT3";
    GpuOpCodes[GpuOpCodes["MORPHWEIGHT4"] = 48] = "MORPHWEIGHT4";
    GpuOpCodes[GpuOpCodes["MORPHWEIGHT5"] = 49] = "MORPHWEIGHT5";
    GpuOpCodes[GpuOpCodes["MORPHWEIGHT6"] = 50] = "MORPHWEIGHT6";
    GpuOpCodes[GpuOpCodes["MORPHWEIGHT7"] = 51] = "MORPHWEIGHT7";
    GpuOpCodes[GpuOpCodes["Unknown0x34"] = 52] = "Unknown0x34";
    GpuOpCodes[GpuOpCodes["Unknown0x35"] = 53] = "Unknown0x35";
    GpuOpCodes[GpuOpCodes["PATCHDIVISION"] = 54] = "PATCHDIVISION";
    GpuOpCodes[GpuOpCodes["PATCHPRIMITIVE"] = 55] = "PATCHPRIMITIVE";
    GpuOpCodes[GpuOpCodes["PATCHFACING"] = 56] = "PATCHFACING";
    GpuOpCodes[GpuOpCodes["Unknown0x39"] = 57] = "Unknown0x39";
    GpuOpCodes[GpuOpCodes["WORLDMATRIXNUMBER"] = 58] = "WORLDMATRIXNUMBER";
    GpuOpCodes[GpuOpCodes["WORLDMATRIXDATA"] = 59] = "WORLDMATRIXDATA";
    GpuOpCodes[GpuOpCodes["VIEWMATRIXNUMBER"] = 60] = "VIEWMATRIXNUMBER";
    GpuOpCodes[GpuOpCodes["VIEWMATRIXDATA"] = 61] = "VIEWMATRIXDATA";
    GpuOpCodes[GpuOpCodes["PROJMATRIXNUMBER"] = 62] = "PROJMATRIXNUMBER";
    GpuOpCodes[GpuOpCodes["PROJMATRIXDATA"] = 63] = "PROJMATRIXDATA";
    GpuOpCodes[GpuOpCodes["TGENMATRIXNUMBER"] = 64] = "TGENMATRIXNUMBER";
    GpuOpCodes[GpuOpCodes["TGENMATRIXDATA"] = 65] = "TGENMATRIXDATA";
    GpuOpCodes[GpuOpCodes["VIEWPORTX1"] = 66] = "VIEWPORTX1";
    GpuOpCodes[GpuOpCodes["VIEWPORTY1"] = 67] = "VIEWPORTY1";
    GpuOpCodes[GpuOpCodes["VIEWPORTZ1"] = 68] = "VIEWPORTZ1";
    GpuOpCodes[GpuOpCodes["VIEWPORTX2"] = 69] = "VIEWPORTX2";
    GpuOpCodes[GpuOpCodes["VIEWPORTY2"] = 70] = "VIEWPORTY2";
    GpuOpCodes[GpuOpCodes["VIEWPORTZ2"] = 71] = "VIEWPORTZ2";
    GpuOpCodes[GpuOpCodes["TEXSCALEU"] = 72] = "TEXSCALEU";
    GpuOpCodes[GpuOpCodes["TEXSCALEV"] = 73] = "TEXSCALEV";
    GpuOpCodes[GpuOpCodes["TEXOFFSETU"] = 74] = "TEXOFFSETU";
    GpuOpCodes[GpuOpCodes["TEXOFFSETV"] = 75] = "TEXOFFSETV";
    GpuOpCodes[GpuOpCodes["OFFSETX"] = 76] = "OFFSETX";
    GpuOpCodes[GpuOpCodes["OFFSETY"] = 77] = "OFFSETY";
    GpuOpCodes[GpuOpCodes["Unknown0x4E"] = 78] = "Unknown0x4E";
    GpuOpCodes[GpuOpCodes["Unknown0x4F"] = 79] = "Unknown0x4F";
    GpuOpCodes[GpuOpCodes["SHADEMODE"] = 80] = "SHADEMODE";
    GpuOpCodes[GpuOpCodes["REVERSENORMAL"] = 81] = "REVERSENORMAL";
    GpuOpCodes[GpuOpCodes["Unknown0x52"] = 82] = "Unknown0x52";
    GpuOpCodes[GpuOpCodes["MATERIALUPDATE"] = 83] = "MATERIALUPDATE";
    GpuOpCodes[GpuOpCodes["MATERIALEMISSIVE"] = 84] = "MATERIALEMISSIVE";
    GpuOpCodes[GpuOpCodes["MATERIALAMBIENT"] = 85] = "MATERIALAMBIENT";
    GpuOpCodes[GpuOpCodes["MATERIALDIFFUSE"] = 86] = "MATERIALDIFFUSE";
    GpuOpCodes[GpuOpCodes["MATERIALSPECULAR"] = 87] = "MATERIALSPECULAR";
    GpuOpCodes[GpuOpCodes["MATERIALALPHA"] = 88] = "MATERIALALPHA";
    GpuOpCodes[GpuOpCodes["Unknown0x59"] = 89] = "Unknown0x59";
    GpuOpCodes[GpuOpCodes["Unknown0x5A"] = 90] = "Unknown0x5A";
    GpuOpCodes[GpuOpCodes["MATERIALSPECULARCOEF"] = 91] = "MATERIALSPECULARCOEF";
    GpuOpCodes[GpuOpCodes["AMBIENTCOLOR"] = 92] = "AMBIENTCOLOR";
    GpuOpCodes[GpuOpCodes["AMBIENTALPHA"] = 93] = "AMBIENTALPHA";
    GpuOpCodes[GpuOpCodes["LIGHTMODE"] = 94] = "LIGHTMODE";
    GpuOpCodes[GpuOpCodes["LIGHTTYPE0"] = 95] = "LIGHTTYPE0";
    GpuOpCodes[GpuOpCodes["LIGHTTYPE1"] = 96] = "LIGHTTYPE1";
    GpuOpCodes[GpuOpCodes["LIGHTTYPE2"] = 97] = "LIGHTTYPE2";
    GpuOpCodes[GpuOpCodes["LIGHTTYPE3"] = 98] = "LIGHTTYPE3";
    GpuOpCodes[GpuOpCodes["LXP0"] = 99] = "LXP0";
    GpuOpCodes[GpuOpCodes["LYP0"] = 100] = "LYP0";
    GpuOpCodes[GpuOpCodes["LZP0"] = 101] = "LZP0";
    GpuOpCodes[GpuOpCodes["LXP1"] = 102] = "LXP1";
    GpuOpCodes[GpuOpCodes["LYP1"] = 103] = "LYP1";
    GpuOpCodes[GpuOpCodes["LZP1"] = 104] = "LZP1";
    GpuOpCodes[GpuOpCodes["LXP2"] = 105] = "LXP2";
    GpuOpCodes[GpuOpCodes["LYP2"] = 106] = "LYP2";
    GpuOpCodes[GpuOpCodes["LZP2"] = 107] = "LZP2";
    GpuOpCodes[GpuOpCodes["LXP3"] = 108] = "LXP3";
    GpuOpCodes[GpuOpCodes["LYP3"] = 109] = "LYP3";
    GpuOpCodes[GpuOpCodes["LZP3"] = 110] = "LZP3";
    GpuOpCodes[GpuOpCodes["LXD0"] = 111] = "LXD0";
    GpuOpCodes[GpuOpCodes["LYD0"] = 112] = "LYD0";
    GpuOpCodes[GpuOpCodes["LZD0"] = 113] = "LZD0";
    GpuOpCodes[GpuOpCodes["LXD1"] = 114] = "LXD1";
    GpuOpCodes[GpuOpCodes["LYD1"] = 115] = "LYD1";
    GpuOpCodes[GpuOpCodes["LZD1"] = 116] = "LZD1";
    GpuOpCodes[GpuOpCodes["LXD2"] = 117] = "LXD2";
    GpuOpCodes[GpuOpCodes["LYD2"] = 118] = "LYD2";
    GpuOpCodes[GpuOpCodes["LZD2"] = 119] = "LZD2";
    GpuOpCodes[GpuOpCodes["LXD3"] = 120] = "LXD3";
    GpuOpCodes[GpuOpCodes["LYD3"] = 121] = "LYD3";
    GpuOpCodes[GpuOpCodes["LZD3"] = 122] = "LZD3";
    GpuOpCodes[GpuOpCodes["LCA0"] = 123] = "LCA0";
    GpuOpCodes[GpuOpCodes["LLA0"] = 124] = "LLA0";
    GpuOpCodes[GpuOpCodes["LQA0"] = 125] = "LQA0";
    GpuOpCodes[GpuOpCodes["LCA1"] = 126] = "LCA1";
    GpuOpCodes[GpuOpCodes["LLA1"] = 127] = "LLA1";
    GpuOpCodes[GpuOpCodes["LQA1"] = 128] = "LQA1";
    GpuOpCodes[GpuOpCodes["LCA2"] = 129] = "LCA2";
    GpuOpCodes[GpuOpCodes["LLA2"] = 130] = "LLA2";
    GpuOpCodes[GpuOpCodes["LQA2"] = 131] = "LQA2";
    GpuOpCodes[GpuOpCodes["LCA3"] = 132] = "LCA3";
    GpuOpCodes[GpuOpCodes["LLA3"] = 133] = "LLA3";
    GpuOpCodes[GpuOpCodes["LQA3"] = 134] = "LQA3";
    GpuOpCodes[GpuOpCodes["SPOTEXP0"] = 135] = "SPOTEXP0";
    GpuOpCodes[GpuOpCodes["SPOTEXP1"] = 136] = "SPOTEXP1";
    GpuOpCodes[GpuOpCodes["SPOTEXP2"] = 137] = "SPOTEXP2";
    GpuOpCodes[GpuOpCodes["SPOTEXP3"] = 138] = "SPOTEXP3";
    GpuOpCodes[GpuOpCodes["SPOTCUT0"] = 139] = "SPOTCUT0";
    GpuOpCodes[GpuOpCodes["SPOTCUT1"] = 140] = "SPOTCUT1";
    GpuOpCodes[GpuOpCodes["SPOTCUT2"] = 141] = "SPOTCUT2";
    GpuOpCodes[GpuOpCodes["SPOTCUT3"] = 142] = "SPOTCUT3";
    GpuOpCodes[GpuOpCodes["ALC0"] = 143] = "ALC0";
    GpuOpCodes[GpuOpCodes["DLC0"] = 144] = "DLC0";
    GpuOpCodes[GpuOpCodes["SLC0"] = 145] = "SLC0";
    GpuOpCodes[GpuOpCodes["ALC1"] = 146] = "ALC1";
    GpuOpCodes[GpuOpCodes["DLC1"] = 147] = "DLC1";
    GpuOpCodes[GpuOpCodes["SLC1"] = 148] = "SLC1";
    GpuOpCodes[GpuOpCodes["ALC2"] = 149] = "ALC2";
    GpuOpCodes[GpuOpCodes["DLC2"] = 150] = "DLC2";
    GpuOpCodes[GpuOpCodes["SLC2"] = 151] = "SLC2";
    GpuOpCodes[GpuOpCodes["ALC3"] = 152] = "ALC3";
    GpuOpCodes[GpuOpCodes["DLC3"] = 153] = "DLC3";
    GpuOpCodes[GpuOpCodes["SLC3"] = 154] = "SLC3";
    GpuOpCodes[GpuOpCodes["CULL"] = 155] = "CULL";
    GpuOpCodes[GpuOpCodes["FRAMEBUFPTR"] = 156] = "FRAMEBUFPTR";
    GpuOpCodes[GpuOpCodes["FRAMEBUFWIDTH"] = 157] = "FRAMEBUFWIDTH";
    GpuOpCodes[GpuOpCodes["ZBUFPTR"] = 158] = "ZBUFPTR";
    GpuOpCodes[GpuOpCodes["ZBUFWIDTH"] = 159] = "ZBUFWIDTH";
    GpuOpCodes[GpuOpCodes["TEXADDR0"] = 160] = "TEXADDR0";
    GpuOpCodes[GpuOpCodes["TEXADDR1"] = 161] = "TEXADDR1";
    GpuOpCodes[GpuOpCodes["TEXADDR2"] = 162] = "TEXADDR2";
    GpuOpCodes[GpuOpCodes["TEXADDR3"] = 163] = "TEXADDR3";
    GpuOpCodes[GpuOpCodes["TEXADDR4"] = 164] = "TEXADDR4";
    GpuOpCodes[GpuOpCodes["TEXADDR5"] = 165] = "TEXADDR5";
    GpuOpCodes[GpuOpCodes["TEXADDR6"] = 166] = "TEXADDR6";
    GpuOpCodes[GpuOpCodes["TEXADDR7"] = 167] = "TEXADDR7";
    GpuOpCodes[GpuOpCodes["TEXBUFWIDTH0"] = 168] = "TEXBUFWIDTH0";
    GpuOpCodes[GpuOpCodes["TEXBUFWIDTH1"] = 169] = "TEXBUFWIDTH1";
    GpuOpCodes[GpuOpCodes["TEXBUFWIDTH2"] = 170] = "TEXBUFWIDTH2";
    GpuOpCodes[GpuOpCodes["TEXBUFWIDTH3"] = 171] = "TEXBUFWIDTH3";
    GpuOpCodes[GpuOpCodes["TEXBUFWIDTH4"] = 172] = "TEXBUFWIDTH4";
    GpuOpCodes[GpuOpCodes["TEXBUFWIDTH5"] = 173] = "TEXBUFWIDTH5";
    GpuOpCodes[GpuOpCodes["TEXBUFWIDTH6"] = 174] = "TEXBUFWIDTH6";
    GpuOpCodes[GpuOpCodes["TEXBUFWIDTH7"] = 175] = "TEXBUFWIDTH7";
    GpuOpCodes[GpuOpCodes["CLUTADDR"] = 176] = "CLUTADDR";
    GpuOpCodes[GpuOpCodes["CLUTADDRUPPER"] = 177] = "CLUTADDRUPPER";
    GpuOpCodes[GpuOpCodes["TRXSBP"] = 178] = "TRXSBP";
    GpuOpCodes[GpuOpCodes["TRXSBW"] = 179] = "TRXSBW";
    GpuOpCodes[GpuOpCodes["TRXDBP"] = 180] = "TRXDBP";
    GpuOpCodes[GpuOpCodes["TRXDBW"] = 181] = "TRXDBW";
    GpuOpCodes[GpuOpCodes["Unknown0xB6"] = 182] = "Unknown0xB6";
    GpuOpCodes[GpuOpCodes["Unknown0xB7"] = 183] = "Unknown0xB7";
    GpuOpCodes[GpuOpCodes["TSIZE0"] = 184] = "TSIZE0";
    GpuOpCodes[GpuOpCodes["TSIZE1"] = 185] = "TSIZE1";
    GpuOpCodes[GpuOpCodes["TSIZE2"] = 186] = "TSIZE2";
    GpuOpCodes[GpuOpCodes["TSIZE3"] = 187] = "TSIZE3";
    GpuOpCodes[GpuOpCodes["TSIZE4"] = 188] = "TSIZE4";
    GpuOpCodes[GpuOpCodes["TSIZE5"] = 189] = "TSIZE5";
    GpuOpCodes[GpuOpCodes["TSIZE6"] = 190] = "TSIZE6";
    GpuOpCodes[GpuOpCodes["TSIZE7"] = 191] = "TSIZE7";
    GpuOpCodes[GpuOpCodes["TMAP"] = 192] = "TMAP";
    GpuOpCodes[GpuOpCodes["TEXTURE_ENV_MAP_MATRIX"] = 193] = "TEXTURE_ENV_MAP_MATRIX";
    GpuOpCodes[GpuOpCodes["TMODE"] = 194] = "TMODE";
    GpuOpCodes[GpuOpCodes["TPSM"] = 195] = "TPSM";
    GpuOpCodes[GpuOpCodes["CLOAD"] = 196] = "CLOAD";
    GpuOpCodes[GpuOpCodes["CMODE"] = 197] = "CMODE";
    GpuOpCodes[GpuOpCodes["TFLT"] = 198] = "TFLT";
    GpuOpCodes[GpuOpCodes["TWRAP"] = 199] = "TWRAP";
    GpuOpCodes[GpuOpCodes["TBIAS"] = 200] = "TBIAS";
    GpuOpCodes[GpuOpCodes["TFUNC"] = 201] = "TFUNC";
    GpuOpCodes[GpuOpCodes["TEC"] = 202] = "TEC";
    GpuOpCodes[GpuOpCodes["TFLUSH"] = 203] = "TFLUSH";
    GpuOpCodes[GpuOpCodes["TSYNC"] = 204] = "TSYNC";
    GpuOpCodes[GpuOpCodes["FFAR"] = 205] = "FFAR";
    GpuOpCodes[GpuOpCodes["FDIST"] = 206] = "FDIST";
    GpuOpCodes[GpuOpCodes["FCOL"] = 207] = "FCOL";
    GpuOpCodes[GpuOpCodes["TSLOPE"] = 208] = "TSLOPE";
    GpuOpCodes[GpuOpCodes["Unknown0xD1"] = 209] = "Unknown0xD1";
    GpuOpCodes[GpuOpCodes["PSM"] = 210] = "PSM";
    GpuOpCodes[GpuOpCodes["CLEAR"] = 211] = "CLEAR";
    GpuOpCodes[GpuOpCodes["SCISSOR1"] = 212] = "SCISSOR1";
    GpuOpCodes[GpuOpCodes["SCISSOR2"] = 213] = "SCISSOR2";
    GpuOpCodes[GpuOpCodes["MINZ"] = 214] = "MINZ";
    GpuOpCodes[GpuOpCodes["MAXZ"] = 215] = "MAXZ";
    GpuOpCodes[GpuOpCodes["CTST"] = 216] = "CTST";
    GpuOpCodes[GpuOpCodes["CREF"] = 217] = "CREF";
    GpuOpCodes[GpuOpCodes["CMSK"] = 218] = "CMSK";
    GpuOpCodes[GpuOpCodes["ATST"] = 219] = "ATST";
    GpuOpCodes[GpuOpCodes["STST"] = 220] = "STST";
    GpuOpCodes[GpuOpCodes["SOP"] = 221] = "SOP";
    GpuOpCodes[GpuOpCodes["ZTST"] = 222] = "ZTST";
    GpuOpCodes[GpuOpCodes["ALPHA"] = 223] = "ALPHA";
    GpuOpCodes[GpuOpCodes["SFIX"] = 224] = "SFIX";
    GpuOpCodes[GpuOpCodes["DFIX"] = 225] = "DFIX";
    GpuOpCodes[GpuOpCodes["DTH0"] = 226] = "DTH0";
    GpuOpCodes[GpuOpCodes["DTH1"] = 227] = "DTH1";
    GpuOpCodes[GpuOpCodes["DTH2"] = 228] = "DTH2";
    GpuOpCodes[GpuOpCodes["DTH3"] = 229] = "DTH3";
    GpuOpCodes[GpuOpCodes["LOP"] = 230] = "LOP";
    GpuOpCodes[GpuOpCodes["ZMSK"] = 231] = "ZMSK";
    GpuOpCodes[GpuOpCodes["PMSKC"] = 232] = "PMSKC";
    GpuOpCodes[GpuOpCodes["PMSKA"] = 233] = "PMSKA";
    GpuOpCodes[GpuOpCodes["TRXKICK"] = 234] = "TRXKICK";
    GpuOpCodes[GpuOpCodes["TRXSPOS"] = 235] = "TRXSPOS";
    GpuOpCodes[GpuOpCodes["TRXDPOS"] = 236] = "TRXDPOS";
    GpuOpCodes[GpuOpCodes["Unknown0xED"] = 237] = "Unknown0xED";
    GpuOpCodes[GpuOpCodes["TRXSIZE"] = 238] = "TRXSIZE";
    GpuOpCodes[GpuOpCodes["Unknown0xEF"] = 239] = "Unknown0xEF";
    GpuOpCodes[GpuOpCodes["Unknown0xF0"] = 240] = "Unknown0xF0";
    GpuOpCodes[GpuOpCodes["Unknown0xF1"] = 241] = "Unknown0xF1";
    GpuOpCodes[GpuOpCodes["Unknown0xF2"] = 242] = "Unknown0xF2";
    GpuOpCodes[GpuOpCodes["Unknown0xF3"] = 243] = "Unknown0xF3";
    GpuOpCodes[GpuOpCodes["Unknown0xF4"] = 244] = "Unknown0xF4";
    GpuOpCodes[GpuOpCodes["Unknown0xF5"] = 245] = "Unknown0xF5";
    GpuOpCodes[GpuOpCodes["Unknown0xF6"] = 246] = "Unknown0xF6";
    GpuOpCodes[GpuOpCodes["Unknown0xF7"] = 247] = "Unknown0xF7";
    GpuOpCodes[GpuOpCodes["Unknown0xF8"] = 248] = "Unknown0xF8";
    GpuOpCodes[GpuOpCodes["Unknown0xF9"] = 249] = "Unknown0xF9";
    GpuOpCodes[GpuOpCodes["Unknown0xFA"] = 250] = "Unknown0xFA";
    GpuOpCodes[GpuOpCodes["Unknown0xFB"] = 251] = "Unknown0xFB";
    GpuOpCodes[GpuOpCodes["Unknown0xFC"] = 252] = "Unknown0xFC";
    GpuOpCodes[GpuOpCodes["Unknown0xFD"] = 253] = "Unknown0xFD";
    GpuOpCodes[GpuOpCodes["Unknown0xFE"] = 254] = "Unknown0xFE";
    GpuOpCodes[GpuOpCodes["DUMMY"] = 255] = "DUMMY";
})(exports.GpuOpCodes || (exports.GpuOpCodes = {}));
var GpuOpCodes = exports.GpuOpCodes;

},
"src/core/gpu/state": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _pixelformat = require('../pixelformat');
var PixelFormat = _pixelformat.PixelFormat;
(function (CullingDirection) {
    CullingDirection[CullingDirection["CounterClockWise"] = 0] = "CounterClockWise";
    CullingDirection[CullingDirection["ClockWise"] = 1] = "ClockWise";
})(exports.CullingDirection || (exports.CullingDirection = {}));
var CullingDirection = exports.CullingDirection;
(function (SyncType) {
    SyncType[SyncType["WaitForCompletion"] = 0] = "WaitForCompletion";
    SyncType[SyncType["Peek"] = 1] = "Peek";
})(exports.SyncType || (exports.SyncType = {}));
var SyncType = exports.SyncType;
(function (DisplayListStatus) {
    DisplayListStatus[DisplayListStatus["Completed"] = 0] = "Completed";
    DisplayListStatus[DisplayListStatus["Queued"] = 1] = "Queued";
    DisplayListStatus[DisplayListStatus["Drawing"] = 2] = "Drawing";
    DisplayListStatus[DisplayListStatus["Stalling"] = 3] = "Stalling";
    DisplayListStatus[DisplayListStatus["Paused"] = 4] = "Paused";
})(exports.DisplayListStatus || (exports.DisplayListStatus = {}));
var DisplayListStatus = exports.DisplayListStatus;
var GpuFrameBufferState = (function () {
    function GpuFrameBufferState() {
        this._widthHighAddress = -1;
        this.lowAddress = 0;
        this.highAddress = 0;
        this.width = 0;
    }
    return GpuFrameBufferState;
})();
exports.GpuFrameBufferState = GpuFrameBufferState;
(function (IndexEnum) {
    IndexEnum[IndexEnum["Void"] = 0] = "Void";
    IndexEnum[IndexEnum["Byte"] = 1] = "Byte";
    IndexEnum[IndexEnum["Short"] = 2] = "Short";
})(exports.IndexEnum || (exports.IndexEnum = {}));
var IndexEnum = exports.IndexEnum;
(function (NumericEnum) {
    NumericEnum[NumericEnum["Void"] = 0] = "Void";
    NumericEnum[NumericEnum["Byte"] = 1] = "Byte";
    NumericEnum[NumericEnum["Short"] = 2] = "Short";
    NumericEnum[NumericEnum["Float"] = 3] = "Float";
})(exports.NumericEnum || (exports.NumericEnum = {}));
var NumericEnum = exports.NumericEnum;
(function (ColorEnum) {
    ColorEnum[ColorEnum["Void"] = 0] = "Void";
    ColorEnum[ColorEnum["Invalid1"] = 1] = "Invalid1";
    ColorEnum[ColorEnum["Invalid2"] = 2] = "Invalid2";
    ColorEnum[ColorEnum["Invalid3"] = 3] = "Invalid3";
    ColorEnum[ColorEnum["Color5650"] = 4] = "Color5650";
    ColorEnum[ColorEnum["Color5551"] = 5] = "Color5551";
    ColorEnum[ColorEnum["Color4444"] = 6] = "Color4444";
    ColorEnum[ColorEnum["Color8888"] = 7] = "Color8888";
})(exports.ColorEnum || (exports.ColorEnum = {}));
var ColorEnum = exports.ColorEnum;
var Vertex = (function () {
    function Vertex() {
        this.px = 0.0;
        this.py = 0.0;
        this.pz = 0.0;
        this.nx = 0.0;
        this.ny = 0.0;
        this.nz = 0.0;
        this.tx = 0.0;
        this.ty = 0.0;
        this.tz = 0.0;
        this.r = 0.0;
        this.g = 0.0;
        this.b = 0.0;
        this.a = 1.0;
        this.w0 = 0.0;
        this.w1 = 0.0;
        this.w2 = 0.0;
        this.w3 = 0.0;
        this.w4 = 0.0;
        this.w5 = 0.0;
        this.w6 = 0.0;
        this.w7 = 0.0;
    }
    Vertex.prototype.copyFromBasic = function (that) {
        this.px = that.px;
        this.py = that.py;
        this.pz = that.pz;
        this.tx = that.tx;
        this.ty = that.ty;
        this.tz = that.tz;
        this.r = that.r;
        this.g = that.g;
        this.b = that.b;
        this.a = that.a;
        return this;
    };
    Vertex.prototype.copyFrom = function (that) {
        this.copyFromBasic(that);
        this.nx = that.nx;
        this.ny = that.ny;
        this.nz = that.nz;
        this.w0 = that.w0;
        this.w1 = that.w1;
        this.w2 = that.w2;
        this.w3 = that.w3;
        this.w4 = that.w4;
        this.w5 = that.w5;
        this.w6 = that.w6;
        this.w7 = that.w7;
        return this;
    };
    Vertex.prototype.clone = function () {
        var that = new Vertex();
        that.copyFrom(this);
        return that;
    };
    return Vertex;
})();
exports.Vertex = Vertex;
var VertexState = (function () {
    function VertexState() {
        this.address = 0;
        this._value = 0;
        this.reversedNormal = false;
        this.textureComponentCount = 2;
    }
    VertexState.prototype.clone = function () {
        var that = new VertexState();
        that.address = this.address;
        that._value = this._value;
        that.reversedNormal = this.reversedNormal;
        that.textureComponentCount = this.textureComponentCount;
        that.size = this.size;
        return that;
    };
    VertexState.prototype.getValue = function () { return this._value; };
    VertexState.prototype.setValue = function (value) {
        this._value = value;
        this.size = this.getVertexSize();
    };
    Object.defineProperty(VertexState.prototype, "hash", {
        get: function () {
            return this._value + (this.textureComponentCount * Math.pow(2, 24));
        },
        enumerable: true,
        configurable: true
    });
    VertexState.prototype.toString = function () {
        return 'VertexState(' + JSON.stringify({
            address: this.address,
            texture: this.texture,
            color: this.color,
            normal: this.normal,
            position: this.position,
            weight: this.weight,
            index: this.index,
            realWeightCount: this.realWeightCount,
            morphingVertexCount: this.morphingVertexCount,
            transform2D: this.transform2D,
        }) + ')';
    };
    Object.defineProperty(VertexState.prototype, "hasTexture", {
        get: function () { return this.texture != NumericEnum.Void; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "hasColor", {
        get: function () { return this.color != ColorEnum.Void; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "hasNormal", {
        get: function () { return this.normal != NumericEnum.Void; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "hasPosition", {
        get: function () { return this.position != NumericEnum.Void; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "hasWeight", {
        get: function () { return this.weight != NumericEnum.Void; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "hasIndex", {
        get: function () { return this.index != IndexEnum.Void; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "texture", {
        get: function () { return BitUtils.extractEnum(this._value, 0, 2); },
        set: function (value) { this._value = BitUtils.insert(this._value, 0, 2, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "color", {
        get: function () { return BitUtils.extractEnum(this._value, 2, 3); },
        set: function (value) { this._value = BitUtils.insert(this._value, 2, 3, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "normal", {
        get: function () { return BitUtils.extractEnum(this._value, 5, 2); },
        set: function (value) { this._value = BitUtils.insert(this._value, 5, 2, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "position", {
        get: function () { return BitUtils.extractEnum(this._value, 7, 2); },
        set: function (value) { this._value = BitUtils.insert(this._value, 7, 2, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "weight", {
        get: function () { return BitUtils.extractEnum(this._value, 9, 2); },
        set: function (value) { this._value = BitUtils.insert(this._value, 9, 2, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "index", {
        get: function () { return BitUtils.extractEnum(this._value, 11, 2); },
        set: function (value) { this._value = BitUtils.insert(this._value, 11, 2, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "weightCount", {
        get: function () { return BitUtils.extract(this._value, 14, 3); },
        set: function (value) { this._value = BitUtils.insert(this._value, 14, 3, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "morphingVertexCount", {
        get: function () { return BitUtils.extract(this._value, 18, 2); },
        set: function (value) { this._value = BitUtils.insert(this._value, 18, 2, value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "transform2D", {
        get: function () { return BitUtils.extractBool(this._value, 23); },
        set: function (value) { this._value = BitUtils.insert(this._value, 23, 1, value ? 1 : 0); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "weightSize", {
        get: function () { return this.NumericEnumGetSize(this.weight); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "colorSize", {
        get: function () { return this.ColorEnumGetSize(this.color); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "textureSize", {
        get: function () { return this.NumericEnumGetSize(this.texture); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "positionSize", {
        get: function () { return this.NumericEnumGetSize(this.position); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "normalSize", {
        get: function () { return this.NumericEnumGetSize(this.normal); },
        enumerable: true,
        configurable: true
    });
    VertexState.prototype.IndexEnumGetSize = function (item) {
        switch (item) {
            case IndexEnum.Void: return 0;
            case IndexEnum.Byte: return 1;
            case IndexEnum.Short: return 2;
            default: throw ("Invalid enum");
        }
    };
    VertexState.prototype.NumericEnumGetSize = function (item) {
        switch (item) {
            case NumericEnum.Void: return 0;
            case NumericEnum.Byte: return 1;
            case NumericEnum.Short: return 2;
            case NumericEnum.Float: return 4;
            default: throw ("Invalid enum");
        }
    };
    VertexState.prototype.ColorEnumGetSize = function (item) {
        switch (item) {
            case ColorEnum.Void: return 0;
            case ColorEnum.Color5650: return 2;
            case ColorEnum.Color5551: return 2;
            case ColorEnum.Color4444: return 2;
            case ColorEnum.Color8888: return 4;
            default: throw ("Invalid enum");
        }
    };
    VertexState.prototype.GetMaxAlignment = function () {
        return Math.max(this.weightSize, this.colorSize, this.textureSize, this.positionSize, this.normalSize);
    };
    Object.defineProperty(VertexState.prototype, "realWeightCount", {
        get: function () {
            return this.hasWeight ? (this.weightCount + 1) : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexState.prototype, "realMorphingVertexCount", {
        get: function () {
            return this.morphingVertexCount + 1;
        },
        enumerable: true,
        configurable: true
    });
    VertexState.prototype.getVertexSize = function () {
        var size = 0;
        size = MathUtils.nextAligned(size, this.weightSize);
        size += this.realWeightCount * this.weightSize;
        size = MathUtils.nextAligned(size, this.textureSize);
        size += this.textureComponentCount * this.textureSize;
        size = MathUtils.nextAligned(size, this.colorSize);
        size += 1 * this.colorSize;
        size = MathUtils.nextAligned(size, this.normalSize);
        size += 3 * this.normalSize;
        size = MathUtils.nextAligned(size, this.positionSize);
        size += 3 * this.positionSize;
        var alignmentSize = this.GetMaxAlignment();
        size = MathUtils.nextAligned(size, alignmentSize);
        return size;
    };
    VertexState.prototype.read = function (memory, count) {
        var vertices = [];
        for (var n = 0; n < count; n++)
            vertices.push(this.readOne(memory));
        return vertices;
    };
    VertexState.prototype.readOne = function (memory) {
        var address = this.address;
        var vertex = {};
        this.address += this.size;
        return vertex;
    };
    return VertexState;
})();
exports.VertexState = VertexState;
var Matrix4x4 = (function () {
    function Matrix4x4() {
        this.index = 0;
        this.values = mat4.create();
    }
    Matrix4x4.prototype.check = function (value) {
        var check = (this.values[this.index] == value);
        if (check)
            this.index++;
        return check;
    };
    Matrix4x4.prototype.put = function (value) {
        this.values[this.index++] = value;
    };
    Matrix4x4.prototype.getAt = function (index, value) {
        return this.values[index];
    };
    Matrix4x4.prototype.putAt = function (index, value) {
        this.values[index] = value;
    };
    Matrix4x4.prototype.reset = function (startIndex) {
        this.index = startIndex;
    };
    return Matrix4x4;
})();
exports.Matrix4x4 = Matrix4x4;
var Matrix4x3 = (function () {
    function Matrix4x3() {
        this.index = 0;
        this.values = mat4.create();
    }
    Matrix4x3.prototype.check = function (value) {
        var check = (this.values[Matrix4x3.indices[this.index]] == value);
        if (check)
            this.index++;
        return check;
    };
    Matrix4x3.prototype.put = function (value) {
        this.putAt(this.index++, value);
    };
    Matrix4x3.prototype.getAt = function (index) {
        return this.values[Matrix4x3.indices[index]];
    };
    Matrix4x3.prototype.putAt = function (index, value) {
        this.values[Matrix4x3.indices[index]] = value;
    };
    Matrix4x3.prototype.reset = function (startIndex) {
        this.index = startIndex;
    };
    Matrix4x3.indices = new Int32Array([
        0, 1, 2,
        4, 5, 6,
        8, 9, 10,
        12, 13, 14
    ]);
    return Matrix4x3;
})();
exports.Matrix4x3 = Matrix4x3;
var ViewPort = (function () {
    function ViewPort() {
        this.x = 2048;
        this.y = 2048;
        this.z = 0;
        this.width = 256;
        this.height = 136;
        this.depth = 0;
    }
    return ViewPort;
})();
exports.ViewPort = ViewPort;
var Region = (function () {
    function Region() {
        this._xy1 = -1;
        this._xy2 = -1;
        this.x1 = 0;
        this.y1 = 0;
        this.x2 = 512;
        this.y2 = 272;
    }
    return Region;
})();
exports.Region = Region;
var Light = (function () {
    function Light() {
        this._type = -1;
        this._specularColor = -1;
        this._diffuseColor = -1;
        this._ambientColor = -1;
        this.enabled = false;
        this.kind = LightModelEnum.SingleColor;
        this.type = LightTypeEnum.Directional;
        this.cutoff = 0;
        this.px = 0;
        this.py = 0;
        this.pz = 0;
        this.pw = 1;
        this.dx = 0;
        this.dy = 0;
        this.dz = 0;
        this.dw = 1;
        this.spotExponent = 0;
        this.spotCutoff = 0;
        this.constantAttenuation = 0;
        this.linearAttenuation = 0;
        this.quadraticAttenuation = 0;
        this.ambientColor = new Color();
        this.diffuseColor = new Color();
        this.specularColor = new Color();
    }
    return Light;
})();
exports.Light = Light;
(function (LightTypeEnum) {
    LightTypeEnum[LightTypeEnum["Directional"] = 0] = "Directional";
    LightTypeEnum[LightTypeEnum["PointLight"] = 1] = "PointLight";
    LightTypeEnum[LightTypeEnum["SpotLight"] = 2] = "SpotLight";
})(exports.LightTypeEnum || (exports.LightTypeEnum = {}));
var LightTypeEnum = exports.LightTypeEnum;
(function (LightModelEnum) {
    LightModelEnum[LightModelEnum["SingleColor"] = 0] = "SingleColor";
    LightModelEnum[LightModelEnum["SeparateSpecularColor"] = 1] = "SeparateSpecularColor";
})(exports.LightModelEnum || (exports.LightModelEnum = {}));
var LightModelEnum = exports.LightModelEnum;
var Lightning = (function () {
    function Lightning() {
        this._ambientLightColor = -1;
        this._ambientLightColorAlpha = -1;
        this.enabled = false;
        this.lights = [new Light(), new Light(), new Light(), new Light()];
        this.lightModel = LightModelEnum.SeparateSpecularColor;
        this.specularPower = 1;
        this.ambientLightColor = new ColorState();
    }
    return Lightning;
})();
exports.Lightning = Lightning;
var MipmapState = (function () {
    function MipmapState() {
        this.tsizeValue = -1;
        this.address = 0;
        this.bufferWidth = 0;
        this.textureWidth = 0;
        this.textureHeight = 0;
    }
    return MipmapState;
})();
exports.MipmapState = MipmapState;
var ColorState = (function () {
    function ColorState() {
        this.r = 1;
        this.g = 1;
        this.b = 1;
        this.a = 1;
    }
    return ColorState;
})();
exports.ColorState = ColorState;
var ClutState = (function () {
    function ClutState() {
        this.adress = 0;
        this.numberOfColors = 0;
        this.pixelFormat = PixelFormat.RGBA_8888;
        this.shift = 0;
        this.mask = 0x00;
        this.start = 0;
    }
    return ClutState;
})();
exports.ClutState = ClutState;
(function (TextureProjectionMapMode) {
    TextureProjectionMapMode[TextureProjectionMapMode["GU_POSITION"] = 0] = "GU_POSITION";
    TextureProjectionMapMode[TextureProjectionMapMode["GU_UV"] = 1] = "GU_UV";
    TextureProjectionMapMode[TextureProjectionMapMode["GU_NORMALIZED_NORMAL"] = 2] = "GU_NORMALIZED_NORMAL";
    TextureProjectionMapMode[TextureProjectionMapMode["GU_NORMAL"] = 3] = "GU_NORMAL";
})(exports.TextureProjectionMapMode || (exports.TextureProjectionMapMode = {}));
var TextureProjectionMapMode = exports.TextureProjectionMapMode;
(function (TextureMapMode) {
    TextureMapMode[TextureMapMode["GU_TEXTURE_COORDS"] = 0] = "GU_TEXTURE_COORDS";
    TextureMapMode[TextureMapMode["GU_TEXTURE_MATRIX"] = 1] = "GU_TEXTURE_MATRIX";
    TextureMapMode[TextureMapMode["GU_ENVIRONMENT_MAP"] = 2] = "GU_ENVIRONMENT_MAP";
})(exports.TextureMapMode || (exports.TextureMapMode = {}));
var TextureMapMode = exports.TextureMapMode;
(function (TextureLevelMode) {
    TextureLevelMode[TextureLevelMode["Auto"] = 0] = "Auto";
    TextureLevelMode[TextureLevelMode["Const"] = 1] = "Const";
    TextureLevelMode[TextureLevelMode["Slope"] = 2] = "Slope";
})(exports.TextureLevelMode || (exports.TextureLevelMode = {}));
var TextureLevelMode = exports.TextureLevelMode;
var TextureState = (function () {
    function TextureState() {
        this.tmode = -1;
        this.tflt = -1;
        this.twrap = -1;
        this.tmap = -1;
        this._envColor = -1;
        this._tfunc = -1;
        this._shadeUV = -1;
        this._tbias = -1;
        this.enabled = false;
        this.swizzled = false;
        this.matrix = new Matrix4x4();
        this.mipmapShareClut = false;
        this.mipmapMaxLevel = 0;
        this.filterMinification = TextureFilter.Nearest;
        this.filterMagnification = TextureFilter.Nearest;
        this.wrapU = WrapMode.Repeat;
        this.offsetU = 0;
        this.offsetV = 0;
        this.scaleU = 1;
        this.scaleV = 1;
        this.shadeU = 0;
        this.shadeV = 0;
        this.wrapV = WrapMode.Repeat;
        this.effect = TextureEffect.Modulate;
        this.colorComponent = TextureColorComponent.Rgb;
        this.envColor = new ColorState();
        this.fragment2X = false;
        this.pixelFormat = PixelFormat.RGBA_8888;
        this.clut = new ClutState();
        this.mipmaps = [new MipmapState(), new MipmapState(), new MipmapState(), new MipmapState(), new MipmapState(), new MipmapState(), new MipmapState(), new MipmapState()];
        this.textureProjectionMapMode = TextureProjectionMapMode.GU_NORMAL;
        this.textureMapMode = TextureMapMode.GU_TEXTURE_COORDS;
        this.slopeLevel = 0;
        this.levelMode = TextureLevelMode.Auto;
        this.mipmapBias = 1.0;
    }
    TextureState.prototype.getTextureComponentsCount = function () {
        switch (this.textureMapMode) {
            default: throw (new Error("Invalid textureMapMode"));
            case TextureMapMode.GU_TEXTURE_COORDS: return 2;
            case TextureMapMode.GU_TEXTURE_MATRIX:
                switch (this.textureProjectionMapMode) {
                    case TextureProjectionMapMode.GU_NORMAL: return 3;
                    case TextureProjectionMapMode.GU_NORMALIZED_NORMAL: return 3;
                    case TextureProjectionMapMode.GU_POSITION: return 3;
                    case TextureProjectionMapMode.GU_UV: return 2;
                    default: return 2;
                }
                break;
            case TextureMapMode.GU_ENVIRONMENT_MAP: return 2;
        }
    };
    return TextureState;
})();
exports.TextureState = TextureState;
var CullingState = (function () {
    function CullingState() {
        this.enabled = false;
        this.direction = CullingDirection.ClockWise;
    }
    return CullingState;
})();
exports.CullingState = CullingState;
(function (TestFunctionEnum) {
    TestFunctionEnum[TestFunctionEnum["Never"] = 0] = "Never";
    TestFunctionEnum[TestFunctionEnum["Always"] = 1] = "Always";
    TestFunctionEnum[TestFunctionEnum["Equal"] = 2] = "Equal";
    TestFunctionEnum[TestFunctionEnum["NotEqual"] = 3] = "NotEqual";
    TestFunctionEnum[TestFunctionEnum["Less"] = 4] = "Less";
    TestFunctionEnum[TestFunctionEnum["LessOrEqual"] = 5] = "LessOrEqual";
    TestFunctionEnum[TestFunctionEnum["Greater"] = 6] = "Greater";
    TestFunctionEnum[TestFunctionEnum["GreaterOrEqual"] = 7] = "GreaterOrEqual";
})(exports.TestFunctionEnum || (exports.TestFunctionEnum = {}));
var TestFunctionEnum = exports.TestFunctionEnum;
var DepthTestState = (function () {
    function DepthTestState() {
        this.updated = false;
        this.enabled = false;
        this.func = TestFunctionEnum.Always;
        this.mask = 0;
        this.rangeFar = 1;
        this.rangeNear = 0;
    }
    return DepthTestState;
})();
exports.DepthTestState = DepthTestState;
(function (ShadingModelEnum) {
    ShadingModelEnum[ShadingModelEnum["Flat"] = 0] = "Flat";
    ShadingModelEnum[ShadingModelEnum["Smooth"] = 1] = "Smooth";
})(exports.ShadingModelEnum || (exports.ShadingModelEnum = {}));
var ShadingModelEnum = exports.ShadingModelEnum;
(function (GuBlendingFactor) {
    GuBlendingFactor[GuBlendingFactor["GU_SRC_COLOR"] = 0] = "GU_SRC_COLOR";
    GuBlendingFactor[GuBlendingFactor["GU_ONE_MINUS_SRC_COLOR"] = 1] = "GU_ONE_MINUS_SRC_COLOR";
    GuBlendingFactor[GuBlendingFactor["GU_SRC_ALPHA"] = 2] = "GU_SRC_ALPHA";
    GuBlendingFactor[GuBlendingFactor["GU_ONE_MINUS_SRC_ALPHA"] = 3] = "GU_ONE_MINUS_SRC_ALPHA";
    GuBlendingFactor[GuBlendingFactor["GU_DST_ALPHA"] = 4] = "GU_DST_ALPHA";
    GuBlendingFactor[GuBlendingFactor["GU_ONE_MINUS_DST_ALPHA"] = 5] = "GU_ONE_MINUS_DST_ALPHA";
    GuBlendingFactor[GuBlendingFactor["GU_FIX"] = 10] = "GU_FIX";
})(exports.GuBlendingFactor || (exports.GuBlendingFactor = {}));
var GuBlendingFactor = exports.GuBlendingFactor;
(function (GuBlendingEquation) {
    GuBlendingEquation[GuBlendingEquation["Add"] = 0] = "Add";
    GuBlendingEquation[GuBlendingEquation["Substract"] = 1] = "Substract";
    GuBlendingEquation[GuBlendingEquation["ReverseSubstract"] = 2] = "ReverseSubstract";
    GuBlendingEquation[GuBlendingEquation["Min"] = 3] = "Min";
    GuBlendingEquation[GuBlendingEquation["Max"] = 4] = "Max";
    GuBlendingEquation[GuBlendingEquation["Abs"] = 5] = "Abs";
})(exports.GuBlendingEquation || (exports.GuBlendingEquation = {}));
var GuBlendingEquation = exports.GuBlendingEquation;
var Color = (function () {
    function Color(r, g, b, a) {
        if (r === void 0) { r = 0; }
        if (g === void 0) { g = 0; }
        if (b === void 0) { b = 0; }
        if (a === void 0) { a = 1; }
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    Color.prototype.setRGB = function (rgb) {
        this.r = BitUtils.extractScale1f(rgb, 0, 8);
        this.g = BitUtils.extractScale1f(rgb, 8, 8);
        this.b = BitUtils.extractScale1f(rgb, 16, 8);
        this.a = 1;
    };
    Color.prototype.set = function (r, g, b, a) {
        if (a === void 0) { a = 1; }
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
        return this;
    };
    Color.add = function (a, b, dest) {
        if (dest === void 0) { dest = null; }
        if (dest == null)
            dest = new Color();
        dest.r = a.r + b.r;
        dest.g = a.g + b.g;
        dest.b = a.b + b.b;
        dest.a = a.a * b.a;
        return dest;
    };
    Color.prototype.equals = function (r, g, b, a) {
        return (this.r == r) && (this.g == g) && (this.b == b) && (this.a == a);
    };
    return Color;
})();
exports.Color = Color;
var Blending = (function () {
    function Blending() {
        this._alpha = -1;
        this._colorMask = -1;
        this._colorMaskA = -1;
        this.enabled = false;
        this.updated = false;
        this.functionSource = GuBlendingFactor.GU_SRC_ALPHA;
        this.functionDestination = GuBlendingFactor.GU_ONE_MINUS_DST_ALPHA;
        this.equation = GuBlendingEquation.Add;
        this._fixColorSourceWord = -1;
        this._fixColorDestinationWord = -1;
        this.fixColorSource = new Color();
        this.fixColorDestination = new Color();
        this.colorMask = { r: 0, g: 0, b: 0, a: 0 };
    }
    return Blending;
})();
exports.Blending = Blending;
var AlphaTest = (function () {
    function AlphaTest() {
        this._atst = -1;
        this.enabled = false;
        this.value = 0;
        this.mask = 0xFF;
        this.func = TestFunctionEnum.Always;
    }
    return AlphaTest;
})();
exports.AlphaTest = AlphaTest;
var Rectangle = (function () {
    function Rectangle(top, left, right, bottom) {
        this.top = top;
        this.left = left;
        this.right = right;
        this.bottom = bottom;
    }
    Object.defineProperty(Rectangle.prototype, "width", {
        get: function () { return this.right - this.left; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rectangle.prototype, "height", {
        get: function () { return this.bottom - this.top; },
        enumerable: true,
        configurable: true
    });
    return Rectangle;
})();
exports.Rectangle = Rectangle;
var ClipPlane = (function () {
    function ClipPlane() {
        this.updated = false;
        this.enabled = true;
        this.scissor = new Rectangle(0, 0, 512, 272);
        this._scissorLeftTop = -1;
        this._scissorRightBottom = -1;
    }
    return ClipPlane;
})();
exports.ClipPlane = ClipPlane;
var SkinningState = (function () {
    function SkinningState() {
        this._currentBoneIndex = 0;
        this.boneMatrices = [new Matrix4x3(), new Matrix4x3(), new Matrix4x3(), new Matrix4x3(), new Matrix4x3(), new Matrix4x3(), new Matrix4x3(), new Matrix4x3()];
        this.linear = new Float32Array(96);
        this._currentBoneMatrix = 0;
        this._currentBoneMatrixIndex = 0;
    }
    SkinningState.prototype.setCurrentBoneIndex = function (index) {
        this._currentBoneIndex = index;
        this._currentBoneMatrix = ToInt32(this._currentBoneIndex / 12);
        this._currentBoneMatrixIndex = ToInt32(this._currentBoneIndex % 12);
    };
    SkinningState.prototype._increment = function () {
        this._currentBoneMatrixIndex++;
        this._currentBoneIndex++;
        if (this._currentBoneMatrixIndex >= 12) {
            this._currentBoneMatrix++;
            this._currentBoneMatrixIndex = 0;
        }
    };
    SkinningState.prototype.check = function (value) {
        var check = (this.linear[this._currentBoneIndex] == value);
        if (check)
            this._increment();
        return check;
    };
    SkinningState.prototype.write = function (value) {
        this.linear[this._currentBoneIndex] = value;
        this.boneMatrices[this._currentBoneMatrix].putAt(this._currentBoneMatrixIndex, value);
        this._increment();
    };
    return SkinningState;
})();
exports.SkinningState = SkinningState;
(function (StencilOperationEnum) {
    StencilOperationEnum[StencilOperationEnum["Keep"] = 0] = "Keep";
    StencilOperationEnum[StencilOperationEnum["Zero"] = 1] = "Zero";
    StencilOperationEnum[StencilOperationEnum["Replace"] = 2] = "Replace";
    StencilOperationEnum[StencilOperationEnum["Invert"] = 3] = "Invert";
    StencilOperationEnum[StencilOperationEnum["Increment"] = 4] = "Increment";
    StencilOperationEnum[StencilOperationEnum["Decrement"] = 5] = "Decrement";
})(exports.StencilOperationEnum || (exports.StencilOperationEnum = {}));
var StencilOperationEnum = exports.StencilOperationEnum;
var StencilState = (function () {
    function StencilState() {
        this.stst = -1;
        this.sop = -1;
        this.enabled = false;
        this.fail = StencilOperationEnum.Keep;
        this.zpass = StencilOperationEnum.Keep;
        this.zfail = StencilOperationEnum.Keep;
        this.func = TestFunctionEnum.Always;
        this.funcRef = 0;
        this.funcMask = 0;
    }
    return StencilState;
})();
exports.StencilState = StencilState;
var PatchState = (function () {
    function PatchState() {
        this._divst = -1;
        this.divs = 0;
        this.divt = 0;
    }
    return PatchState;
})();
exports.PatchState = PatchState;
var Fog = (function () {
    function Fog() {
        this._color = -1;
        this.enabled = false;
        this.far = 0;
        this.dist = 1;
        this.color = new Color();
    }
    return Fog;
})();
exports.Fog = Fog;
var LogicOp = (function () {
    function LogicOp() {
        this.enabled = false;
    }
    return LogicOp;
})();
exports.LogicOp = LogicOp;
var LineSmoothState = (function () {
    function LineSmoothState() {
        this.enabled = false;
    }
    return LineSmoothState;
})();
exports.LineSmoothState = LineSmoothState;
var PatchCullingState = (function () {
    function PatchCullingState() {
        this.enabled = false;
        this.faceFlag = false;
    }
    return PatchCullingState;
})();
exports.PatchCullingState = PatchCullingState;
var GpuState = (function () {
    function GpuState() {
        this._clearingWord = -1;
        this._ambientModelColor = -1;
        this._ambientModelColorAlpha = -1;
        this._ambientLightColorAlpha = -1;
        this._diffuseModelColor = -1;
        this._specularModelColor = -1;
        this.clearing = false;
        this.clearFlags = 0;
        this.baseAddress = 0;
        this.baseOffset = 0;
        this.indexAddress = 0;
        this.shadeModel = ShadingModelEnum.Flat;
        this.frameBuffer = new GpuFrameBufferState();
        this.vertex = new VertexState();
        this.stencil = new StencilState();
        this.skinning = new SkinningState();
        this.morphWeights = [1, 0, 0, 0, 0, 0, 0, 0];
        this.projectionMatrix = new Matrix4x4();
        this.viewMatrix = new Matrix4x3();
        this.worldMatrix = new Matrix4x3();
        this.viewport = new ViewPort();
        this.region = new Region();
        this.offset = { x: 0, y: 0 };
        this.fog = new Fog();
        this.clipPlane = new ClipPlane();
        this.logicOp = new LogicOp();
        this.lightning = new Lightning();
        this.alphaTest = new AlphaTest();
        this.blending = new Blending();
        this.patch = new PatchState();
        this.texture = new TextureState();
        this.lineSmoothState = new LineSmoothState();
        this.patchCullingState = new PatchCullingState();
        this.ambientModelColor = new ColorState();
        this.diffuseModelColor = new ColorState();
        this.specularModelColor = new ColorState();
        this.culling = new CullingState();
        this.dithering = new DitheringState();
        this.colorTest = new ColorTestState();
        this.depthTest = new DepthTestState();
        this.drawPixelFormat = PixelFormat.RGBA_8888;
    }
    GpuState.prototype.getAddressRelativeToBase = function (relativeAddress) { return (this.baseAddress | relativeAddress); };
    GpuState.prototype.getAddressRelativeToBaseOffset = function (relativeAddress) { return ((this.baseAddress | relativeAddress) + this.baseOffset); };
    return GpuState;
})();
exports.GpuState = GpuState;
var ColorTestState = (function () {
    function ColorTestState() {
        this.enabled = false;
    }
    return ColorTestState;
})();
exports.ColorTestState = ColorTestState;
var DitheringState = (function () {
    function DitheringState() {
        this.enabled = false;
    }
    return DitheringState;
})();
exports.DitheringState = DitheringState;
(function (WrapMode) {
    WrapMode[WrapMode["Repeat"] = 0] = "Repeat";
    WrapMode[WrapMode["Clamp"] = 1] = "Clamp";
})(exports.WrapMode || (exports.WrapMode = {}));
var WrapMode = exports.WrapMode;
(function (TextureEffect) {
    TextureEffect[TextureEffect["Modulate"] = 0] = "Modulate";
    TextureEffect[TextureEffect["Decal"] = 1] = "Decal";
    TextureEffect[TextureEffect["Blend"] = 2] = "Blend";
    TextureEffect[TextureEffect["Replace"] = 3] = "Replace";
    TextureEffect[TextureEffect["Add"] = 4] = "Add";
})(exports.TextureEffect || (exports.TextureEffect = {}));
var TextureEffect = exports.TextureEffect;
(function (TextureFilter) {
    TextureFilter[TextureFilter["Nearest"] = 0] = "Nearest";
    TextureFilter[TextureFilter["Linear"] = 1] = "Linear";
    TextureFilter[TextureFilter["NearestMipmapNearest"] = 4] = "NearestMipmapNearest";
    TextureFilter[TextureFilter["LinearMipmapNearest"] = 5] = "LinearMipmapNearest";
    TextureFilter[TextureFilter["NearestMipmapLinear"] = 6] = "NearestMipmapLinear";
    TextureFilter[TextureFilter["LinearMipmapLinear"] = 7] = "LinearMipmapLinear";
})(exports.TextureFilter || (exports.TextureFilter = {}));
var TextureFilter = exports.TextureFilter;
(function (TextureColorComponent) {
    TextureColorComponent[TextureColorComponent["Rgb"] = 0] = "Rgb";
    TextureColorComponent[TextureColorComponent["Rgba"] = 1] = "Rgba";
})(exports.TextureColorComponent || (exports.TextureColorComponent = {}));
var TextureColorComponent = exports.TextureColorComponent;
(function (PrimitiveType) {
    PrimitiveType[PrimitiveType["Points"] = 0] = "Points";
    PrimitiveType[PrimitiveType["Lines"] = 1] = "Lines";
    PrimitiveType[PrimitiveType["LineStrip"] = 2] = "LineStrip";
    PrimitiveType[PrimitiveType["Triangles"] = 3] = "Triangles";
    PrimitiveType[PrimitiveType["TriangleStrip"] = 4] = "TriangleStrip";
    PrimitiveType[PrimitiveType["TriangleFan"] = 5] = "TriangleFan";
    PrimitiveType[PrimitiveType["Sprites"] = 6] = "Sprites";
})(exports.PrimitiveType || (exports.PrimitiveType = {}));
var PrimitiveType = exports.PrimitiveType;

},
"src/core/gpu/vertex": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _state = require('./state');
var _IndentStringGenerator = require('../../util/IndentStringGenerator');
var ColorEnum = _state.ColorEnum;
var VertexBuffer = (function () {
    function VertexBuffer() {
        this.offsetLength = 0;
        this.vertices = [];
        this.triangleStripOffset = 0;
    }
    VertexBuffer.prototype.reset = function () {
        this.offsetLength = 0;
    };
    VertexBuffer.prototype.take = function (count) {
        var result = this.offsetLength;
        this.offsetLength += count;
        return result;
    };
    VertexBuffer.prototype.startDegenerateTriangleStrip = function () {
        this.triangleStripOffset = this.ensureAndTake(2);
    };
    VertexBuffer.prototype.endDegenerateTriangleStrip = function () {
        var offset = this.triangleStripOffset;
        this.vertices[offset + 0].copyFrom(this.vertices[offset - 1]);
        this.vertices[offset + 1].copyFrom(this.vertices[offset + 2]);
    };
    VertexBuffer.prototype.ensure = function (count) {
        count += this.offsetLength;
        while (this.vertices.length < count)
            this.vertices.push(new _state.Vertex());
    };
    VertexBuffer.prototype.ensureAndTake = function (count) {
        this.ensure(count);
        return this.take(count);
    };
    return VertexBuffer;
})();
exports.VertexBuffer = VertexBuffer;
var VertexReaderFactory = (function () {
    function VertexReaderFactory() {
    }
    VertexReaderFactory.get = function (vertexState) {
        var cacheId = vertexState.hash;
        var vertexReader = this.cache[cacheId];
        if (vertexReader === undefined)
            vertexReader = this.cache[cacheId] = new VertexReader(vertexState.clone());
        return vertexReader;
    };
    VertexReaderFactory.cache = {};
    return VertexReaderFactory;
})();
exports.VertexReaderFactory = VertexReaderFactory;
var VertexReader = (function () {
    function VertexReader(vertexState) {
        this.vertexState = vertexState;
        this.readOffset = 0;
        this.oneOuput = [new _state.Vertex()];
        this.oneIndices = [0];
        this.input2 = new Uint8Array(1 * 1024 * 1024);
        this.s8 = new Int8Array(this.input2.buffer);
        this.s16 = new Int16Array(this.input2.buffer);
        this.s32 = new Int32Array(this.input2.buffer);
        this.f32 = new Float32Array(this.input2.buffer);
        this.readCode = this.createJs();
        this.readOneFunc = (new Function('output', 'inputOffset', 'f32', 's8', 's16', 's32', '"use strict";' + this.readCode));
    }
    VertexReader.prototype.readOne = function (input, index) {
        this.oneIndices[0] = index;
        this.oneOuput[0] = new _state.Vertex();
        this.readCount(this.oneOuput, 0, input, this.oneIndices, 1, true);
        return this.oneOuput[0];
    };
    VertexReader.prototype.readCount = function (output, verticesOffset, input, indices, count, hasIndex) {
        if (hasIndex) {
            var maxDatacount = 0;
            for (var n = 0; n < count; n++)
                maxDatacount = Math.max(maxDatacount, indices[n] + 1);
        }
        else {
            maxDatacount = count;
        }
        maxDatacount *= this.vertexState.size;
        this.input2.set(new Uint8Array(input.buffer, input.byteOffset, maxDatacount));
        if (hasIndex) {
            for (var n = 0; n < count; n++) {
                var index = indices[n];
                this.readOneFunc(output[verticesOffset + n], index * this.vertexState.size, this.f32, this.s8, this.s16, this.s32);
            }
        }
        else {
            var inputOffset = 0;
            for (var n = 0; n < count; n++) {
                this.readOneFunc(output[verticesOffset + n], inputOffset, this.f32, this.s8, this.s16, this.s32);
                inputOffset += this.vertexState.size;
            }
        }
    };
    VertexReader.prototype.createJs = function () {
        var indentStringGenerator = new _IndentStringGenerator();
        this.readOffset = 0;
        var normalize = !this.vertexState.transform2D;
        this.createNumberJs([1, 0x80, 0x8000, 1], true, indentStringGenerator, ['w0', 'w1', 'w2', 'w3', 'w4', 'w5', 'w6', 'w7'].slice(0, this.vertexState.realWeightCount), this.vertexState.weight, normalize);
        this.createNumberJs([1, 0x80, 0x8000, 1], false, indentStringGenerator, ['tx', 'ty', 'tx'].slice(0, this.vertexState.textureComponentCount), this.vertexState.texture, normalize);
        this.createColorJs(indentStringGenerator, this.vertexState.color);
        this.createNumberJs([1, 0x7F, 0x7FFF, 1], true, indentStringGenerator, ['nx', 'ny', 'nz'], this.vertexState.normal, normalize);
        this.createNumberJs([1, 0x7F, 0x7FFF, 1], true, indentStringGenerator, ['px', 'py', 'pz'], this.vertexState.position, normalize);
        return indentStringGenerator.output;
    };
    VertexReader.prototype.readInt8 = function () { return '(s8[inputOffset + ' + this.getOffsetAlignAndIncrement(1) + '])'; };
    VertexReader.prototype.readInt16 = function () { return '(s16[(inputOffset + ' + this.getOffsetAlignAndIncrement(2) + ') >> 1])'; };
    VertexReader.prototype.readInt32 = function () { return '(s32[(inputOffset + ' + this.getOffsetAlignAndIncrement(4) + ') >> 2])'; };
    VertexReader.prototype.readFloat32 = function () { return '(f32[(inputOffset + ' + this.getOffsetAlignAndIncrement(4) + ') >> 2])'; };
    VertexReader.prototype.readUInt8 = function () { return '((' + this.readInt8() + ' & 0xFF) >>> 0)'; };
    VertexReader.prototype.readUInt16 = function () { return '((' + this.readInt16() + ' & 0xFFFF) >>> 0)'; };
    VertexReader.prototype.readUInt32 = function () { return '((' + this.readInt32() + ' & 0xFFFFFFFF) >>> 0)'; };
    VertexReader.prototype.createColorJs = function (indentStringGenerator, type) {
        if (type == ColorEnum.Void)
            return;
        var alignment = 4;
        var sizes = [8, 8, 8, 8];
        var components = ['r', 'g', 'b', 'a'];
        switch (type) {
            case ColorEnum.Color8888:
                alignment = 4;
                sizes = [8, 8, 8, 8];
                break;
            case ColorEnum.Color5551:
                alignment = 2;
                sizes = [5, 5, 5, 1];
                break;
            case ColorEnum.Color4444:
                alignment = 2;
                sizes = [4, 4, 4, 4];
                break;
            case ColorEnum.Color5650:
                alignment = 2;
                sizes = [5, 6, 5, 0];
                break;
            default: throw (new Error("Not implemented color format '" + type + "'"));
        }
        this.align(alignment);
        indentStringGenerator.write('var temp = (' + ((alignment == 2) ? this.readUInt16() : this.readUInt32()) + ');\n');
        var offset = 0;
        for (var n = 0; n < 4; n++) {
            var size = sizes[n], component = components[n];
            indentStringGenerator.write('output.' + component + ' = ');
            indentStringGenerator.write((size != 0) ? ('(((temp >> ' + offset + ') & ' + BitUtils.mask(size) + ') / ' + BitUtils.mask(size) + ');') : '1.0');
            indentStringGenerator.write('\n');
            offset += size;
        }
    };
    VertexReader.prototype.align = function (count) {
        this.readOffset = MathUtils.nextAligned(this.readOffset, count);
    };
    VertexReader.prototype.getOffsetAlignAndIncrement = function (size) {
        this.align(size);
        var offset = this.readOffset;
        this.readOffset += size;
        return offset;
    };
    VertexReader.prototype.createNumberJs = function (scales, signed, indentStringGenerator, components, type, normalize) {
        var _this = this;
        if (type == _state.NumericEnum.Void)
            return;
        components.forEach(function (component) {
            switch (type) {
                case _state.NumericEnum.Byte:
                    indentStringGenerator.write('output.' + component + ' = ' + (signed ? _this.readInt8() : _this.readUInt8()));
                    break;
                case _state.NumericEnum.Short:
                    indentStringGenerator.write('output.' + component + ' = ' + (signed ? _this.readInt16() : _this.readUInt16()));
                    break;
                case _state.NumericEnum.Float:
                    indentStringGenerator.write('output.' + component + ' = ' + (_this.readFloat32()));
                    break;
            }
            if (normalize && (scales[type] != 1))
                indentStringGenerator.write(' * ' + (1 / scales[type]));
            indentStringGenerator.write(';\n');
        });
    };
    return VertexReader;
})();
exports.VertexReader = VertexReader;

},
"src/core/gpu/webgl/driver": function(module, exports, require) {
///<reference path="../../../global.d.ts" />
var _state = require('../state');
var _shader = require('./shader');
var _texture = require('./texture');
var _utils = require('./utils');
var FastFloat32Buffer = _utils.FastFloat32Buffer;
var ShaderCache = _shader.ShaderCache;
var TextureHandler = _texture.TextureHandler;
var WebGlPspDrawDriver = (function () {
    function WebGlPspDrawDriver(memory, display, canvas) {
        this.memory = memory;
        this.display = display;
        this.canvas = canvas;
        this.baseShaderFragString = '';
        this.baseShaderVertString = '';
        this.transformMatrix = mat4.create();
        this.transformMatrix2d = mat4.create();
        this.equationTranslate = null;
        this.opsConvertTable = null;
        this.testConvertTable = null;
        this.testConvertTable_inv = null;
        this.vertexPool = [];
        this.vertexPool2 = [];
        this.testCount = 20;
        this.positionData = new FastFloat32Buffer();
        this.colorData = new FastFloat32Buffer();
        this.textureData = new FastFloat32Buffer();
        this.normalData = new FastFloat32Buffer();
        this.vertexWeightData1 = new FastFloat32Buffer();
        this.vertexWeightData2 = new FastFloat32Buffer();
        this.lastBaseAddress = 0;
        this.tempVec = new Float32Array([0, 0, 0]);
        this.texMat = mat4.create();
        this.convertPrimitiveType = null;
        var webglOptions = {
            alpha: false,
            depth: true,
            stencil: true,
            preserveDrawingBuffer: true,
        };
        this.gl = this.canvas.getContext('webgl', webglOptions);
        if (!this.gl)
            this.gl = this.canvas.getContext('experimental-webgl', webglOptions);
        if (!this.gl) {
            alert("Can't initialize WebGL!");
            throw (new Error("Can't initialize WebGL!"));
        }
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
        this.transformMatrix2d = mat4.ortho(mat4.create(), 0, 480, 272, 0, 0, -0xFFFF);
    }
    WebGlPspDrawDriver.prototype.initAsync = function () {
        var _this = this;
        return downloadFileAsync('data/shader.vert').then(function (shaderVert) {
            return downloadFileAsync('data/shader.frag').then(function (shaderFrag) {
                var shaderVertString = Stream.fromArrayBuffer(shaderVert).readUtf8String(shaderVert.byteLength);
                var shaderFragString = Stream.fromArrayBuffer(shaderFrag).readUtf8String(shaderFrag.byteLength);
                _this.cache = new ShaderCache(_this.gl, shaderVertString, shaderFragString);
                _this.textureHandler = new TextureHandler(_this.memory, _this.gl);
            });
        });
    };
    WebGlPspDrawDriver.prototype.setClearMode = function (clearing, flags) {
        this.clearing = clearing;
        this.clearingFlags = flags;
    };
    WebGlPspDrawDriver.prototype.end = function () {
        this.textureHandler.end();
    };
    WebGlPspDrawDriver.prototype.setMatrices = function (projectionMatrix, viewMatrix, worldMatrix) {
        this.projectionMatrix = projectionMatrix;
        this.viewMatrix = viewMatrix;
        this.worldMatrix = worldMatrix;
        mat4.identity(this.transformMatrix);
        mat4.multiply(this.transformMatrix, this.transformMatrix, this.projectionMatrix.values);
        mat4.multiply(this.transformMatrix, this.transformMatrix, this.viewMatrix.values);
        mat4.multiply(this.transformMatrix, this.transformMatrix, this.worldMatrix.values);
    };
    WebGlPspDrawDriver.prototype.enableDisable = function (type, enable) {
        if (enable)
            this.gl.enable(type);
        else
            this.gl.disable(type);
        return enable;
    };
    WebGlPspDrawDriver.prototype.setState = function (state) {
        this.state = state;
    };
    WebGlPspDrawDriver.prototype.updateNormalState = function (program, vertexState, primitiveType) {
        var state = this.state;
        var gl = this.gl;
        if (!this.equationTranslate)
            this.equationTranslate = [gl.FUNC_ADD, gl.FUNC_SUBTRACT, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD, gl.FUNC_ADD, gl.FUNC_ADD];
        if (!this.opsConvertTable)
            this.opsConvertTable = [gl.KEEP, gl.ZERO, gl.REPLACE, gl.INVERT, gl.INCR, gl.DECR];
        if (!this.testConvertTable)
            this.testConvertTable = [gl.NEVER, gl.ALWAYS, gl.EQUAL, gl.NOTEQUAL, gl.LESS, gl.LEQUAL, gl.GREATER, gl.GEQUAL];
        if (!this.testConvertTable_inv)
            this.testConvertTable_inv = [gl.NEVER, gl.ALWAYS, gl.EQUAL, gl.NOTEQUAL, gl.GREATER, gl.GEQUAL, gl.LESS, gl.LEQUAL];
        if (this.enableDisable(gl.CULL_FACE, state.culling.enabled && (primitiveType != _state.PrimitiveType.Sprites))) {
            gl.cullFace((state.culling.direction == _state.CullingDirection.ClockWise) ? gl.FRONT : gl.BACK);
        }
        if (!state.clipPlane.updated) {
            state.clipPlane.updated = true;
            if (this.enableDisable(gl.SCISSOR_TEST, state.clipPlane.enabled)) {
                var rect = state.clipPlane.scissor;
                var ratio = this.getScaleRatio();
                gl.scissor(rect.left * ratio, rect.top * ratio, rect.width * ratio, rect.height * ratio);
            }
        }
        if (!this.state.blending.updated) {
            this.state.blending.updated = true;
            var blending = state.blending;
            if (this.enableDisable(gl.BLEND, blending.enabled)) {
                var getBlendFix = function (color) {
                    if (color.equals(0, 0, 0, 1))
                        return gl.ZERO;
                    if (color.equals(1, 1, 1, 1))
                        return gl.ONE;
                    return gl.CONSTANT_COLOR;
                };
                var sfactor = gl.SRC_COLOR + blending.functionSource;
                var dfactor = gl.SRC_COLOR + blending.functionDestination;
                if (blending.functionSource == _state.GuBlendingFactor.GU_FIX) {
                    sfactor = getBlendFix(blending.fixColorSource);
                }
                if (blending.functionDestination == _state.GuBlendingFactor.GU_FIX) {
                    if ((sfactor == gl.CONSTANT_COLOR) && ((_state.Color.add(blending.fixColorSource, blending.fixColorDestination).equals(1, 1, 1, 1)))) {
                        dfactor = gl.ONE_MINUS_CONSTANT_COLOR;
                    }
                    else {
                        dfactor = getBlendFix(blending.fixColorDestination);
                    }
                }
                gl.blendEquation(this.equationTranslate[blending.equation]);
                gl.blendFunc(sfactor, dfactor);
                switch (blending.equation) {
                    case _state.GuBlendingEquation.Abs:
                    case _state.GuBlendingEquation.Max:
                    case _state.GuBlendingEquation.Min:
                    case _state.GuBlendingEquation.Add:
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case _state.GuBlendingEquation.Substract:
                        gl.blendEquation(gl.FUNC_SUBTRACT);
                        break;
                    case _state.GuBlendingEquation.ReverseSubstract:
                        gl.blendEquation(gl.FUNC_REVERSE_SUBTRACT);
                        break;
                }
                var blendColor = blending.fixColorDestination;
                gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendColor.a);
            }
        }
        var stencil = state.stencil;
        if (this.enableDisable(gl.STENCIL_TEST, stencil.enabled)) {
            gl.stencilFunc(this.testConvertTable[stencil.func], stencil.funcRef, stencil.funcMask);
            gl.stencilOp(this.opsConvertTable[stencil.fail], this.opsConvertTable[stencil.zfail], this.opsConvertTable[stencil.zpass]);
        }
        if (!this.state.depthTest.updated) {
            this.state.depthTest.updated = true;
            gl.depthRange(state.depthTest.rangeFar, state.depthTest.rangeNear);
            gl.depthMask(state.depthTest.mask == 0);
            if (this.enableDisable(gl.DEPTH_TEST, state.depthTest.enabled)) {
                gl.depthFunc(this.testConvertTable_inv[state.depthTest.func]);
            }
        }
        var alphaTest = state.alphaTest;
        if (alphaTest.enabled) {
            program.getUniform('alphaTestFunc').set1i(alphaTest.func);
            program.getUniform('alphaTestReference').set1i(alphaTest.value);
            program.getUniform('alphaTestMask').set1i(alphaTest.mask);
        }
        else {
        }
    };
    WebGlPspDrawDriver.prototype.updateClearStateEnd = function (program, vertexState, primitiveType) {
        var gl = this.gl;
        gl.colorMask(true, true, true, true);
    };
    WebGlPspDrawDriver.prototype.updateClearStateStart = function (program, vertexState, primitiveType) {
        var state = this.state;
        var gl = this.gl;
        var ccolorMask = false, calphaMask = false;
        var clearingFlags = this.clearingFlags;
        gl.disable(gl.SCISSOR_TEST);
        state.clipPlane.updated = false;
        gl.disable(gl.BLEND);
        this.state.blending.updated = false;
        gl.disable(gl.DEPTH_TEST);
        this.state.depthTest.updated = false;
        gl.disable(gl.STENCIL_TEST);
        gl.disable(gl.CULL_FACE);
        gl.depthMask(false);
        if (clearingFlags & ClearBufferSet.ColorBuffer) {
            ccolorMask = true;
        }
        if (clearingFlags & ClearBufferSet.StencilBuffer) {
            calphaMask = true;
            gl.enable(gl.STENCIL_TEST);
            gl.stencilFunc(gl.ALWAYS, 0x00, 0xFF);
            gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE);
        }
        if (clearingFlags & ClearBufferSet.DepthBuffer) {
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.ALWAYS);
            gl.depthMask(true);
            gl.depthRange(state.depthTest.rangeNear, state.depthTest.rangeNear);
        }
        gl.colorMask(ccolorMask, ccolorMask, ccolorMask, calphaMask);
    };
    WebGlPspDrawDriver.prototype.updateCommonState = function (program, vertexState, primitiveType) {
        var viewport = this.state.viewport;
        var x = 2048 - viewport.x;
        var y = 2048 - viewport.y;
        var width = Math.abs(viewport.width * 2);
        var height = Math.abs(-viewport.height * 2);
        var ratio = this.getScaleRatio();
        this.gl.viewport(x * ratio, y * ratio, width * ratio, height * ratio);
    };
    WebGlPspDrawDriver.prototype.updateState = function (program, vertexState, primitiveType) {
        if (this.state.clearing) {
            this.updateClearStateStart(program, vertexState, primitiveType);
        }
        else {
            this.updateNormalState(program, vertexState, primitiveType);
        }
        this.updateCommonState(program, vertexState, primitiveType);
    };
    WebGlPspDrawDriver.prototype.getScaleRatio = function () {
        return this.canvas.width / 480;
    };
    WebGlPspDrawDriver.prototype.drawElements = function (state, primitiveType, vertices, count, vertexState) {
        if (count == 0)
            return;
        this.setState(state);
        this.setClearMode(state.clearing, state.clearFlags);
        this.setMatrices(state.projectionMatrix, state.viewMatrix, state.worldMatrix);
        this.display.setEnabledDisplay(false);
        if (primitiveType == _state.PrimitiveType.Sprites) {
            return this.drawSprites(vertices, count, vertexState);
        }
        else {
            return this.drawElementsInternal(primitiveType, primitiveType, vertices, count, vertexState);
        }
    };
    WebGlPspDrawDriver.prototype.textureFlush = function (state) {
        this.textureHandler.flush();
    };
    WebGlPspDrawDriver.prototype.textureSync = function (state) {
        this.textureHandler.sync();
    };
    WebGlPspDrawDriver.prototype.drawSprites = function (vertices, count, vertexState) {
        var vertexPool = this.vertexPool;
        while (vertexPool.length < count * 2)
            vertexPool.push(new _state.Vertex());
        var inCount = 0;
        this.vertexPool2.length = Math.max(this.vertexPool2.length, count * 3);
        var outCount = 0;
        for (var n = 0; n < count; n += 2) {
            var tl = vertexPool[inCount++].copyFromBasic(vertices[n + 0]);
            var br = vertexPool[inCount++].copyFromBasic(vertices[n + 1]);
            tl.r = br.r;
            tl.g = br.g;
            tl.b = br.b;
            tl.a = br.a;
            var vtr = vertexPool[inCount++].copyFromBasic(tl);
            var vbl = vertexPool[inCount++].copyFromBasic(br);
            vtr.px = br.px;
            vtr.py = tl.py;
            vtr.tx = br.tx;
            vtr.ty = tl.ty;
            vbl.px = tl.px;
            vbl.py = br.py;
            vbl.tx = tl.tx;
            vbl.ty = br.ty;
            this.vertexPool2[outCount++] = tl;
            this.vertexPool2[outCount++] = vtr;
            this.vertexPool2[outCount++] = vbl;
            this.vertexPool2[outCount++] = vtr;
            this.vertexPool2[outCount++] = br;
            this.vertexPool2[outCount++] = vbl;
        }
        this.drawElementsInternal(_state.PrimitiveType.Sprites, _state.PrimitiveType.Triangles, this.vertexPool2, outCount, vertexState);
    };
    WebGlPspDrawDriver.prototype.demuxVertices = function (vertices, count, vertexState, primitiveType, originalPrimitiveType) {
        var textureState = this.state.texture;
        var weightCount = vertexState.realWeightCount;
        this.positionData.restart();
        this.colorData.restart();
        this.textureData.restart();
        this.normalData.restart();
        this.vertexWeightData1.restart();
        this.vertexWeightData2.restart();
        var mipmap = this.state.texture.mipmaps[0];
        for (var n = 0; n < count; n++) {
            var v = vertices[n];
            this.positionData.push3(v.px, v.py, vertexState.transform2D ? 0.0 : v.pz);
            if (vertexState.hasColor)
                this.colorData.push4(v.r, v.g, v.b, v.a);
            if (vertexState.hasTexture)
                this.textureData.push3(v.tx, v.ty, v.tz);
            if (vertexState.hasNormal)
                this.normalData.push3(v.nx, v.ny, v.nz);
            if (weightCount >= 1) {
                this.vertexWeightData1.push4(v.w0, v.w1, v.w2, v.w3);
                if (weightCount >= 4) {
                    this.vertexWeightData2.push4(v.w4, v.w5, v.w6, v.w7);
                }
            }
        }
    };
    WebGlPspDrawDriver.prototype.prepareTexture = function (gl, program, vertexState) {
        if (vertexState.hasTexture) {
            this.textureHandler.bindTexture(program, this.state);
        }
        else {
            this.textureHandler.unbindTexture(program, this.state);
        }
    };
    WebGlPspDrawDriver.prototype.drawElementsInternal = function (originalPrimitiveType, primitiveType, vertices, count, vertexState) {
        var gl = this.gl;
        var program = this.cache.getProgram(vertexState, this.state);
        program.use();
        this.demuxVertices(vertices, count, vertexState, primitiveType, originalPrimitiveType);
        this.updateState(program, vertexState, originalPrimitiveType);
        this.setProgramParameters(gl, program, vertexState);
        if (this.clearing) {
            this.textureHandler.unbindTexture(program, this.state);
        }
        else {
            this.prepareTexture(gl, program, vertexState);
        }
        this.drawArraysActual(gl, program, vertexState, primitiveType, count, vertices);
        this.unsetProgramParameters(gl, program, vertexState);
        if (this.state.clearing) {
            this.updateClearStateEnd(program, vertexState, primitiveType);
        }
    };
    WebGlPspDrawDriver.prototype.setProgramParameters = function (gl, program, vertexState) {
        program.getUniform('u_modelViewProjMatrix').setMat4(vertexState.transform2D ? this.transformMatrix2d : this.transformMatrix);
        program.getAttrib("vPosition").setFloats(3, this.positionData.slice());
        if (vertexState.hasTexture) {
            program.getUniform('tfx').set1i(this.state.texture.effect);
            program.getUniform('tcc').set1i(this.state.texture.colorComponent);
            program.getAttrib("vTexcoord").setFloats(3, this.textureData.slice());
        }
        if (vertexState.hasNormal) {
            program.getAttrib("vNormal").setFloats(3, this.normalData.slice());
        }
        if (vertexState.realWeightCount >= 1) {
            program.getAttrib('vertexWeight1').setFloats(4, this.vertexWeightData1.slice());
            if (vertexState.realWeightCount >= 4) {
                program.getAttrib('vertexWeight2').setFloats(4, this.vertexWeightData2.slice());
            }
            for (var n = 0; n < vertexState.realWeightCount; n++) {
                program.getUniform("matrixBone" + n).setMat4(this.state.skinning.boneMatrices[n].values);
            }
        }
        if (vertexState.hasColor) {
            program.getAttrib("vColor").setFloats(4, this.colorData.slice());
        }
        else {
            var ac = this.state.ambientModelColor;
            program.getUniform('uniformColor').set4f(ac.r, ac.g, ac.b, ac.a);
        }
        if (vertexState.hasTexture) {
            var texture = this.state.texture;
            var mipmap = texture.mipmaps[0];
            mat4.identity(this.texMat);
            var t = this.tempVec;
            if (vertexState.transform2D) {
                t[0] = 1.0 / (mipmap.bufferWidth);
                t[1] = 1.0 / (mipmap.textureHeight);
                t[2] = 1.0;
                mat4.scale(this.texMat, this.texMat, t);
            }
            else {
                switch (texture.textureMapMode) {
                    case _state.TextureMapMode.GU_TEXTURE_COORDS:
                        t[0] = texture.offsetU;
                        t[1] = texture.offsetV;
                        t[2] = 0.0;
                        mat4.translate(this.texMat, this.texMat, t);
                        t[0] = texture.scaleU;
                        t[1] = texture.scaleV;
                        t[2] = 1.0;
                        mat4.scale(this.texMat, this.texMat, t);
                        break;
                    default:
                        break;
                }
            }
            program.getUniform('u_texMatrix').setMat4(this.texMat);
        }
    };
    WebGlPspDrawDriver.prototype.unsetProgramParameters = function (gl, program, vertexState) {
        program.getAttrib("vPosition").disable();
        if (vertexState.hasTexture)
            program.getAttrib("vTexcoord").disable();
        if (vertexState.hasNormal)
            program.getAttrib("vNormal").disable();
        if (vertexState.hasColor)
            program.getAttrib("vColor").disable();
        if (vertexState.realWeightCount >= 1)
            program.getAttrib('vertexWeight1').disable();
        if (vertexState.realWeightCount >= 4)
            program.getAttrib('vertexWeight2').disable();
    };
    WebGlPspDrawDriver.prototype.drawArraysActual = function (gl, program, vertexState, primitiveType, count, vertices) {
        if (!this.convertPrimitiveType)
            this.convertPrimitiveType = [gl.POINTS, gl.LINES, gl.LINE_STRIP, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN];
        gl.drawArrays(this.convertPrimitiveType[primitiveType], 0, count);
    };
    return WebGlPspDrawDriver;
})();
var ClearBufferSet;
(function (ClearBufferSet) {
    ClearBufferSet[ClearBufferSet["ColorBuffer"] = 1] = "ColorBuffer";
    ClearBufferSet[ClearBufferSet["StencilBuffer"] = 2] = "StencilBuffer";
    ClearBufferSet[ClearBufferSet["DepthBuffer"] = 4] = "DepthBuffer";
    ClearBufferSet[ClearBufferSet["FastClear"] = 16] = "FastClear";
})(ClearBufferSet || (ClearBufferSet = {}));
module.exports = WebGlPspDrawDriver;

},
"src/core/gpu/webgl/driver_dummy": function(module, exports, require) {
///<reference path="../../../global.d.ts" />
var DummyDrawDriver = (function () {
    function DummyDrawDriver() {
    }
    DummyDrawDriver.prototype.end = function () {
    };
    DummyDrawDriver.prototype.initAsync = function () {
        return Promise2.resolve();
    };
    DummyDrawDriver.prototype.textureFlush = function (state) {
    };
    DummyDrawDriver.prototype.textureSync = function (state) {
    };
    DummyDrawDriver.prototype.drawElements = function (state, primitiveType, vertices, count, vertexState) {
    };
    return DummyDrawDriver;
})();
module.exports = DummyDrawDriver;

},
"src/core/gpu/webgl/shader": function(module, exports, require) {
///<reference path="../../../global.d.ts" />
var _utils = require('./utils');
var WrappedWebGLProgram = _utils.WrappedWebGLProgram;
var ShaderCache = (function () {
    function ShaderCache(gl, shaderVertString, shaderFragString) {
        this.gl = gl;
        this.shaderVertString = shaderVertString;
        this.shaderFragString = shaderFragString;
        this.programs = {};
    }
    ShaderCache.prototype.getProgram = function (vertex, state) {
        var hash = vertex.hash;
        hash += Math.pow(2, 32) * (state.alphaTest.enabled ? 1 : 0);
        hash += Math.pow(2, 33) * (state.clearing ? 1 : 0);
        if (this.programs[hash])
            return this.programs[hash];
        return this.programs[hash] = this.createProgram(vertex, state);
    };
    ShaderCache.prototype.createProgram = function (vertex, state) {
        var defines = [];
        if (vertex.hasColor)
            defines.push('VERTEX_COLOR 1');
        if (vertex.hasTexture)
            defines.push('VERTEX_TEXTURE 1');
        if (vertex.hasNormal)
            defines.push('VERTEX_NORMAL 1');
        if (!state.clearing) {
            if (state.alphaTest.enabled)
                defines.push('ALPHATEST 1');
        }
        defines.push('VERTEX_SKINNING ' + vertex.realWeightCount);
        var preppend = defines.map(function (item) { return '#define ' + item + ''; }).join("\n");
        return ShaderCache.shaderProgram(this.gl, preppend + "\n" + this.shaderVertString, preppend + "\n" + this.shaderFragString);
    };
    ShaderCache.shaderProgram = function (gl, vs, fs) {
        var prog = gl.createProgram();
        var addshader = function (type, source) {
            var s = gl.createShader((type == 'vertex') ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
            gl.shaderSource(s, source);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
                throw (new Error("Could not compile " + type + " shader:\n\n" + gl.getShaderInfoLog(s) + "\n\n" + source));
            gl.attachShader(prog, s);
        };
        addshader('vertex', vs);
        addshader('fragment', fs);
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS))
            throw (new Error("Could not link the shader program!"));
        return new WrappedWebGLProgram(gl, prog, vs, fs);
    };
    return ShaderCache;
})();
exports.ShaderCache = ShaderCache;

},
"src/core/gpu/webgl/texture": function(module, exports, require) {
///<reference path="../../../global.d.ts" />
var _state = require('../state');
var _pixelformat = require('../../pixelformat');
var PixelFormatUtils = _pixelformat.PixelFormatUtils;
var PixelConverter = _pixelformat.PixelConverter;
var Texture = (function () {
    function Texture(gl) {
        this.gl = gl;
        this.recheckTimestamp = 0;
        this.valid = true;
        this.validHint = true;
        this.swizzled = false;
        this.texture = gl.createTexture();
    }
    Texture.prototype.setInfo = function (state) {
        var texture = state.texture;
        var mipmap = texture.mipmaps[0];
        var clut = texture.clut;
        this.swizzled = texture.swizzled;
        this.address_start = mipmap.address;
        this.address_end = mipmap.address + PixelConverter.getSizeInBytes(texture.pixelFormat, mipmap.bufferWidth * mipmap.textureHeight);
        this.pixelFormat = texture.pixelFormat;
        this.clutFormat = clut.pixelFormat;
        this.clut_start = clut.adress;
        this.clut_end = clut.adress + PixelConverter.getSizeInBytes(texture.clut.pixelFormat, clut.numberOfColors);
    };
    Texture.prototype._create = function (callbackTex2D) {
        var gl = this.gl;
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        callbackTex2D();
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
    };
    Texture.prototype.fromBytes = function (data, width, height) {
        var gl = this.gl;
        this.width = width;
        this.height = height;
        this._create(function () {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        });
    };
    Texture.prototype.fromCanvas = function (canvas) {
        var gl = this.gl;
        this.width = canvas.width;
        this.height = canvas.height;
        this._create(function () {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
        });
    };
    Texture.prototype.bind = function (textureUnit, min, mag, wraps, wrapt) {
        var gl = this.gl;
        gl.activeTexture(gl.TEXTURE0 + textureUnit);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, min);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, mag);
        if (!MathUtils.isPowerOfTwo(this.width) || !MathUtils.isPowerOfTwo(this.height)) {
            wraps = wrapt = gl.CLAMP_TO_EDGE;
        }
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wraps);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapt);
    };
    Texture.hashFast = function (state) {
        var result = state.texture.mipmaps[0].address;
        if (PixelFormatUtils.hasClut(state.texture.pixelFormat)) {
            result += state.texture.clut.adress * Math.pow(2, 23);
        }
        result += (state.texture.swizzled ? 1 : 0) * Math.pow(2, 13);
        return result;
    };
    Texture.hashSlow = function (memory, state) {
        var texture = state.texture;
        var mipmap = texture.mipmaps[0];
        var clut = texture.clut;
        var hash_number = 0;
        hash_number += (texture.swizzled ? 1 : 0) * Math.pow(2, 0);
        hash_number += (texture.pixelFormat) * Math.pow(2, 1);
        hash_number += (mipmap.bufferWidth) * Math.pow(2, 3);
        hash_number += (mipmap.textureWidth) * Math.pow(2, 6);
        hash_number += (mipmap.textureHeight) * Math.pow(2, 8);
        hash_number += memory.hash(mipmap.address, PixelConverter.getSizeInBytes(texture.pixelFormat, mipmap.textureHeight * mipmap.bufferWidth)) * Math.pow(2, 12);
        if (PixelFormatUtils.hasClut(texture.pixelFormat)) {
            hash_number += memory.hash(clut.adress + PixelConverter.getSizeInBytes(clut.pixelFormat, clut.start + clut.shift * clut.numberOfColors), PixelConverter.getSizeInBytes(clut.pixelFormat, clut.numberOfColors)) * Math.pow(2, 30);
            hash_number += clut.info * Math.pow(2, 26);
        }
        return hash_number;
    };
    Texture.prototype.toString = function () {
        var out = '';
        out += 'Texture(address = ' + this.address_start + ', hash1 = ' + this.hash1 + ', hash2 = ' + this.hash2 + ', pixelFormat = ' + this.pixelFormat + ', swizzled = ' + this.swizzled;
        if (PixelFormatUtils.hasClut(this.pixelFormat)) {
            out += ', clutFormat=' + this.clutFormat;
        }
        out += ')';
        return out;
    };
    return Texture;
})();
exports.Texture = Texture;
var TextureHandler = (function () {
    function TextureHandler(memory, gl) {
        var _this = this;
        this.memory = memory;
        this.gl = gl;
        this.texturesByHash2 = {};
        this.texturesByHash1 = {};
        this.texturesByAddress = {};
        this.textures = [];
        this.recheckTimestamp = 0;
        this.invalidatedAll = false;
        memory.invalidateDataRange.add(function (range) { return _this.invalidatedMemoryRange(range); });
        memory.invalidateDataAll.add(function () { return _this.invalidatedMemoryAll(); });
    }
    TextureHandler.prototype.flush = function () {
        for (var n = 0; n < this.textures.length; n++) {
            var texture = this.textures[n];
            if (!texture.validHint) {
                texture.valid = false;
                texture.validHint = true;
            }
        }
    };
    TextureHandler.prototype.sync = function () {
    };
    TextureHandler.prototype.end = function () {
        if (!this.invalidatedAll)
            return;
        this.invalidatedAll = false;
        for (var n = 0; n < this.textures.length; n++) {
            var texture = this.textures[n];
            texture.validHint = false;
        }
    };
    TextureHandler.prototype.invalidatedMemoryAll = function () {
        this.invalidatedAll = true;
    };
    TextureHandler.prototype.invalidatedMemoryRange = function (range) {
        for (var n = 0; n < this.textures.length; n++) {
            var texture = this.textures[n];
            if (texture.address_start >= range.start && texture.address_end <= range.end) {
                texture.validHint = false;
            }
            if (texture.clut_start >= range.start && texture.clut_end <= range.end) {
                texture.validHint = false;
            }
        }
    };
    TextureHandler.prototype.mustRecheckSlowHash = function (texture) {
        return !texture || !texture.valid;
    };
    TextureHandler.prototype.bindTexture = function (prog, state) {
        var gl = this.gl;
        var mipmap = state.texture.mipmaps[0];
        if (mipmap.bufferWidth == 0)
            return;
        if (mipmap.textureWidth == 0)
            return;
        if (mipmap.textureHeight == 0)
            return;
        var hash1 = Texture.hashFast(state);
        var texture = this.texturesByHash1[hash1];
        if (this.mustRecheckSlowHash(texture)) {
            var hash2 = Texture.hashSlow(this.memory, state);
            texture = this.texturesByHash2[hash2];
            if (!texture) {
                if (!this.texturesByAddress[mipmap.address]) {
                    this.texturesByAddress[mipmap.address] = texture = new Texture(gl);
                    this.textures.push(texture);
                    console.warn('New texture allocated!', mipmap, state.texture);
                }
                texture = this.texturesByHash2[hash2] = this.texturesByHash1[hash1] = this.texturesByAddress[mipmap.address];
                texture.setInfo(state);
                texture.hash1 = hash1;
                texture.hash2 = hash2;
                texture.valid = true;
                texture.recheckTimestamp = this.recheckTimestamp;
                var mipmap = state.texture.mipmaps[0];
                var h = mipmap.textureHeight;
                var w = mipmap.textureWidth;
                var w2 = mipmap.bufferWidth;
                var data2 = new Uint8Array(w2 * h * 4);
                var clut = state.texture.clut;
                if (PixelFormatUtils.hasClut(state.texture.pixelFormat)) {
                    clut.numberOfColors = Math.max(clut.numberOfColors, clut.mask + 1);
                }
                var paletteBuffer = new ArrayBuffer(clut.numberOfColors * 4);
                var paletteU8 = new Uint8Array(paletteBuffer);
                var palette = new Uint32Array(paletteBuffer);
                if (PixelFormatUtils.hasClut(state.texture.pixelFormat)) {
                    PixelConverter.decode(clut.pixelFormat, this.memory.getPointerU8Array(clut.adress), paletteU8, 0, clut.numberOfColors, true);
                }
                var dataBuffer = new ArrayBuffer(PixelConverter.getSizeInBytes(state.texture.pixelFormat, w2 * h));
                var data = new Uint8Array(dataBuffer);
                data.set(this.memory.getPointerU8Array(mipmap.address, data.length));
                if (state.texture.swizzled) {
                    PixelConverter.unswizzleInline(state.texture.pixelFormat, dataBuffer, 0, w2, h);
                }
                PixelConverter.decode(state.texture.pixelFormat, data, data2, 0, w2 * h, true, palette, clut.start, clut.shift, clut.mask);
                if (true) {
                    texture.fromBytes(data2, w2, h);
                }
                else {
                    var canvas = document.createElement('canvas');
                    canvas.style.border = '1px solid white';
                    canvas.width = w2;
                    canvas.height = h;
                    var ctx = canvas.getContext('2d');
                    var imageData = ctx.createImageData(w2, h);
                    var u8 = imageData.data;
                    ctx.clearRect(0, 0, w, h);
                    for (var n = 0; n < w2 * h * 4; n++)
                        u8[n] = data2[n];
                    ctx.putImageData(imageData, 0, 0);
                    console.error('generated texture!' + texture.toString());
                    $(document.body).append($('<div style="color:white;" />')
                        .append(canvas)
                        .append(texture.toString() + 'w=' + w + ',w2=' + w2 + ',' + h));
                    texture.fromCanvas(canvas);
                }
            }
        }
        this.lastTexture = texture;
        texture.bind(0, (state.texture.filterMinification == _state.TextureFilter.Linear) ? gl.LINEAR : gl.NEAREST, (state.texture.filterMagnification == _state.TextureFilter.Linear) ? gl.LINEAR : gl.NEAREST, (state.texture.wrapU == _state.WrapMode.Clamp) ? gl.CLAMP_TO_EDGE : gl.REPEAT, (state.texture.wrapV == _state.WrapMode.Clamp) ? gl.CLAMP_TO_EDGE : gl.REPEAT);
        prog.getUniform('uSampler').set1i(0);
        prog.getUniform('samplerClut').set1i(1);
    };
    TextureHandler.prototype.unbindTexture = function (program, state) {
        var gl = this.gl;
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, null);
    };
    return TextureHandler;
})();
exports.TextureHandler = TextureHandler;

},
"src/core/gpu/webgl/utils": function(module, exports, require) {
///<reference path="../../../global.d.ts" />
var mat4x3_indices = new Int32Array([0, 1, 2, 4, 5, 6, 8, 9, 10, 12, 13, 14]);
var mat4x3 = mat4.create();
var WrappedWebGLUniform = (function () {
    function WrappedWebGLUniform(gl, program, name) {
        this.gl = gl;
        this.program = program;
        this.name = name;
        this.location = gl.getUniformLocation(program, name);
    }
    WrappedWebGLUniform.prototype.setMat4 = function (data) {
        this.gl.uniformMatrix4fv(this.location, false, data);
    };
    WrappedWebGLUniform.prototype.setMat4x3 = function (data, index) {
        mat4.identity(mat4x3);
        for (var n = 0; n < 12; n++)
            mat4x3[mat4x3_indices[n]] = data[index + n];
        this.gl.uniformMatrix4fv(this.location, false, data);
    };
    WrappedWebGLUniform.prototype.set1i = function (value) {
        this.gl.uniform1i(this.location, value);
    };
    WrappedWebGLUniform.prototype.set4f = function (x, y, z, w) {
        this.gl.uniform4f(this.location, x, y, z, w);
    };
    return WrappedWebGLUniform;
})();
exports.WrappedWebGLUniform = WrappedWebGLUniform;
var WrappedWebGLAttrib = (function () {
    function WrappedWebGLAttrib(gl, program, name) {
        this.gl = gl;
        this.program = program;
        this.name = name;
        this.location = gl.getAttribLocation(program, name);
    }
    WrappedWebGLAttrib.prototype.enable = function () {
        if (this.location < 0)
            return;
        this.gl.enableVertexAttribArray(this.location);
    };
    WrappedWebGLAttrib.prototype.disable = function () {
        if (this.location < 0)
            return;
        this.gl.disableVertexAttribArray(this.location);
    };
    WrappedWebGLAttrib.prototype.setFloats = function (rsize, arr) {
        if (this.location < 0)
            return;
        var gl = this.gl;
        if (!this.buffer)
            this.buffer = this.gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, arr, gl.DYNAMIC_DRAW);
        this.enable();
        gl.vertexAttribPointer(this.location, rsize, gl.FLOAT, false, 0, 0);
    };
    return WrappedWebGLAttrib;
})();
exports.WrappedWebGLAttrib = WrappedWebGLAttrib;
var WrappedWebGLProgram = (function () {
    function WrappedWebGLProgram(gl, program, vs, fs) {
        this.gl = gl;
        this.program = program;
        this.vs = vs;
        this.fs = fs;
        this.uniforms = {};
        this.attribs = {};
    }
    WrappedWebGLProgram.prototype.use = function () {
        this.gl.useProgram(this.program);
    };
    WrappedWebGLProgram.prototype.getUniform = function (name) {
        var uniform = this.uniforms[name];
        if (!uniform)
            uniform = this.uniforms[name] = new WrappedWebGLUniform(this.gl, this.program, name);
        return uniform;
    };
    WrappedWebGLProgram.prototype.getAttrib = function (name) {
        var attrib = this.attribs[name];
        if (!attrib)
            attrib = this.attribs[name] = new WrappedWebGLAttrib(this.gl, this.program, name);
        return attrib;
    };
    return WrappedWebGLProgram;
})();
exports.WrappedWebGLProgram = WrappedWebGLProgram;
var FastFloat32Buffer = (function () {
    function FastFloat32Buffer() {
        this.arrayBuffer = new ArrayBuffer(32768 * 4 * 4 * 4);
        this.float32Array = new Float32Array(this.arrayBuffer);
        this.index = 0;
    }
    FastFloat32Buffer.prototype.restart = function () {
        this.index = 0;
    };
    FastFloat32Buffer.prototype.push = function (value) {
        this.float32Array[this.index++] = value;
    };
    FastFloat32Buffer.prototype.push2 = function (x, y) {
        this.float32Array[this.index++] = x;
        this.float32Array[this.index++] = y;
    };
    FastFloat32Buffer.prototype.push3 = function (x, y, z) {
        this.float32Array[this.index++] = x;
        this.float32Array[this.index++] = y;
        this.float32Array[this.index++] = z;
    };
    FastFloat32Buffer.prototype.push4 = function (x, y, z, w) {
        this.float32Array[this.index++] = x;
        this.float32Array[this.index++] = y;
        this.float32Array[this.index++] = z;
        this.float32Array[this.index++] = w;
    };
    FastFloat32Buffer.prototype.slice = function () {
        return new Float32Array(this.arrayBuffer, 0, this.index);
    };
    return FastFloat32Buffer;
})();
exports.FastFloat32Buffer = FastFloat32Buffer;

},
"src/core/interrupt": function(module, exports, require) {
///<reference path="../global.d.ts" />
var InterruptHandler = (function () {
    function InterruptHandler(no) {
        this.no = no;
        this.enabled = false;
        this.address = 0;
        this.argument = 0;
        this.cpuState = null;
    }
    return InterruptHandler;
})();
exports.InterruptHandler = InterruptHandler;
var InterruptHandlers = (function () {
    function InterruptHandlers(pspInterrupt) {
        this.pspInterrupt = pspInterrupt;
        this.handlers = {};
    }
    InterruptHandlers.prototype.get = function (handlerIndex) {
        if (!this.handlers[handlerIndex])
            this.handlers[handlerIndex] = new InterruptHandler(handlerIndex);
        return this.handlers[handlerIndex];
    };
    InterruptHandlers.prototype.remove = function (handlerIndex) {
        delete this.handlers[handlerIndex];
    };
    InterruptHandlers.prototype.has = function (handlerIndex) {
        return (this.handlers[handlerIndex] !== undefined);
    };
    return InterruptHandlers;
})();
exports.InterruptHandlers = InterruptHandlers;
var InterruptManager = (function () {
    function InterruptManager() {
        this.enabled = true;
        this.flags = 0xFFFFFFFF;
        this.interruptHandlers = {};
        this.event = new Signal();
        this.queue = [];
    }
    InterruptManager.prototype.suspend = function () {
        var currentFlags = this.flags;
        this.flags = 0;
        this.enabled = false;
        return currentFlags;
    };
    InterruptManager.prototype.resume = function (value) {
        this.flags = value;
        this.enabled = true;
    };
    InterruptManager.prototype.get = function (pspInterrupt) {
        if (!this.interruptHandlers[pspInterrupt])
            this.interruptHandlers[pspInterrupt] = new InterruptHandlers(pspInterrupt);
        return this.interruptHandlers[pspInterrupt];
    };
    InterruptManager.prototype.interrupt = function (pspInterrupt) {
        var interrupt = this.get(pspInterrupt);
        var handlers = interrupt.handlers;
        for (var n in handlers) {
            var handler = handlers[n];
            if (handler.enabled) {
                this.queue.push(handler);
                this.execute(null);
            }
        }
    };
    InterruptManager.prototype.execute = function (_state) {
        while (this.queue.length > 0) {
            var item = this.queue.shift();
            var state = item.cpuState;
            state.preserveRegisters(function () {
                state.gpr[4] = item.no;
                state.gpr[5] = item.argument;
                state.PC = item.address;
                state.executeAtPC();
            });
        }
    };
    return InterruptManager;
})();
exports.InterruptManager = InterruptManager;
(function (PspInterrupts) {
    PspInterrupts[PspInterrupts["PSP_GPIO_INT"] = 4] = "PSP_GPIO_INT";
    PspInterrupts[PspInterrupts["PSP_ATA_INT"] = 5] = "PSP_ATA_INT";
    PspInterrupts[PspInterrupts["PSP_UMD_INT"] = 6] = "PSP_UMD_INT";
    PspInterrupts[PspInterrupts["PSP_MSCM0_INT"] = 7] = "PSP_MSCM0_INT";
    PspInterrupts[PspInterrupts["PSP_WLAN_INT"] = 8] = "PSP_WLAN_INT";
    PspInterrupts[PspInterrupts["PSP_AUDIO_INT"] = 10] = "PSP_AUDIO_INT";
    PspInterrupts[PspInterrupts["PSP_I2C_INT"] = 12] = "PSP_I2C_INT";
    PspInterrupts[PspInterrupts["PSP_SIRCS_INT"] = 14] = "PSP_SIRCS_INT";
    PspInterrupts[PspInterrupts["PSP_SYSTIMER0_INT"] = 15] = "PSP_SYSTIMER0_INT";
    PspInterrupts[PspInterrupts["PSP_SYSTIMER1_INT"] = 16] = "PSP_SYSTIMER1_INT";
    PspInterrupts[PspInterrupts["PSP_SYSTIMER2_INT"] = 17] = "PSP_SYSTIMER2_INT";
    PspInterrupts[PspInterrupts["PSP_SYSTIMER3_INT"] = 18] = "PSP_SYSTIMER3_INT";
    PspInterrupts[PspInterrupts["PSP_THREAD0_INT"] = 19] = "PSP_THREAD0_INT";
    PspInterrupts[PspInterrupts["PSP_NAND_INT"] = 20] = "PSP_NAND_INT";
    PspInterrupts[PspInterrupts["PSP_DMACPLUS_INT"] = 21] = "PSP_DMACPLUS_INT";
    PspInterrupts[PspInterrupts["PSP_DMA0_INT"] = 22] = "PSP_DMA0_INT";
    PspInterrupts[PspInterrupts["PSP_DMA1_INT"] = 23] = "PSP_DMA1_INT";
    PspInterrupts[PspInterrupts["PSP_MEMLMD_INT"] = 24] = "PSP_MEMLMD_INT";
    PspInterrupts[PspInterrupts["PSP_GE_INT"] = 25] = "PSP_GE_INT";
    PspInterrupts[PspInterrupts["PSP_VBLANK_INT"] = 30] = "PSP_VBLANK_INT";
    PspInterrupts[PspInterrupts["PSP_MECODEC_INT"] = 31] = "PSP_MECODEC_INT";
    PspInterrupts[PspInterrupts["PSP_HPREMOTE_INT"] = 36] = "PSP_HPREMOTE_INT";
    PspInterrupts[PspInterrupts["PSP_MSCM1_INT"] = 60] = "PSP_MSCM1_INT";
    PspInterrupts[PspInterrupts["PSP_MSCM2_INT"] = 61] = "PSP_MSCM2_INT";
    PspInterrupts[PspInterrupts["PSP_THREAD1_INT"] = 65] = "PSP_THREAD1_INT";
    PspInterrupts[PspInterrupts["PSP_INTERRUPT_INT"] = 66] = "PSP_INTERRUPT_INT";
    PspInterrupts[PspInterrupts["PSP_NUMBER_INTERRUPTS"] = 67] = "PSP_NUMBER_INTERRUPTS";
})(exports.PspInterrupts || (exports.PspInterrupts = {}));
var PspInterrupts = exports.PspInterrupts;

},
"src/core/kirk": function(module, exports, require) {
///<reference path="../global.d.ts" />
var _kirk = require('./kirk/kirk');
_kirk.CMD7;
exports.KIRK_AES128CBC_HEADER = _kirk.KIRK_AES128CBC_HEADER;
exports.KirkMode = _kirk.KirkMode;
exports.CommandEnum = _kirk.CommandEnum;
exports.hleUtilsBufferCopyWithRange = _kirk.hleUtilsBufferCopyWithRange;
var Cmd1 = exports.KirkMode.Cmd1;
var CERT_VERIFY = exports.CommandEnum.CERT_VERIFY;
var KIRK_AES128CBC_HEADER_struct = exports.KIRK_AES128CBC_HEADER.struct;

},
"src/core/kirk/crypto": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var jsaes2 = require('./jsaes2');
function cryptoToArray(info) {
    var words = info.words;
    var wordsLen = words.length;
    var data = new Uint8Array(wordsLen * 4);
    var m = 0;
    for (var n = 0; n < wordsLen; n++) {
        data[m++] = (words[n] >>> 24) & 0xFF;
        data[m++] = (words[n] >>> 16) & 0xFF;
        data[m++] = (words[n] >>> 8) & 0xFF;
        data[m++] = (words[n] >>> 0) & 0xFF;
    }
    return data;
}
function ab2str(buf) {
    return String.fromCharCode.apply(null, buf);
}
function ab2hex(buf) {
    var parts = [];
    for (var n = 0; n < buf.length; n++) {
        var chunk = buf[n].toString(16);
        while (chunk.length < 2)
            chunk = '0' + chunk;
        parts.push(chunk);
    }
    return parts.join('');
}
function str2ab(str) {
    var bufView = new Uint8Array(str.length);
    for (var i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }
    return bufView;
}
function uint8array_to_array32(data) {
    var data2 = new Uint32Array(data.buffer);
    var out = new Array(data2.length / 4);
    for (var n = 0; n < data2.length; n++) {
        out[n] = data2[n];
    }
    return out;
}
function uint8array_to_array8(data) {
    var out = new Array(data.length / 4);
    for (var n = 0; n < data.length; n++) {
        out[n] = data[n];
    }
    return out;
}
function array_to_uint8array(data) {
    var out = new Uint8Array(data.length);
    for (var n = 0; n < data.length; n++)
        out[n] = data[n];
    return out;
}
function pad_PKCS7(array, padding) {
    var left = (padding - (array.length % padding)) % padding;
    for (var n = 0; n < left; n++)
        array.push(left);
    return array;
}
function pad_Zero(array, padding) {
    var left = (padding - (array.length % padding)) % padding;
    for (var n = 0; n < left; n++)
        array.push(0);
    return array;
}
function cbc(data, iv) {
    for (var m = 0; m < 16; m++)
        data[m] ^= iv[m];
    for (var n = 16; n < data.length; n += 16) {
        for (var m = 0; m < 16; m++) {
            data[n + m] ^= data[n + m - 16];
        }
    }
}
function aes_decrypt(data, key, iv) {
    var keyLength = key.length;
    if (iv === undefined)
        iv = new Uint8Array(keyLength);
    return jsaes2.decrypt_aes128_cbc(data, key);
}
exports.aes_decrypt = aes_decrypt;

},
"src/core/kirk/jsaes2": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var SBOX = new Uint8Array(256);
var INV_SBOX = new Uint8Array(256);
var SUB_MIX_0 = new Uint32Array(256);
var SUB_MIX_1 = new Uint32Array(256);
var SUB_MIX_2 = new Uint32Array(256);
var SUB_MIX_3 = new Uint32Array(256);
var INV_SUB_MIX_0 = new Uint32Array(256);
var INV_SUB_MIX_1 = new Uint32Array(256);
var INV_SUB_MIX_2 = new Uint32Array(256);
var INV_SUB_MIX_3 = new Uint32Array(256);
(function () {
    var d = [];
    for (var i = 0; i < 256; i++) {
        d[i] = (i << 1);
        if (i >= 128)
            d[i] ^= 0x11b;
    }
    var x = 0;
    var xi = 0;
    for (var i = 0; i < 256; i++) {
        var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
        sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
        SBOX[x] = sx;
        INV_SBOX[sx] = x;
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];
        var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
        SUB_MIX_0[x] = (t << 24) | (t >>> 8);
        SUB_MIX_1[x] = (t << 16) | (t >>> 16);
        SUB_MIX_2[x] = (t << 8) | (t >>> 24);
        SUB_MIX_3[x] = (t << 0);
        var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
        INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
        INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
        INV_SUB_MIX_2[sx] = (t << 8) | (t >>> 24);
        INV_SUB_MIX_3[sx] = (t << 0);
        if (!x) {
            x = xi = 1;
        }
        else {
            x = x2 ^ d[d[d[x8 ^ x2]]];
            xi ^= d[d[xi]];
        }
    }
}());
var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
var AES = (function () {
    function AES(key) {
        this._key = new Uint32Array([0, 0, 0, 0]);
        this._nRounds = -1;
        this._keySchedule = [];
        this._invKeySchedule = [];
        this._key = uint8array_to_words(key);
        this.reset();
    }
    AES.prototype.reset = function () {
        var key = this._key;
        var keyWords = key;
        var keySize = key.length;
        var nRounds = this._nRounds = keySize + 6;
        var ksRows = (nRounds + 1) * 4;
        var keySchedule = this._keySchedule = [];
        for (var ksRow = 0; ksRow < ksRows; ksRow++) {
            if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
            }
            else {
                var t = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                    t = (t << 8) | (t >>> 24);
                    t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
                    t ^= RCON[(ksRow / keySize) | 0] << 24;
                }
                else if (keySize > 6 && ksRow % keySize == 4) {
                    t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
            }
        }
        var invKeySchedule = this._invKeySchedule = [];
        for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
            var ksRow = ksRows - invKsRow;
            if (invKsRow % 4) {
                var t = keySchedule[ksRow];
            }
            else {
                var t = keySchedule[ksRow - 4];
            }
            if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t;
            }
            else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
                    INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
            }
        }
    };
    AES.prototype.encryptBlock = function (M, offset) {
        this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
    };
    AES.prototype.decryptBlock = function (M, offset) {
        var t = M[offset + 1];
        M[offset + 1] = M[offset + 3];
        M[offset + 3] = t;
        this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
        var t = M[offset + 1];
        M[offset + 1] = M[offset + 3];
        M[offset + 3] = t;
    };
    AES.prototype._doCryptBlock = function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
        var nRounds = this._nRounds;
        var s0 = M[offset + 0] ^ keySchedule[0];
        var s1 = M[offset + 1] ^ keySchedule[1];
        var s2 = M[offset + 2] ^ keySchedule[2];
        var s3 = M[offset + 3] ^ keySchedule[3];
        var ksRow = 4;
        for (var round = 1; round < nRounds; round++) {
            var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[(s3 >>> 0) & 0xff] ^ keySchedule[ksRow++];
            var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[(s0 >>> 0) & 0xff] ^ keySchedule[ksRow++];
            var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[(s1 >>> 0) & 0xff] ^ keySchedule[ksRow++];
            var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[(s2 >>> 0) & 0xff] ^ keySchedule[ksRow++];
            s0 = t0;
            s1 = t1;
            s2 = t2;
            s3 = t3;
        }
        var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[(s3 >>> 0) & 0xff]) ^ keySchedule[ksRow++];
        var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[(s0 >>> 0) & 0xff]) ^ keySchedule[ksRow++];
        var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[(s1 >>> 0) & 0xff]) ^ keySchedule[ksRow++];
        var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[(s2 >>> 0) & 0xff]) ^ keySchedule[ksRow++];
        M[offset + 0] = t0;
        M[offset + 1] = t1;
        M[offset + 2] = t2;
        M[offset + 3] = t3;
    };
    return AES;
})();
exports.AES = AES;
function swap32(v) {
    return ((v & 0xFF) << 24) | ((v & 0xFF00) << 8) | ((v >> 8) & 0xFF00) | ((v >> 24) & 0xFF);
}
function uint8array_to_words(key) {
    var temp = new Uint32Array(key.buffer, key.byteOffset, key.length / 4);
    var words = new Uint32Array(key.length / 4);
    for (var n = 0; n < words.length; n++)
        words[n] = swap32(temp[n]);
    return words;
}
function words_to_uint8array(words) {
    var out = new Uint8Array(words.length * 4);
    var out2 = new Uint32Array(out.buffer);
    for (var n = 0; n < words.length; n++)
        out2[n] = swap32(words[n]);
    return out;
}
function decrypt_aes128_cbc(data, key) {
    var aes = new AES(key);
    var words = uint8array_to_words(data);
    var wordsLength = words.length;
    var t0 = 0, t1 = 0, t2 = 0, t3 = 0;
    var s0 = 0, s1 = 0, s2 = 0, s3 = 0;
    for (var n = 0; n < wordsLength; n += 4) {
        t0 = words[n + 0];
        t1 = words[n + 1];
        t2 = words[n + 2];
        t3 = words[n + 3];
        aes.decryptBlock(words, n);
        words[n + 0] ^= s0;
        words[n + 1] ^= s1;
        words[n + 2] ^= s2;
        words[n + 3] ^= s3;
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
    }
    return words_to_uint8array(words);
}
exports.decrypt_aes128_cbc = decrypt_aes128_cbc;

},
"src/core/kirk/kirk": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var crypto = require('./crypto');
var kirk1_key = new Uint8Array([0x98, 0xC9, 0x40, 0x97, 0x5C, 0x1D, 0x10, 0xE8, 0x7F, 0xE6, 0x0E, 0xA3, 0xFD, 0x03, 0xA8, 0xBA]);
var kirk16_key = new Uint8Array([0x47, 0x5E, 0x09, 0xF4, 0xA2, 0x37, 0xDA, 0x9B, 0xEF, 0xFF, 0x3B, 0xC0, 0x77, 0x14, 0x3D, 0x8A]);
var kirk7_keys = {
    0x02: new Uint8Array([0xB8, 0x13, 0xC3, 0x5E, 0xC6, 0x44, 0x41, 0xE3, 0xDC, 0x3C, 0x16, 0xF5, 0xB4, 0x5E, 0x64, 0x84]),
    0x03: new Uint8Array([0x98, 0x02, 0xC4, 0xE6, 0xEC, 0x9E, 0x9E, 0x2F, 0xFC, 0x63, 0x4C, 0xE4, 0x2F, 0xBB, 0x46, 0x68]),
    0x04: new Uint8Array([0x99, 0x24, 0x4C, 0xD2, 0x58, 0xF5, 0x1B, 0xCB, 0xB0, 0x61, 0x9C, 0xA7, 0x38, 0x30, 0x07, 0x5F]),
    0x05: new Uint8Array([0x02, 0x25, 0xD7, 0xBA, 0x63, 0xEC, 0xB9, 0x4A, 0x9D, 0x23, 0x76, 0x01, 0xB3, 0xF6, 0xAC, 0x17]),
    0x07: new Uint8Array([0x76, 0x36, 0x8B, 0x43, 0x8F, 0x77, 0xD8, 0x7E, 0xFE, 0x5F, 0xB6, 0x11, 0x59, 0x39, 0x88, 0x5C]),
    0x0C: new Uint8Array([0x84, 0x85, 0xC8, 0x48, 0x75, 0x08, 0x43, 0xBC, 0x9B, 0x9A, 0xEC, 0xA7, 0x9C, 0x7F, 0x60, 0x18]),
    0x0D: new Uint8Array([0xB5, 0xB1, 0x6E, 0xDE, 0x23, 0xA9, 0x7B, 0x0E, 0xA1, 0x7C, 0xDB, 0xA2, 0xDC, 0xDE, 0xC4, 0x6E]),
    0x0E: new Uint8Array([0xC8, 0x71, 0xFD, 0xB3, 0xBC, 0xC5, 0xD2, 0xF2, 0xE2, 0xD7, 0x72, 0x9D, 0xDF, 0x82, 0x68, 0x82]),
    0x0F: new Uint8Array([0x0A, 0xBB, 0x33, 0x6C, 0x96, 0xD4, 0xCD, 0xD8, 0xCB, 0x5F, 0x4B, 0xE0, 0xBA, 0xDB, 0x9E, 0x03]),
    0x10: new Uint8Array([0x32, 0x29, 0x5B, 0xD5, 0xEA, 0xF7, 0xA3, 0x42, 0x16, 0xC8, 0x8E, 0x48, 0xFF, 0x50, 0xD3, 0x71]),
    0x11: new Uint8Array([0x46, 0xF2, 0x5E, 0x8E, 0x4D, 0x2A, 0xA5, 0x40, 0x73, 0x0B, 0xC4, 0x6E, 0x47, 0xEE, 0x6F, 0x0A]),
    0x12: new Uint8Array([0x5D, 0xC7, 0x11, 0x39, 0xD0, 0x19, 0x38, 0xBC, 0x02, 0x7F, 0xDD, 0xDC, 0xB0, 0x83, 0x7D, 0x9D]),
    0x38: new Uint8Array([0x12, 0x46, 0x8D, 0x7E, 0x1C, 0x42, 0x20, 0x9B, 0xBA, 0x54, 0x26, 0x83, 0x5E, 0xB0, 0x33, 0x03]),
    0x39: new Uint8Array([0xC4, 0x3B, 0xB6, 0xD6, 0x53, 0xEE, 0x67, 0x49, 0x3E, 0xA9, 0x5F, 0xBC, 0x0C, 0xED, 0x6F, 0x8A]),
    0x3A: new Uint8Array([0x2C, 0xC3, 0xCF, 0x8C, 0x28, 0x78, 0xA5, 0xA6, 0x63, 0xE2, 0xAF, 0x2D, 0x71, 0x5E, 0x86, 0xBA]),
    0x44: new Uint8Array([0x7D, 0xF4, 0x92, 0x65, 0xE3, 0xFA, 0xD6, 0x78, 0xD6, 0xFE, 0x78, 0xAD, 0xBB, 0x3D, 0xFB, 0x63]),
    0x4B: new Uint8Array([0x0C, 0xFD, 0x67, 0x9A, 0xF9, 0xB4, 0x72, 0x4F, 0xD7, 0x8D, 0xD6, 0xE9, 0x96, 0x42, 0x28, 0x8B]),
    0x53: new Uint8Array([0xAF, 0xFE, 0x8E, 0xB1, 0x3D, 0xD1, 0x7E, 0xD8, 0x0A, 0x61, 0x24, 0x1C, 0x95, 0x92, 0x56, 0xB6]),
    0x57: new Uint8Array([0x1C, 0x9B, 0xC4, 0x90, 0xE3, 0x06, 0x64, 0x81, 0xFA, 0x59, 0xFD, 0xB6, 0x00, 0xBB, 0x28, 0x70]),
    0x5D: new Uint8Array([0x11, 0x5A, 0x5D, 0x20, 0xD5, 0x3A, 0x8D, 0xD3, 0x9C, 0xC5, 0xAF, 0x41, 0x0F, 0x0F, 0x18, 0x6F]),
    0x63: new Uint8Array([0x9C, 0x9B, 0x13, 0x72, 0xF8, 0xC6, 0x40, 0xCF, 0x1C, 0x62, 0xF5, 0xD5, 0x92, 0xDD, 0xB5, 0x82]),
    0x64: new Uint8Array([0x03, 0xB3, 0x02, 0xE8, 0x5F, 0xF3, 0x81, 0xB1, 0x3B, 0x8D, 0xAA, 0x2A, 0x90, 0xFF, 0x5E, 0x61]),
};
var ec_p = new Uint8Array([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
var ec_a = new Uint8Array([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC]);
var ec_b2 = new Uint8Array([0xA6, 0x8B, 0xED, 0xC3, 0x34, 0x18, 0x02, 0x9C, 0x1D, 0x3C, 0xE3, 0x3B, 0x9A, 0x32, 0x1F, 0xCC, 0xBB, 0x9E, 0x0F, 0x0B]);
var ec_N2 = new Uint8Array([0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xB5, 0xAE, 0x3C, 0x52, 0x3E, 0x63, 0x94, 0x4F, 0x21, 0x27]);
var Gx2 = new Uint8Array([0x12, 0x8E, 0xC4, 0x25, 0x64, 0x87, 0xFD, 0x8F, 0xDF, 0x64, 0xE2, 0x43, 0x7B, 0xC0, 0xA1, 0xF6, 0xD5, 0xAF, 0xDE, 0x2C]);
var Gy2 = new Uint8Array([0x59, 0x58, 0x55, 0x7E, 0xB1, 0xDB, 0x00, 0x12, 0x60, 0x42, 0x55, 0x24, 0xDB, 0xC3, 0x79, 0xD5, 0xAC, 0x5F, 0x4A, 0xDF]);
var ec_b1 = new Uint8Array([0x65, 0xD1, 0x48, 0x8C, 0x03, 0x59, 0xE2, 0x34, 0xAD, 0xC9, 0x5B, 0xD3, 0x90, 0x80, 0x14, 0xBD, 0x91, 0xA5, 0x25, 0xF9]);
var ec_N1 = new Uint8Array([0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x01, 0xB5, 0xC6, 0x17, 0xF2, 0x90, 0xEA, 0xE1, 0xDB, 0xAD, 0x8F]);
var Gx1 = new Uint8Array([0x22, 0x59, 0xAC, 0xEE, 0x15, 0x48, 0x9C, 0xB0, 0x96, 0xA8, 0x82, 0xF0, 0xAE, 0x1C, 0xF9, 0xFD, 0x8E, 0xE5, 0xF8, 0xFA]);
var Gy1 = new Uint8Array([0x60, 0x43, 0x58, 0x45, 0x6D, 0x0A, 0x1C, 0xB2, 0x90, 0x8D, 0xE9, 0x0F, 0x27, 0xD7, 0x5C, 0x82, 0xBE, 0xC1, 0x08, 0xC0]);
var Px1 = new Uint8Array([0xED, 0x9C, 0xE5, 0x82, 0x34, 0xE6, 0x1A, 0x53, 0xC6, 0x85, 0xD6, 0x4D, 0x51, 0xD0, 0x23, 0x6B, 0xC3, 0xB5, 0xD4, 0xB9]);
var Py1 = new Uint8Array([0x04, 0x9D, 0xF1, 0xA0, 0x75, 0xC0, 0xE0, 0x4F, 0xB3, 0x44, 0x85, 0x8B, 0x61, 0xB7, 0x9B, 0x69, 0xA6, 0x3D, 0x2C, 0x39]);
var KIRK_AES128CBC_HEADER = (function () {
    function KIRK_AES128CBC_HEADER() {
        this.mode = KirkMode.Invalid0;
        this.unk_4 = 0;
        this.unk_8 = 0;
        this.keyseed = 0;
        this.data_size = 0;
    }
    KIRK_AES128CBC_HEADER.struct = StructClass.create(KIRK_AES128CBC_HEADER, [
        { mode: Int32 },
        { unk_4: Int32 },
        { unk_8: Int32 },
        { keyseed: Int32 },
        { data_size: Int32 },
    ]);
    return KIRK_AES128CBC_HEADER;
})();
exports.KIRK_AES128CBC_HEADER = KIRK_AES128CBC_HEADER;
var AES128CMACHeader = (function () {
    function AES128CMACHeader() {
    }
    AES128CMACHeader.struct = StructClass.create(AES128CMACHeader, [
        { AES_key: StructArray(UInt8, 16) },
        { CMAC_key: StructArray(UInt8, 16) },
        { CMAC_header_hash: StructArray(UInt8, 16) },
        { CMAC_data_hash: StructArray(UInt8, 16) },
        { Unknown1: StructArray(UInt8, 32) },
        { Mode: UInt8 },
        { UseECDSAhash: UInt8 },
        { Unknown2: StructArray(UInt8, 14) },
        { DataSize: UInt32 },
        { DataOffset: UInt32 },
        { Unknown3: StructArray(UInt8, 8) },
        { Unknown4: StructArray(UInt8, 16) },
    ]);
    return AES128CMACHeader;
})();
exports.AES128CMACHeader = AES128CMACHeader;
function kirk_4_7_get_key(key_type) {
    var key = kirk7_keys[key_type];
    if (!key)
        throw (new Error("Unsupported key '" + key_type + "'"));
    return key;
}
(function (KirkMode) {
    KirkMode[KirkMode["Invalid0"] = 0] = "Invalid0";
    KirkMode[KirkMode["Cmd1"] = 1] = "Cmd1";
    KirkMode[KirkMode["Cmd2"] = 2] = "Cmd2";
    KirkMode[KirkMode["Cmd3"] = 3] = "Cmd3";
    KirkMode[KirkMode["EncryptCbc"] = 4] = "EncryptCbc";
    KirkMode[KirkMode["DecryptCbc"] = 5] = "DecryptCbc";
})(exports.KirkMode || (exports.KirkMode = {}));
var KirkMode = exports.KirkMode;
(function (CommandEnum) {
    CommandEnum[CommandEnum["DECRYPT_PRIVATE"] = 1] = "DECRYPT_PRIVATE";
    CommandEnum[CommandEnum["ENCRYPT_SIGN"] = 2] = "ENCRYPT_SIGN";
    CommandEnum[CommandEnum["DECRYPT_SIGN"] = 3] = "DECRYPT_SIGN";
    CommandEnum[CommandEnum["ENCRYPT_IV_0"] = 4] = "ENCRYPT_IV_0";
    CommandEnum[CommandEnum["ENCRYPT_IV_FUSE"] = 5] = "ENCRYPT_IV_FUSE";
    CommandEnum[CommandEnum["ENCRYPT_IV_USER"] = 6] = "ENCRYPT_IV_USER";
    CommandEnum[CommandEnum["DECRYPT_IV_0"] = 7] = "DECRYPT_IV_0";
    CommandEnum[CommandEnum["DECRYPT_IV_FUSE"] = 8] = "DECRYPT_IV_FUSE";
    CommandEnum[CommandEnum["DECRYPT_IV_USER"] = 9] = "DECRYPT_IV_USER";
    CommandEnum[CommandEnum["PRIV_SIG_CHECK"] = 10] = "PRIV_SIG_CHECK";
    CommandEnum[CommandEnum["SHA1_HASH"] = 11] = "SHA1_HASH";
    CommandEnum[CommandEnum["ECDSA_GEN_KEYS"] = 12] = "ECDSA_GEN_KEYS";
    CommandEnum[CommandEnum["ECDSA_MULTIPLY_POINT"] = 13] = "ECDSA_MULTIPLY_POINT";
    CommandEnum[CommandEnum["PRNG"] = 14] = "PRNG";
    CommandEnum[CommandEnum["INIT"] = 15] = "INIT";
    CommandEnum[CommandEnum["ECDSA_SIGN"] = 16] = "ECDSA_SIGN";
    CommandEnum[CommandEnum["ECDSA_VERIFY"] = 17] = "ECDSA_VERIFY";
    CommandEnum[CommandEnum["CERT_VERIFY"] = 18] = "CERT_VERIFY";
})(exports.CommandEnum || (exports.CommandEnum = {}));
var CommandEnum = exports.CommandEnum;
function CMD7(input) {
    var header = KIRK_AES128CBC_HEADER.struct.read(input.slice());
    if (header.mode != KirkMode.DecryptCbc)
        throw (new Error("Kirk Invalid mode '" + header.mode + "'"));
    if (header.data_size == 0)
        throw (new Error("Kirk data size == 0"));
    return crypto.aes_decrypt(input.sliceFrom(KIRK_AES128CBC_HEADER.struct.length).readAllBytes(), kirk_4_7_get_key(header.keyseed));
}
exports.CMD7 = CMD7;
function kirk_CMD7(output, input) {
    var output2 = Stream.fromUint8Array(CMD7(input.slice()));
    output.slice().writeStream(output2);
}
function kirk_CMD1(output, input) {
    var header = input.slice().readStruct(AES128CMACHeader.struct);
    if (header.Mode != KirkMode.Cmd1)
        throw (new Error("Kirk mode != Cmd1"));
    var Keys = crypto.aes_decrypt(input.sliceWithLength(0, 16 * 2).readAllBytes(), kirk1_key);
    var KeyAes = Keys.subarray(0, 16);
    var KeyCmac = Keys.subarray(16, 16);
    var PaddedDataSize = (header.DataSize + 15) & -16;
    var Output = crypto.aes_decrypt(input.sliceWithLength(header.DataOffset + AES128CMACHeader.struct.length, PaddedDataSize).readAllBytes(), KeyAes);
    output.slice().writeBytes(Output.subarray(0, header.DataSize));
}
function hleUtilsBufferCopyWithRange(output, input, command) {
    switch (command) {
        case CommandEnum.DECRYPT_PRIVATE:
            return kirk_CMD1(output, input);
            break;
        case CommandEnum.DECRYPT_IV_0:
            return kirk_CMD7(output, input);
            break;
    }
    throw (new Error("Not implemented hleUtilsBufferCopyWithRange! with command " + command + ': ' + CommandEnum[command]));
}
exports.hleUtilsBufferCopyWithRange = hleUtilsBufferCopyWithRange;

},
"src/core/memory": function(module, exports, require) {
///<reference path="../global.d.ts" />
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var MASK = 0x0FFFFFFF;
var LWR_MASK = new Uint32Array([0x00000000, 0xFF000000, 0xFFFF0000, 0xFFFFFF00]);
var LWR_SHIFT = new Uint32Array([0, 8, 16, 24]);
var LWL_MASK = new Uint32Array([0x00FFFFFF, 0x0000FFFF, 0x000000FF, 0x00000000]);
var LWL_SHIFT = new Uint32Array([24, 16, 8, 0]);
var SWL_MASK = new Uint32Array([0xFFFFFF00, 0xFFFF0000, 0xFF000000, 0x00000000]);
var SWL_SHIFT = new Uint32Array([24, 16, 8, 0]);
var SWR_MASK = new Uint32Array([0x00000000, 0x000000FF, 0x0000FFFF, 0x00FFFFFF]);
var SWR_SHIFT = new Uint32Array([0, 8, 16, 24]);
var Memory = (function () {
    function Memory() {
        this.invalidateDataRange = new Signal();
        this.invalidateDataAll = new Signal();
        this.writeBreakpoints = [];
    }
    Memory.prototype.lwl = function (address, value) {
        var align = address & 3;
        var oldvalue = this.lw(address & ~3);
        return ((oldvalue << LWL_SHIFT[align]) | (value & LWL_MASK[align]));
    };
    Memory.prototype.lwr = function (address, value) {
        var align = address & 3;
        var oldvalue = this.lw(address & ~3);
        return ((oldvalue >>> LWR_SHIFT[align]) | (value & LWR_MASK[align]));
    };
    Memory.prototype.swl = function (address, value) {
        var align = address & 3;
        var aadress = address & ~3;
        var vwrite = (value >>> SWL_SHIFT[align]) | (this.lw(aadress) & SWL_MASK[align]);
        this.sw(aadress, vwrite);
    };
    Memory.prototype.swr = function (address, value) {
        var align = address & 3;
        var aadress = address & ~3;
        var vwrite = (value << SWR_SHIFT[align]) | (this.lw(aadress) & SWR_MASK[align]);
        this.sw(aadress, vwrite);
    };
    Memory.prototype.writeInt8 = function (address, value) { this.sb(address, value); };
    Memory.prototype.writeInt16 = function (address, value) { this.sh(address, value); };
    Memory.prototype.writeInt32 = function (address, value) { this.sw(address, value); };
    Memory.prototype.writeFloat32 = function (address, value) { this.swc1(address, value); };
    Memory.prototype.readInt8 = function (address) { return this.lb(address); };
    Memory.prototype.readUInt8 = function (address) { return this.lbu(address); };
    Memory.prototype.readInt16 = function (address) { return this.lh(address); };
    Memory.prototype.readUInt16 = function (address) { return this.lhu(address); };
    Memory.prototype.readInt32 = function (address) { return this.lw(address); };
    Memory.prototype.readUInt32 = function (address) { return this.lwu(address); };
    Memory.prototype.readFloat32 = function (address) { return this.lwc1(address); };
    Memory.prototype.readUInt32_2 = function (address) { return this.lw_2(address); };
    Memory.prototype.sb = function (address, value) { throw "Must override"; };
    Memory.prototype.sh = function (address, value) { throw "Must override"; };
    Memory.prototype.sw = function (address, value) { throw "Must override"; };
    Memory.prototype.swc1 = function (address, value) { throw "Must override"; };
    Memory.prototype.lb = function (address) { throw "Must override"; };
    Memory.prototype.lbu = function (address) { throw "Must override"; };
    Memory.prototype.lh = function (address) { throw "Must override"; };
    Memory.prototype.lhu = function (address) { throw "Must override"; };
    Memory.prototype.lw = function (address) { throw "Must override"; };
    Memory.prototype.lwu = function (address) { throw "Must override"; };
    Memory.prototype.lwc1 = function (address) { throw "Must override"; };
    Memory.prototype.lw_2 = function (address) { throw "Must override"; };
    Memory.prototype.slice = function (low, high) { throw "Must override"; };
    Memory.prototype.availableAfterAddress = function (address) { throw "Must override"; };
    Memory.prototype.isAddressInRange = function (address, min, max) {
        address &= FastMemory.MASK;
        address >>>= 0;
        min &= FastMemory.MASK;
        min >>>= 0;
        max &= FastMemory.MASK;
        max >>>= 0;
        return (address >= min) && (address < max);
    };
    Memory.prototype.isValidAddress = function (address) {
        address &= FastMemory.MASK;
        if ((address & 0x3E000000) == 0x08000000)
            return true;
        if ((address & 0x3F800000) == 0x04000000)
            return true;
        if ((address & 0xBFFF0000) == 0x00010000)
            return true;
        if (this.isAddressInRange(address, FastMemory.DEFAULT_FRAME_ADDRESS, FastMemory.DEFAULT_FRAME_ADDRESS + 0x200000))
            return true;
        if (this.isAddressInRange(address, 0x08000000, 0x08000000 + 0x04000000))
            return true;
        return false;
    };
    Memory.prototype.getPointerPointer = function (type, address) {
        if (address == 0)
            return null;
        return new Pointer(type, this, address);
    };
    Memory.prototype.getPointerDataView = function (address, size) {
        var data = this.getPointerU8Array(address, size);
        return new DataView(data.buffer, data.byteOffset, data.byteLength);
    };
    Memory.prototype.getPointerU8Array = function (address, size) {
        if (!size)
            size = this.availableAfterAddress(address);
        return this.slice(address, address + size);
    };
    Memory.prototype.getPointerU16Array = function (address, size) {
        return new Uint16Array(this.getPointerU8Array(address, size));
    };
    Memory.prototype.getPointerStream = function (address, size) {
        if (address == 0)
            return null;
        if (size === 0)
            return new Stream(new DataView(new ArrayBuffer(0)));
        if (!this.isValidAddress(address))
            return Stream.INVALID;
        if (size === undefined)
            size = this.availableAfterAddress(address & FastMemory.MASK);
        if (size < 0)
            return Stream.INVALID;
        return new Stream(this.getPointerDataView(address & FastMemory.MASK, size));
    };
    Memory.prototype.getU8Array = function (address, size) {
        if (address == 0)
            return null;
        if (!this.isValidAddress(address))
            return null;
        if (!size)
            size = this.availableAfterAddress(address & FastMemory.MASK);
        return this.getPointerU8Array(address & FastMemory.MASK, size);
    };
    Memory.prototype.getU16Array = function (address, size) {
        if (address == 0)
            return null;
        if (!this.isValidAddress(address))
            return null;
        if (!size)
            size = this.availableAfterAddress(address & FastMemory.MASK);
        return this.getPointerU16Array(address & FastMemory.MASK, size);
    };
    Memory.prototype.addWatch4 = function (address) {
        var _this = this;
        this.addWriteAction(address, function (address) {
            console.log(sprintf('Watch:0x%08X <- 0x%08X', address, _this.lwu(address)));
        });
    };
    Memory.prototype.addBreakpointOnValue = function (address, value) {
        //Watch: 0x0951044C < - 0x2A000000 
        var _this = this;
        this.addWriteAction(address, function (actualAddress) {
            var actualValue = _this.lwu(address);
            console.log(sprintf('TryBreakpoint:0x%08X <- 0x%08X | 0x%08X (%d)', address, actualValue, value, (actualValue == value)));
            if (actualValue == value) {
                debugger;
            }
        });
    };
    Memory.prototype.addWriteAction = function (address, action) {
        this.writeBreakpoints.push({ address: address, action: action });
    };
    Memory.prototype._checkWriteBreakpoints = function (start, end) {
        start &= FastMemory.MASK;
        end &= FastMemory.MASK;
        for (var n = 0; n < this.writeBreakpoints.length; n++) {
            var writeBreakpoint = this.writeBreakpoints[n];
            var addressCheck = writeBreakpoint.address & FastMemory.MASK;
            if (addressCheck >= start && addressCheck < end) {
                writeBreakpoint.action(writeBreakpoint.address);
            }
        }
    };
    Memory.prototype.readArrayBuffer = function (address, length) {
        var out = new Uint8Array(length);
        out.set(this.getPointerU8Array(address, length));
        return out.buffer;
    };
    Memory.prototype.sliceWithBounds = function (low, high) {
        return new Stream(this.getPointerDataView(low, high - low));
    };
    Memory.prototype.sliceWithSize = function (address, size) {
        return new Stream(this.getPointerDataView(address, size));
    };
    Memory.prototype.reset = function () {
        this.memset(FastMemory.DEFAULT_FRAME_ADDRESS, 0, 0x200000);
    };
    Memory.prototype.copy = function (from, to, length) {
        if (length <= 0)
            return;
        this.getPointerU8Array(to, length).set(this.getPointerU8Array(from, length));
        this._checkWriteBreakpoints(to, to + length);
    };
    Memory.prototype.memset = function (address, value, length) {
        var buffer = this.getPointerU8Array(address, length);
        for (var n = 0; n < buffer.length; n++)
            buffer[n] = value & 0xFF;
        this._checkWriteBreakpoints(address, address + length);
    };
    Memory.prototype.writeBytes = function (address, data) {
        this.getPointerU8Array(address, data.byteLength).set(new Uint8Array(data));
        this._checkWriteBreakpoints(address, address + data.byteLength);
    };
    Memory.prototype.writeStream = function (address, stream) {
        stream = stream.sliceWithLength(0, stream.length);
        while (stream.available > 0) {
            this.sb(address++, stream.readUInt8());
        }
        this._checkWriteBreakpoints(address, address + stream.length);
    };
    Memory.prototype.readStringz = function (address) {
        if (address == 0)
            return null;
        var out = '';
        while (true) {
            var _char = this.lbu(address++);
            if (_char == 0)
                break;
            out += String.fromCharCode(_char);
        }
        return out;
    };
    Memory.prototype.hashWordCount = function (addressAligned, count) {
        addressAligned >>>= 2;
        count >>>= 2;
        var result = 0;
        for (var n = 0; n < count; n++) {
            var v = this.lw_2(addressAligned + n);
            result = (result + v ^ n) | 0;
        }
        return result;
    };
    Memory.prototype.hash = function (address, count) {
        var result = 0;
        while ((address & 3) != 0) {
            result += this.lbu(address++);
            count--;
        }
        var count2 = MathUtils.prevAligned(count, 4);
        result += this.hashWordCount(address, count2);
        address += count2;
        count -= count2;
        while ((address & 3) != 0) {
            result += this.lbu(address++) * 7;
            count--;
        }
        return result;
    };
    Memory.prototype.writeUint8Array = function (address, data) {
        for (var n = 0; n < data.length; n++)
            this.sb(address + n, data[n]);
    };
    Memory.memoryCopy = function (source, sourcePosition, destination, destinationPosition, length) {
        var _source = new Uint8Array(source, sourcePosition, length);
        var _destination = new Uint8Array(destination, destinationPosition, length);
        _destination.set(_source);
    };
    Memory.prototype.dump = function (name) {
        if (name === void 0) { name = 'memory.bin'; }
        saveAs(new Blob([this.getPointerDataView(0x08000000, 0x2000000)]), name);
    };
    Memory.DEFAULT_FRAME_ADDRESS = 0x04000000;
    Memory.MASK = 0x0FFFFFFF;
    Memory.MAIN_OFFSET = 0x08000000;
    return Memory;
})();
exports.Memory = Memory;
var FastMemory = (function (_super) {
    __extends(FastMemory, _super);
    function FastMemory() {
        this.buffer = new ArrayBuffer(0x0a000000 + 4);
        this.s8 = new Int8Array(this.buffer);
        this.u8 = new Uint8Array(this.buffer);
        this.u16 = new Uint16Array(this.buffer);
        this.s16 = new Int16Array(this.buffer);
        this.s32 = new Int32Array(this.buffer);
        this.u32 = new Uint32Array(this.buffer);
        this.f32 = new Float32Array(this.buffer);
        _super.call(this);
    }
    FastMemory.prototype.sb = function (address, value) { this.u8[(address & MASK) >> 0] = value; };
    FastMemory.prototype.sh = function (address, value) { this.u16[(address & MASK) >> 1] = value; };
    FastMemory.prototype.sw = function (address, value) { this.u32[(address & MASK) >> 2] = value; };
    FastMemory.prototype.swc1 = function (address, value) { this.f32[(address & MASK) >> 2] = value; };
    FastMemory.prototype.lb = function (address) { return this.s8[(address & MASK) >> 0]; };
    FastMemory.prototype.lbu = function (address) { return this.u8[(address & MASK) >> 0]; };
    FastMemory.prototype.lh = function (address) { return this.s16[(address & MASK) >> 1]; };
    FastMemory.prototype.lhu = function (address) { return this.u16[(address & MASK) >> 1]; };
    FastMemory.prototype.lw = function (address) { return this.s32[(address & MASK) >> 2]; };
    FastMemory.prototype.lwu = function (address) { return this.u32[(address & MASK) >> 2]; };
    FastMemory.prototype.lwc1 = function (address) { return this.f32[(address & MASK) >> 2]; };
    FastMemory.prototype.lw_2 = function (address) { return this.u32[address]; };
    FastMemory.prototype.slice = function (low, high) {
        low &= MASK;
        high &= MASK;
        return new Uint8Array(this.buffer, low, high - low);
    };
    FastMemory.prototype.availableAfterAddress = function (address) {
        return this.buffer.byteLength - (address & MASK);
    };
    FastMemory.prototype.getU16Array = function (address, size) {
        if (address == 0)
            return null;
        if (!this.isValidAddress(address))
            return null;
        if (!size)
            size = this.availableAfterAddress(address & FastMemory.MASK);
        return new Uint16Array(this.buffer, address, size / 2);
    };
    return FastMemory;
})(Memory);
var LowMemorySegment = (function () {
    function LowMemorySegment(name, offset, buffer) {
        this.name = name;
        this.offset = offset;
        this.buffer = buffer;
        this.size = buffer.byteLength;
        this.low = offset;
        this.high = this.low + this.size;
        this.s8 = new Int8Array(this.buffer);
        this.u8 = new Uint8Array(this.buffer);
        this.u16 = new Uint16Array(this.buffer);
        this.s16 = new Int16Array(this.buffer);
        this.s32 = new Int32Array(this.buffer);
        this.u32 = new Uint32Array(this.buffer);
        this.f32 = new Float32Array(this.buffer);
    }
    LowMemorySegment.prototype.contains = function (address) {
        address &= MASK;
        return address >= this.low && address < this.high;
    };
    LowMemorySegment.prototype.fixAddress = function (address) { return (address & MASK) - this.offset; };
    LowMemorySegment.prototype.sb = function (address, value) { this.u8[this.fixAddress(address) >> 0] = value; };
    LowMemorySegment.prototype.sh = function (address, value) { this.u16[this.fixAddress(address) >> 1] = value; };
    LowMemorySegment.prototype.sw = function (address, value) { this.u32[this.fixAddress(address) >> 2] = value; };
    LowMemorySegment.prototype.swc1 = function (address, value) { this.f32[this.fixAddress(address) >> 2] = value; };
    LowMemorySegment.prototype.lb = function (address) { return this.s8[this.fixAddress(address) >> 0]; };
    LowMemorySegment.prototype.lbu = function (address) { return this.u8[this.fixAddress(address) >> 0]; };
    LowMemorySegment.prototype.lh = function (address) { return this.s16[this.fixAddress(address) >> 1]; };
    LowMemorySegment.prototype.lhu = function (address) { return this.u16[this.fixAddress(address) >> 1]; };
    LowMemorySegment.prototype.lw = function (address) { return this.s32[this.fixAddress(address) >> 2]; };
    LowMemorySegment.prototype.lwu = function (address) { return this.u32[this.fixAddress(address) >> 2]; };
    LowMemorySegment.prototype.lwc1 = function (address) { return this.f32[this.fixAddress(address) >> 2]; };
    LowMemorySegment.prototype.slice = function (low, high) {
        var low2 = this.fixAddress(low);
        var high2 = this.fixAddress(high);
        return new Uint8Array(this.buffer, low2, high2 - low2);
    };
    LowMemorySegment.prototype.getU16Array = function (address, size) {
        return new Uint16Array(this.buffer, this.fixAddress(address), size / 2);
    };
    LowMemorySegment.prototype.availableAfterAddress = function (address) {
        return this.buffer.byteLength - this.fixAddress(address);
    };
    return LowMemorySegment;
})();
var LowMemory = (function (_super) {
    __extends(LowMemory, _super);
    function LowMemory() {
        this.scratchpad = new LowMemorySegment('scatchpad', 0x00000000, new ArrayBuffer(16 * 1024 + 0x00010000));
        this.videomem = new LowMemorySegment('videomem', 0x04000000, new ArrayBuffer(2 * 1024 * 1024));
        this.mainmem = new LowMemorySegment('mainmem', 0x08000000, new ArrayBuffer(32 * 1024 * 1024));
        _super.call(this);
    }
    LowMemory.prototype.getMemRange = function (address) {
        address &= MASK;
        if (address >= 0x08000000) {
            return this.mainmem;
        }
        else {
            if (this.scratchpad.contains(address))
                return this.scratchpad;
            if (this.videomem.contains(address))
                return this.videomem;
            if (this.mainmem.contains(address))
                return this.mainmem;
            printf("Unmapped: %08X", address);
            return null;
        }
    };
    LowMemory.prototype.sb = function (address, value) { this.getMemRange(address).sb(address, value); };
    LowMemory.prototype.sh = function (address, value) { this.getMemRange(address).sh(address, value); };
    LowMemory.prototype.sw = function (address, value) { this.getMemRange(address).sw(address, value); };
    LowMemory.prototype.swc1 = function (address, value) { this.getMemRange(address).swc1(address, value); };
    LowMemory.prototype.lb = function (address) { return this.getMemRange(address).lb(address); };
    LowMemory.prototype.lbu = function (address) { return this.getMemRange(address).lbu(address); };
    LowMemory.prototype.lh = function (address) { return this.getMemRange(address).lh(address); };
    LowMemory.prototype.lhu = function (address) { return this.getMemRange(address).lhu(address); };
    LowMemory.prototype.lw = function (address) { return this.getMemRange(address).lw(address); };
    LowMemory.prototype.lwu = function (address) { return this.getMemRange(address).lwu(address); };
    LowMemory.prototype.lwc1 = function (address) { return this.getMemRange(address).lwc1(address); };
    LowMemory.prototype.lw_2 = function (address4) { return this.getMemRange(address4 * 4).lw(address4 * 4); };
    LowMemory.prototype.slice = function (low, high) {
        return this.getMemRange(low).slice(low, high);
    };
    LowMemory.prototype.getU16Array = function (address, size) {
        if (address == 0)
            return null;
        if (!this.isValidAddress(address))
            return null;
        return this.getMemRange(address).getU16Array(address, size);
    };
    LowMemory.prototype.availableAfterAddress = function (address) {
        return this.getMemRange(address).availableAfterAddress(address);
    };
    return LowMemory;
})(Memory);
function isNodeJs() {
    return typeof process != 'undefined';
}
function allowBigAlloc() {
    try {
        var ab = new ArrayBuffer(0x0a000000 + 4);
        return true;
    }
    catch (e) {
        return false;
    }
}
function supportFastMemory() {
    return !isNodeJs();
}
function create() {
    if (supportFastMemory()) {
        return new FastMemory();
    }
    else {
        return new LowMemory();
    }
}
exports.create = create;
var _instance = null;
function getInstance() {
    if (_instance == null)
        _instance = create();
    return _instance;
}
exports.getInstance = getInstance;

},
"src/core/pixelformat": function(module, exports, require) {
///<reference path="../global.d.ts" />
var _memory = require('./memory');
var Memory = _memory.Memory;
var PixelFormatUtils = (function () {
    function PixelFormatUtils() {
    }
    PixelFormatUtils.hasClut = function (pixelFormat) {
        return ((pixelFormat >= PixelFormat.PALETTE_T4) && (pixelFormat <= PixelFormat.PALETTE_T32));
    };
    return PixelFormatUtils;
})();
exports.PixelFormatUtils = PixelFormatUtils;
(function (PixelFormat) {
    PixelFormat[PixelFormat["NONE"] = -1] = "NONE";
    PixelFormat[PixelFormat["RGBA_5650"] = 0] = "RGBA_5650";
    PixelFormat[PixelFormat["RGBA_5551"] = 1] = "RGBA_5551";
    PixelFormat[PixelFormat["RGBA_4444"] = 2] = "RGBA_4444";
    PixelFormat[PixelFormat["RGBA_8888"] = 3] = "RGBA_8888";
    PixelFormat[PixelFormat["PALETTE_T4"] = 4] = "PALETTE_T4";
    PixelFormat[PixelFormat["PALETTE_T8"] = 5] = "PALETTE_T8";
    PixelFormat[PixelFormat["PALETTE_T16"] = 6] = "PALETTE_T16";
    PixelFormat[PixelFormat["PALETTE_T32"] = 7] = "PALETTE_T32";
    PixelFormat[PixelFormat["COMPRESSED_DXT1"] = 8] = "COMPRESSED_DXT1";
    PixelFormat[PixelFormat["COMPRESSED_DXT3"] = 9] = "COMPRESSED_DXT3";
    PixelFormat[PixelFormat["COMPRESSED_DXT5"] = 10] = "COMPRESSED_DXT5";
})(exports.PixelFormat || (exports.PixelFormat = {}));
var PixelFormat = exports.PixelFormat;
var sizes = {};
sizes[PixelFormat.COMPRESSED_DXT1] = 0.5;
sizes[PixelFormat.COMPRESSED_DXT3] = 1;
sizes[PixelFormat.COMPRESSED_DXT5] = 1;
sizes[PixelFormat.NONE] = 0;
sizes[PixelFormat.PALETTE_T16] = 2;
sizes[PixelFormat.PALETTE_T32] = 4;
sizes[PixelFormat.PALETTE_T8] = 1;
sizes[PixelFormat.PALETTE_T4] = 0.5;
sizes[PixelFormat.RGBA_4444] = 2;
sizes[PixelFormat.RGBA_5551] = 2;
sizes[PixelFormat.RGBA_5650] = 2;
sizes[PixelFormat.RGBA_8888] = 4;
var PixelConverter = (function () {
    function PixelConverter() {
    }
    PixelConverter.getSizeInBytes = function (format, count) {
        return sizes[format] * count;
    };
    PixelConverter.unswizzleInline = function (format, from, fromIndex, width, height) {
        var rowWidth = PixelConverter.getSizeInBytes(format, width);
        var textureHeight = height;
        var size = rowWidth * textureHeight;
        var temp = new Uint8Array(size);
        PixelConverter.unswizzle(new Uint8Array(from, fromIndex), new Uint8Array(temp.buffer), rowWidth, textureHeight);
        new Uint8Array(from, fromIndex, size).set(temp);
    };
    PixelConverter.unswizzle = function (input, output, rowWidth, textureHeight) {
        var pitch = ToInt32((rowWidth - 16) / 4);
        var bxc = ToInt32(rowWidth / 16);
        var byc = ToInt32(textureHeight / 8);
        var pitch4 = ToInt32(pitch * 4);
        var src = 0;
        var ydest = 0;
        for (var by = 0; by < byc; by++) {
            var xdest = ydest;
            for (var bx = 0; bx < bxc; bx++) {
                var dest = xdest;
                for (var n = 0; n < 8; n++, dest += pitch4) {
                    for (var m = 0; m < 16; m++)
                        output[dest++] = input[src++];
                }
                xdest += 16;
            }
            ydest += rowWidth * 8;
        }
    };
    PixelConverter.decode = function (format, fromArray, to, toIndex, count, useAlpha, palette, clutStart, clutShift, clutMask) {
        if (useAlpha === void 0) { useAlpha = true; }
        if (palette === void 0) { palette = null; }
        if (clutStart === void 0) { clutStart = 0; }
        if (clutShift === void 0) { clutShift = 0; }
        if (clutMask === void 0) { clutMask = 0; }
        var from = fromArray.buffer;
        var fromIndex = fromArray.byteOffset;
        switch (format) {
            case PixelFormat.RGBA_8888:
                PixelConverter.decode8888(new Uint8Array(from), (fromIndex >>> 0) & Memory.MASK, to, toIndex, count, useAlpha);
                break;
            case PixelFormat.RGBA_5551:
                PixelConverter.update5551(new Uint16Array(from), (fromIndex >>> 1) & Memory.MASK, to, toIndex, count, useAlpha);
                break;
            case PixelFormat.RGBA_5650:
                PixelConverter.update5650(new Uint16Array(from), (fromIndex >>> 1) & Memory.MASK, to, toIndex, count, useAlpha);
                break;
            case PixelFormat.RGBA_4444:
                PixelConverter.update4444(new Uint16Array(from), (fromIndex >>> 1) & Memory.MASK, to, toIndex, count, useAlpha);
                break;
            case PixelFormat.PALETTE_T8:
                PixelConverter.updateT8(new Uint8Array(from), (fromIndex >>> 0) & Memory.MASK, to, toIndex, count, useAlpha, palette, clutStart, clutShift, clutMask);
                break;
            case PixelFormat.PALETTE_T4:
                PixelConverter.updateT4(new Uint8Array(from), (fromIndex >>> 0) & Memory.MASK, to, toIndex, count, useAlpha, palette, clutStart, clutShift, clutMask);
                break;
            default: throw new Error("Unsupported pixel format " + format);
        }
    };
    PixelConverter.updateT4 = function (from, fromIndex, to, toIndex, count, useAlpha, palette, clutStart, clutShift, clutMask) {
        if (useAlpha === void 0) { useAlpha = true; }
        if (palette === void 0) { palette = null; }
        if (clutStart === void 0) { clutStart = 0; }
        if (clutShift === void 0) { clutShift = 0; }
        if (clutMask === void 0) { clutMask = 0; }
        var to32 = ArrayBufferUtils.uint8ToUint32(to, toIndex);
        var orValue = useAlpha ? 0 : 0xFF000000;
        count |= 0;
        clutStart |= 0;
        clutShift |= 0;
        clutMask &= 0xF;
        var updateT4Translate = PixelConverter.updateT4Translate;
        for (var m = 0; m < 16; m++)
            updateT4Translate[m] = palette[((clutStart + m) >>> clutShift) & clutMask];
        for (var n = 0, m = 0; n < count; n++) {
            var char = from[fromIndex + n];
            to32[m++] = updateT4Translate[(char >>> 0) & 0xF] | orValue;
            to32[m++] = updateT4Translate[(char >>> 4) & 0xF] | orValue;
        }
    };
    PixelConverter.updateT8 = function (from, fromIndex, to, toIndex, count, useAlpha, palette, clutStart, clutShift, clutMask) {
        if (useAlpha === void 0) { useAlpha = true; }
        if (palette === void 0) { palette = null; }
        if (clutStart === void 0) { clutStart = 0; }
        if (clutShift === void 0) { clutShift = 0; }
        if (clutMask === void 0) { clutMask = 0; }
        var to32 = ArrayBufferUtils.uint8ToUint32(to, toIndex);
        var orValue = useAlpha ? 0 : 0xFF000000;
        clutMask &= 0xFF;
        if (count > 1024) {
            var updateT8Translate = PixelConverter.updateT8Translate;
            for (var m = 0; m < 256; m++)
                updateT8Translate[m] = palette[((clutStart + m) >>> clutShift) & clutMask];
            for (var m = 0; m < count; m++)
                to32[m] = updateT8Translate[from[fromIndex + m]] | orValue;
        }
        else {
            for (var m = 0; m < count; m++)
                to32[m] = palette[clutStart + ((from[fromIndex + m] & clutMask) << clutShift)] | orValue;
        }
    };
    PixelConverter.decode8888 = function (from, fromIndex, to, toIndex, count, useAlpha) {
        if (useAlpha === void 0) { useAlpha = true; }
        var to32 = ArrayBufferUtils.uint8ToUint32(to, toIndex);
        var from32 = ArrayBufferUtils.uint8ToUint32(from, fromIndex);
        var orValue = useAlpha ? 0 : 0xFF000000;
        for (var n = 0; n < count; n++)
            to32[n] = from32[n] | orValue;
    };
    PixelConverter.update5551 = function (from, fromIndex, to, toIndex, count, useAlpha) {
        if (useAlpha === void 0) { useAlpha = true; }
        var to32 = ArrayBufferUtils.uint8ToUint32(to, toIndex);
        var orValue = useAlpha ? 0 : 0xFF000000;
        for (var n = 0; n < count; n++) {
            var it_1 = from[fromIndex++];
            var value = 0;
            value |= BitUtils.extractScalei(it_1, 0, 5, 0xFF) << 0;
            value |= BitUtils.extractScalei(it_1, 5, 5, 0xFF) << 8;
            value |= BitUtils.extractScalei(it_1, 10, 5, 0xFF) << 16;
            value |= BitUtils.extractScalei(it_1, 15, 1, 0xFF) << 24;
            value |= orValue;
            to32[n] = value;
        }
    };
    PixelConverter.update5650 = function (from, fromIndex, to, toIndex, count, useAlpha) {
        if (useAlpha === void 0) { useAlpha = true; }
        var to32 = ArrayBufferUtils.uint8ToUint32(to, toIndex);
        for (var n = 0; n < count; n++) {
            var it_2 = from[fromIndex++];
            var value = 0;
            value |= BitUtils.extractScalei(it_2, 0, 5, 0xFF) << 0;
            value |= BitUtils.extractScalei(it_2, 5, 6, 0xFF) << 8;
            value |= BitUtils.extractScalei(it_2, 11, 5, 0xFF) << 16;
            value |= 0xFF000000;
            to32[n] = value;
        }
    };
    PixelConverter.update4444 = function (from, fromIndex, to, toIndex, count, useAlpha) {
        if (useAlpha === void 0) { useAlpha = true; }
        var to32 = ArrayBufferUtils.uint8ToUint32(to, toIndex);
        for (var n = 0; n < count; n++) {
            var it_3 = from[fromIndex++];
            var value = 0;
            value |= BitUtils.extractScalei(it_3, 0, 4, 0xFF) << 0;
            value |= BitUtils.extractScalei(it_3, 4, 4, 0xFF) << 8;
            value |= BitUtils.extractScalei(it_3, 8, 4, 0xFF) << 16;
            value |= (useAlpha ? BitUtils.extractScalei(it_3, 12, 4, 0xFF) : 0xFF) << 24;
            to32[n] = value;
        }
    };
    PixelConverter.updateT4Translate = new Uint32Array(16);
    PixelConverter.updateT8Translate = new Uint32Array(256);
    return PixelConverter;
})();
exports.PixelConverter = PixelConverter;

},
"src/core/rtc": function(module, exports, require) {
///<reference path="../global.d.ts" />
var PspRtc = (function () {
    function PspRtc() {
    }
    PspRtc.prototype.getCurrentUnixSeconds = function () { return Date.now() / 1000; };
    PspRtc.prototype.getCurrentUnixMicroseconds = function () { return Date.now() * 1000; };
    PspRtc.prototype.getClockMicroseconds = function () { return (performance.now() * 1000) >>> 0; };
    PspRtc.prototype.getDayOfWeek = function (year, month, day) { return new Date(year, month - 1, day).getDay(); };
    PspRtc.prototype.getDaysInMonth = function (year, month) { return new Date(year, month, 0).getDate(); };
    return PspRtc;
})();
exports.PspRtc = PspRtc;

},
"src/core/stream": function(module, exports, require) {
exports.MemoryAsyncStream2 = MemoryAsyncStream;

},
"src/emulator": function(module, exports, require) {
///<reference path="global.d.ts" />
var _context = require('./context');
var _cpu = require('./core/cpu');
var _gpu = require('./core/gpu');
var _rtc = require('./core/rtc');
var _controller = require('./core/controller');
var _stream = require('./core/stream');
_stream;
var _display = require('./core/display');
var _audio = require('./core/audio');
var _interrupt = require('./core/interrupt');
var _memory = require('./core/memory');
var _format = require('./format/format');
var _format_cso = require('./format/cso');
var _format_iso = require('./format/iso');
var _format_zip = require('./format/zip');
var _pbp = require('./format/pbp');
var _psf = require('./format/psf');
var _vfs = require('./hle/vfs');
var _config = require('./hle/config');
var _elf_psp = require('./hle/elf_psp');
var _elf_crypted_prx = require('./hle/elf_crypted_prx');
var _manager = require('./hle/manager');
var _pspmodules = require('./hle/pspmodules');
var PspRtc = _rtc.PspRtc;
var FileOpenFlags = _vfs.FileOpenFlags;
var MountableVfs = _vfs.MountableVfs;
var UriVfs = _vfs.UriVfs;
var IsoVfs = _vfs.IsoVfs;
var ZipVfs = _vfs.ZipVfs;
var StorageVfs = _vfs.StorageVfs;
var MemoryStickVfs = _vfs.MemoryStickVfs;
var EmulatorVfs = _vfs.EmulatorVfs;
_vfs.EmulatorVfs;
var MemoryVfs = _vfs.MemoryVfs;
var ProxyVfs = _vfs.ProxyVfs;
var Config = _config.Config;
var PspElfLoader = _elf_psp.PspElfLoader;
var EmulatorContext = _context.EmulatorContext;
var InterruptManager = _interrupt.InterruptManager;
var PspAudio = _audio.PspAudio;
var PspDisplay = _display.PspDisplay;
var PspGpu = _gpu.PspGpu;
var PspController = _controller.PspController;
var SyscallManager = _cpu.SyscallManager;
var ThreadManager = _manager.ThreadManager;
var ModuleManager = _manager.ModuleManager;
var MemoryManager = _manager.MemoryManager;
var NetManager = _manager.NetManager;
var FileManager = _manager.FileManager;
var CallbackManager = _manager.CallbackManager;
var Interop = _manager.Interop;
var console = logger.named('emulator');
var Emulator = (function () {
    function Emulator(memory) {
        this.gameTitle = '';
        if (!memory)
            memory = _memory.getInstance();
        this.memory = memory;
    }
    Emulator.prototype.stopAsync = function () {
        if (!this.display)
            return Promise2.resolve();
        return Promise2.all([
            this.display.stopAsync(),
            this.controller.stopAsync(),
            this.gpu.stopAsync(),
            this.audio.stopAsync(),
            this.threadManager.stopAsync(),
        ]);
    };
    Emulator.prototype.startAsync = function () {
        var _this = this;
        return this.stopAsync().then(function () {
            _this.memory.reset();
            _this.context = new EmulatorContext();
            _this.memoryManager = new MemoryManager();
            _this.interruptManager = new InterruptManager();
            _this.audio = new PspAudio();
            if (typeof document != 'undefined') {
                _this.canvas = (document.getElementById('canvas'));
                _this.webgl_canvas = (document.getElementById('webgl_canvas'));
            }
            else {
                _this.canvas = null;
                _this.webgl_canvas = null;
            }
            _this.controller = new PspController();
            _this.syscallManager = new SyscallManager(_this.context);
            _this.fileManager = new FileManager();
            _this.interop = new Interop();
            _this.config = new Config();
            _this.callbackManager = new CallbackManager(_this.interop);
            _this.rtc = new PspRtc();
            _this.display = new PspDisplay(_this.memory, _this.interruptManager, _this.canvas, _this.webgl_canvas);
            _this.gpu = new PspGpu(_this.memory, _this.display, _this.webgl_canvas, _this.interop);
            _this.threadManager = new ThreadManager(_this.memory, _this.interruptManager, _this.callbackManager, _this.memoryManager, _this.display, _this.syscallManager);
            _this.moduleManager = new ModuleManager(_this.context);
            _this.netManager = new NetManager();
            _this.emulatorVfs = new EmulatorVfs(_this.context);
            _this.ms0Vfs = new MountableVfs();
            _this.storageVfs = new StorageVfs('psp_storage');
            var msvfs = new MemoryStickVfs([_this.storageVfs, _this.ms0Vfs], _this.callbackManager, _this.memory);
            _this.fileManager.mount('fatms0', msvfs);
            _this.fileManager.mount('ms0', msvfs);
            _this.fileManager.mount('mscmhc0', msvfs);
            _this.fileManager.mount('host0', new MemoryVfs());
            _this.fileManager.mount('flash0', new UriVfs('data/flash0'));
            _this.fileManager.mount('emulator', _this.emulatorVfs);
            _this.fileManager.mount('kemulator', _this.emulatorVfs);
            _this.ms0Vfs.mountVfs('/', new MemoryVfs());
            _pspmodules.registerModulesAndSyscalls(_this.syscallManager, _this.moduleManager);
            _this.context.init(_this.interruptManager, _this.display, _this.controller, _this.gpu, _this.memoryManager, _this.threadManager, _this.audio, _this.memory, _this.fileManager, _this.rtc, _this.callbackManager, _this.moduleManager, _this.config, _this.interop, _this.netManager);
            return Promise2.all([
                _this.display.startAsync(),
                _this.controller.startAsync(),
                _this.gpu.startAsync(),
                _this.audio.startAsync(),
                _this.threadManager.startAsync(),
            ]);
        });
    };
    Emulator.prototype.processParamsPsf = function (psf) {
        this.gameTitle = psf.entriesByName['TITLE'];
        console.log(psf.entriesByName);
    };
    Emulator.prototype.changeFavicon = function (src) {
        if (typeof document == 'undefined')
            return;
        var link = document.createElement('link'), oldLink = document.getElementById('dynamic-favicon');
        link.id = 'dynamic-favicon';
        link.rel = 'shortcut icon';
        link.href = src;
        if (oldLink) {
            document.head.removeChild(oldLink);
        }
        document.head.appendChild(link);
    };
    Emulator.prototype.loadIcon0 = function (data) {
        if (data.length == 0) {
            this.changeFavicon('icon.png');
        }
        else {
            this.changeFavicon(data.toImageUrl());
        }
    };
    Emulator.prototype.loadPic1 = function (data) {
        if (typeof document == 'undefined')
            return;
        document.body.style.backgroundRepeat = 'no-repeat';
        document.body.style.backgroundSize = 'cover';
        document.body.style.backgroundPosition = 'center center';
        document.body.style.backgroundImage = 'url("' + data.toImageUrl() + '")';
    };
    Emulator.prototype._loadAndExecuteAsync = function (asyncStream, pathToFile) {
        var _this = this;
        return _format.detectFormatAsync(asyncStream).then(function (fileFormat) {
            console.info("File:: size: " + asyncStream.size + ", format: \"" + fileFormat + "\", name: \"" + asyncStream.name + "\"");
            switch (fileFormat) {
                case 'ciso':
                    return _format_cso.Cso.fromStreamAsync(asyncStream).then(function (asyncStream2) { return _this._loadAndExecuteAsync(asyncStream2, pathToFile); });
                case 'pbp':
                    return asyncStream.readChunkAsync(0, asyncStream.size).then(function (executableArrayBuffer) {
                        var pbp = _pbp.Pbp.fromStream(Stream.fromArrayBuffer(executableArrayBuffer));
                        var psf = _psf.Psf.fromStream(pbp.get(_pbp.Names.ParamSfo));
                        _this.processParamsPsf(psf);
                        _this.loadIcon0(pbp.get(_pbp.Names.Icon0Png));
                        _this.loadPic1(pbp.get(_pbp.Names.Pic1Png));
                        return _this._loadAndExecuteAsync(new MemoryAsyncStream(pbp.get(_pbp.Names.PspData).toArrayBuffer()), pathToFile);
                    });
                case 'psp':
                    return asyncStream.readChunkAsync(0, asyncStream.size).then(function (executableArrayBuffer) {
                        return _this._loadAndExecuteAsync(new MemoryAsyncStream(_elf_crypted_prx.decrypt(Stream.fromArrayBuffer(executableArrayBuffer)).slice().readAllBytes().buffer, pathToFile + ".CryptedPSP"), pathToFile);
                    });
                case 'zip':
                    return _format_zip.Zip.fromStreamAsync(asyncStream).then(function (zip) {
                        var zipFs = new ZipVfs(zip, _this.storageVfs);
                        var mountableVfs = _this.ms0Vfs;
                        mountableVfs.mountVfs('/PSP/GAME/virtual', zipFs);
                        var availableElf = ['/EBOOT.ELF', '/BOOT.ELF', '/EBOOT.PBP'].first(function (item) { return zip.has(item); });
                        console.log('elf: ' + availableElf);
                        return zipFs.openAsync(availableElf, FileOpenFlags.Read, parseInt('0777', 8)).then(function (node) {
                            return node.readAllAsync().then(function (data) {
                                return _this._loadAndExecuteAsync(MemoryAsyncStream.fromArrayBuffer(data), 'ms0:/PSP/GAME/virtual/EBOOT.ELF');
                            });
                        });
                    });
                case 'iso':
                    return _format_iso.Iso.fromStreamAsync(asyncStream).then(function (iso) {
                        var isoFs = new IsoVfs(iso);
                        _this.fileManager.mount('umd0', isoFs);
                        _this.fileManager.mount('umd1', isoFs);
                        _this.fileManager.mount('disc0', isoFs);
                        _this.fileManager.mount('disc1', isoFs);
                        return isoFs.existsAsync('PSP_GAME/PARAM.SFO').then(function (exists) {
                            if (!exists) {
                                var mountableVfs = _this.ms0Vfs;
                                mountableVfs.mountVfs('/PSP/GAME/virtual', new ProxyVfs([isoFs, _this.storageVfs]));
                                return isoFs.readAllAsync('EBOOT.PBP').then(function (bootBinData) {
                                    return _this._loadAndExecuteAsync(MemoryAsyncStream.fromArrayBuffer(bootBinData), 'ms0:/PSP/GAME/virtual/EBOOT.PBP');
                                });
                            }
                            else {
                                return isoFs.readAllAsync('PSP_GAME/PARAM.SFO').then(function (paramSfoData) {
                                    var psf = _psf.Psf.fromStream(Stream.fromArrayBuffer(paramSfoData));
                                    _this.processParamsPsf(psf);
                                    var icon0Promise = isoFs.readAllAsync('PSP_GAME/ICON0.PNG').then(function (data) { _this.loadIcon0(Stream.fromArrayBuffer(data)); }).catch(function () { });
                                    var pic1Promise = isoFs.readAllAsync('PSP_GAME/PIC1.PNG').then(function (data) { _this.loadPic1(Stream.fromArrayBuffer(data)); }).catch(function () { });
                                    return isoFs.existsAsync('PSP_GAME/SYSDIR/BOOT.BIN').then(function (exists) {
                                        var path = exists ? 'PSP_GAME/SYSDIR/BOOT.BIN' : 'PSP_GAME/SYSDIR/EBOOT.BIN';
                                        return isoFs.readAllAsync(path).then(function (bootBinData) {
                                            return _this._loadAndExecuteAsync(MemoryAsyncStream.fromArrayBuffer(bootBinData), 'umd0:/' + path);
                                        });
                                    });
                                });
                            }
                        });
                    });
                case 'elf':
                    return asyncStream.readChunkAsync(0, asyncStream.size).then(function (executableArrayBuffer) {
                        if (typeof document != 'undefined') {
                            if (_this.gameTitle) {
                                document.title = _this.gameTitle + ' - jspspemu';
                            }
                            else {
                                document.title = 'jspspemu';
                            }
                        }
                        var mountableVfs = _this.ms0Vfs;
                        mountableVfs.mountFileData('/PSP/GAME/virtual/EBOOT.ELF', executableArrayBuffer);
                        var elfStream = Stream.fromArrayBuffer(executableArrayBuffer);
                        _this.fileManager.cwd = new _manager.Uri('ms0:/PSP/GAME/virtual');
                        console.info('pathToFile:', pathToFile);
                        var args = [pathToFile];
                        var argumentsPartition = _this.memoryManager.userPartition.allocateLow(0x4000);
                        var argument = args.map(function (argument) { return argument + String.fromCharCode(0); }).join('');
                        _this.memory.getPointerStream(argumentsPartition.low).writeString(argument);
                        var pspElf = new PspElfLoader(_this.memory, _this.memoryManager, _this.moduleManager, _this.syscallManager);
                        pspElf.load(elfStream);
                        _this.context.symbolLookup = pspElf;
                        _this.context.gameTitle = _this.gameTitle;
                        _this.context.gameId = pspElf.moduleInfo.name;
                        var moduleInfo = pspElf.moduleInfo;
                        var thread = _this.threadManager.create('main', moduleInfo.pc, 10);
                        thread.state.GP = moduleInfo.gp;
                        thread.state.gpr[4] = argument.length;
                        thread.state.gpr[5] = argumentsPartition.low;
                        thread.start();
                    });
                default:
                    throw new Error("\"Unhandled format '" + fileFormat + "'");
            }
        });
    };
    Emulator.prototype.checkPlugins = function () {
    };
    Emulator.prototype.loadExecuteAndWaitAsync = function (asyncStream, url, afterStartCallback) {
        var _this = this;
        this.gameTitle = '';
        return this.loadAndExecuteAsync(asyncStream, url).then(function () {
            if (afterStartCallback)
                afterStartCallback();
            return _this.threadManager.waitExitGameAsync().then(function () {
                return _this.stopAsync().then(function () {
                    return _this.emulatorVfs.output;
                });
            });
        }).catch(function (e) {
            console.error(e);
            console.error(e.stack);
            throw (e);
        });
    };
    Emulator.disableLog = function () {
        global.loggerPolicies.disableAll = true;
    };
    Emulator.prototype.loadAndExecuteAsync = function (asyncStream, url) {
        var _this = this;
        if (typeof $ != 'undefined')
            $('#game_menu').fadeOut(100);
        url = String(url);
        this.gameTitle = '';
        this.loadIcon0(Stream.fromArray([]));
        this.loadPic1(Stream.fromArray([]));
        return this.startAsync().then(function () {
            var parentUrl = url.replace(/\/[^//]+$/, '');
            console.info('parentUrl: ' + parentUrl);
            _this.ms0Vfs.mountVfs('/PSP/GAME/virtual', new UriVfs(parentUrl));
            return _this._loadAndExecuteAsync(asyncStream, "ms0:/PSP/GAME/virtual/EBOOT.PBP");
        }).catch(function (e) {
            console.error(e);
            console.error(e.stack);
            throw (e);
        });
    };
    Emulator.prototype.downloadAndExecuteAsync = function (url) {
        var _this = this;
        return UrlAsyncStream.fromUrlAsync(url).then(function (stream) {
            Microtask.queue(function () {
                _this.loadAndExecuteAsync(stream, url);
            });
        });
    };
    Emulator.prototype.executeFileAsync = function (file) {
        var _this = this;
        Microtask.queue(function () {
            _this.loadAndExecuteAsync(new FileAsyncStream(file), '.');
        });
    };
    return Emulator;
})();
exports.Emulator = Emulator;

},
"src/format/cso": function(module, exports, require) {
///<reference path="../global.d.ts" />
var CSO_MAGIC = 'CISO';
var Header = (function () {
    function Header() {
    }
    Object.defineProperty(Header.prototype, "numberOfBlocks", {
        get: function () { return Math.floor(this.totalBytes / this.blockSize); },
        enumerable: true,
        configurable: true
    });
    Header.struct = StructClass.create(Header, [
        { magic: Stringz(4) },
        { headerSize: UInt32 },
        { totalBytes: Int64 },
        { blockSize: UInt32 },
        { version: UInt8 },
        { alignment: UInt8 },
        { reserved: UInt16 },
    ]);
    return Header;
})();
var Cso = (function () {
    function Cso() {
        this.date = new Date();
        this.cache = new AsyncCache(128 * 1024, function (arraybuffer) { return arraybuffer.byteLength; });
    }
    Cso.fromStreamAsync = function (stream) {
        return new Cso().loadAsync(stream);
    };
    Object.defineProperty(Cso.prototype, "name", {
        get: function () { return this.stream.name; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Cso.prototype, "size", {
        get: function () { return this.header.totalBytes; },
        enumerable: true,
        configurable: true
    });
    Cso.prototype.decodeBlockAsync = function (index) {
        var _this = this;
        return this.cache.getOrGenerateAsync('item-' + index, function () {
            var compressed = ((_this.offsets[index + 0] & 0x80000000) == 0);
            var low = _this.offsets[index + 0] & 0x7FFFFFFF;
            var high = _this.offsets[index + 1] & 0x7FFFFFFF;
            return _this.stream.readChunkAsync(low, high - low).then(function (data) {
                return (compressed ? inflateRawArrayBufferAsync(data).then(function (value) {
                    return value;
                }) : data);
            }).catch(function (e) {
                console.error(e);
                throw (e);
            });
        }).then(function (v) {
            return v;
        });
    };
    Cso.prototype.readChunkAsync = function (offset, count) {
        var _this = this;
        var blockIndex = Math.floor(offset / this.header.blockSize);
        var blockLow = MathUtils.prevAligned(offset, this.header.blockSize);
        var blockHigh = blockLow + this.header.blockSize;
        var maxReadCount = blockHigh - offset;
        var toReadInChunk = Math.min(count, maxReadCount);
        var chunkPromise = this.decodeBlockAsync(blockIndex).then(function (data) {
            var low = offset - blockLow;
            return data.slice(low, low + toReadInChunk);
        });
        if (count <= maxReadCount) {
            return chunkPromise;
        }
        else {
            return chunkPromise.then(function (chunk1) {
                return _this.readChunkAsync(offset + toReadInChunk, count - toReadInChunk).then(function (chunk2) {
                    var result = ArrayBufferUtils.concat([chunk1, chunk2]);
                    return result;
                });
            });
        }
    };
    Cso.prototype.loadAsync = function (stream) {
        var _this = this;
        this.stream = stream;
        this.date = stream.date;
        return stream.readChunkAsync(0, Header.struct.length).then(function (buffer) {
            var header = _this.header = Header.struct.read(Stream.fromArrayBuffer(buffer));
            if (header.magic != CSO_MAGIC)
                throw ('Not a CSO file');
            return stream.readChunkAsync(Header.struct.length, (header.numberOfBlocks + 1) * 4).then(function (buffer) {
                _this.offsets = new Uint32Array(buffer);
                return _this;
            });
        });
    };
    return Cso;
})();
exports.Cso = Cso;

},
"src/format/elf": function(module, exports, require) {
///<reference path="../global.d.ts" />
var _memory = require('../core/memory');
var Memory = _memory.Memory;
var console = logger.named('elf');
var ElfHeader = (function () {
    function ElfHeader() {
    }
    Object.defineProperty(ElfHeader.prototype, "hasValidMagic", {
        get: function () {
            return this.magic == String.fromCharCode(0x7F) + 'ELF';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElfHeader.prototype, "hasValidMachine", {
        get: function () {
            return this.machine == ElfMachine.ALLEGREX;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElfHeader.prototype, "hasValidType", {
        get: function () {
            return [ElfType.Executable, ElfType.Prx].indexOf(this.type) >= 0;
        },
        enumerable: true,
        configurable: true
    });
    ElfHeader.struct = StructClass.create(ElfHeader, [
        { magic: Stringn(4) },
        { class: Int8 },
        { data: Int8 },
        { idVersion: Int8 },
        { _padding: StructArray(Int8, 9) },
        { type: UInt16 },
        { machine: Int16 },
        { version: Int32 },
        { entryPoint: Int32 },
        { programHeaderOffset: Int32 },
        { sectionHeaderOffset: Int32 },
        { flags: Int32 },
        { elfHeaderSize: Int16 },
        { programHeaderEntrySize: Int16 },
        { programHeaderCount: Int16 },
        { sectionHeaderEntrySize: Int16 },
        { sectionHeaderCount: Int16 },
        { sectionHeaderStringTable: Int16 },
    ]);
    return ElfHeader;
})();
exports.ElfHeader = ElfHeader;
var ElfProgramHeader = (function () {
    function ElfProgramHeader() {
    }
    ElfProgramHeader.struct = StructClass.create(ElfProgramHeader, [
        { type: UInt32 },
        { offset: UInt32 },
        { virtualAddress: UInt32 },
        { psysicalAddress: UInt32 },
        { fileSize: UInt32 },
        { memorySize: UInt32 },
        { flags: UInt32 },
        { alignment: UInt32 },
    ]);
    return ElfProgramHeader;
})();
exports.ElfProgramHeader = ElfProgramHeader;
var ElfSectionHeader = (function () {
    function ElfSectionHeader() {
        this.stream = null;
    }
    ElfSectionHeader.struct = StructClass.create(ElfSectionHeader, [
        { nameOffset: UInt32 },
        { type: UInt32 },
        { flags: UInt32 },
        { address: UInt32 },
        { offset: UInt32 },
        { size: UInt32 },
        { link: UInt32 },
        { info: UInt32 },
        { addressAlign: UInt32 },
        { entitySize: UInt32 },
    ]);
    return ElfSectionHeader;
})();
exports.ElfSectionHeader = ElfSectionHeader;
(function (ElfProgramHeaderType) {
    ElfProgramHeaderType[ElfProgramHeaderType["NoLoad"] = 0] = "NoLoad";
    ElfProgramHeaderType[ElfProgramHeaderType["Load"] = 1] = "Load";
    ElfProgramHeaderType[ElfProgramHeaderType["Reloc1"] = 1879048352] = "Reloc1";
    ElfProgramHeaderType[ElfProgramHeaderType["Reloc2"] = 1879048353] = "Reloc2";
})(exports.ElfProgramHeaderType || (exports.ElfProgramHeaderType = {}));
var ElfProgramHeaderType = exports.ElfProgramHeaderType;
(function (ElfSectionHeaderType) {
    ElfSectionHeaderType[ElfSectionHeaderType["Null"] = 0] = "Null";
    ElfSectionHeaderType[ElfSectionHeaderType["ProgramBits"] = 1] = "ProgramBits";
    ElfSectionHeaderType[ElfSectionHeaderType["SYMTAB"] = 2] = "SYMTAB";
    ElfSectionHeaderType[ElfSectionHeaderType["STRTAB"] = 3] = "STRTAB";
    ElfSectionHeaderType[ElfSectionHeaderType["RELA"] = 4] = "RELA";
    ElfSectionHeaderType[ElfSectionHeaderType["HASH"] = 5] = "HASH";
    ElfSectionHeaderType[ElfSectionHeaderType["DYNAMIC"] = 6] = "DYNAMIC";
    ElfSectionHeaderType[ElfSectionHeaderType["NOTE"] = 7] = "NOTE";
    ElfSectionHeaderType[ElfSectionHeaderType["NoBits"] = 8] = "NoBits";
    ElfSectionHeaderType[ElfSectionHeaderType["Relocation"] = 9] = "Relocation";
    ElfSectionHeaderType[ElfSectionHeaderType["SHLIB"] = 10] = "SHLIB";
    ElfSectionHeaderType[ElfSectionHeaderType["DYNSYM"] = 11] = "DYNSYM";
    ElfSectionHeaderType[ElfSectionHeaderType["LOPROC"] = 1879048192] = "LOPROC";
    ElfSectionHeaderType[ElfSectionHeaderType["HIPROC"] = 2147483647] = "HIPROC";
    ElfSectionHeaderType[ElfSectionHeaderType["LOUSER"] = 2147483648] = "LOUSER";
    ElfSectionHeaderType[ElfSectionHeaderType["HIUSER"] = 4294967295] = "HIUSER";
    ElfSectionHeaderType[ElfSectionHeaderType["PrxRelocation"] = 1879048352] = "PrxRelocation";
    ElfSectionHeaderType[ElfSectionHeaderType["PrxRelocation_FW5"] = 1879048353] = "PrxRelocation_FW5";
})(exports.ElfSectionHeaderType || (exports.ElfSectionHeaderType = {}));
var ElfSectionHeaderType = exports.ElfSectionHeaderType;
(function (ElfSectionHeaderFlags) {
    ElfSectionHeaderFlags[ElfSectionHeaderFlags["None"] = 0] = "None";
    ElfSectionHeaderFlags[ElfSectionHeaderFlags["Write"] = 1] = "Write";
    ElfSectionHeaderFlags[ElfSectionHeaderFlags["Allocate"] = 2] = "Allocate";
    ElfSectionHeaderFlags[ElfSectionHeaderFlags["Execute"] = 4] = "Execute";
})(exports.ElfSectionHeaderFlags || (exports.ElfSectionHeaderFlags = {}));
var ElfSectionHeaderFlags = exports.ElfSectionHeaderFlags;
(function (ElfProgramHeaderFlags) {
    ElfProgramHeaderFlags[ElfProgramHeaderFlags["Executable"] = 1] = "Executable";
    ElfProgramHeaderFlags[ElfProgramHeaderFlags["Writable"] = 2] = "Writable";
    ElfProgramHeaderFlags[ElfProgramHeaderFlags["Readable"] = 4] = "Readable";
})(exports.ElfProgramHeaderFlags || (exports.ElfProgramHeaderFlags = {}));
var ElfProgramHeaderFlags = exports.ElfProgramHeaderFlags;
(function (ElfType) {
    ElfType[ElfType["Executable"] = 2] = "Executable";
    ElfType[ElfType["Prx"] = 65440] = "Prx";
})(exports.ElfType || (exports.ElfType = {}));
var ElfType = exports.ElfType;
(function (ElfMachine) {
    ElfMachine[ElfMachine["ALLEGREX"] = 8] = "ALLEGREX";
})(exports.ElfMachine || (exports.ElfMachine = {}));
var ElfMachine = exports.ElfMachine;
(function (ElfPspModuleFlags) {
    ElfPspModuleFlags[ElfPspModuleFlags["User"] = 0] = "User";
    ElfPspModuleFlags[ElfPspModuleFlags["Kernel"] = 4096] = "Kernel";
})(exports.ElfPspModuleFlags || (exports.ElfPspModuleFlags = {}));
var ElfPspModuleFlags = exports.ElfPspModuleFlags;
(function (ElfPspLibFlags) {
    ElfPspLibFlags[ElfPspLibFlags["DirectJump"] = 1] = "DirectJump";
    ElfPspLibFlags[ElfPspLibFlags["Syscall"] = 16384] = "Syscall";
    ElfPspLibFlags[ElfPspLibFlags["SysLib"] = 32768] = "SysLib";
})(exports.ElfPspLibFlags || (exports.ElfPspLibFlags = {}));
var ElfPspLibFlags = exports.ElfPspLibFlags;
(function (ElfPspModuleNids) {
    ElfPspModuleNids[ElfPspModuleNids["MODULE_INFO"] = 4028461991] = "MODULE_INFO";
    ElfPspModuleNids[ElfPspModuleNids["MODULE_BOOTSTART"] = 3547614176] = "MODULE_BOOTSTART";
    ElfPspModuleNids[ElfPspModuleNids["MODULE_REBOOT_BEFORE"] = 788942758] = "MODULE_REBOOT_BEFORE";
    ElfPspModuleNids[ElfPspModuleNids["MODULE_START"] = 3593645275] = "MODULE_START";
    ElfPspModuleNids[ElfPspModuleNids["MODULE_START_THREAD_PARAMETER"] = 259794796] = "MODULE_START_THREAD_PARAMETER";
    ElfPspModuleNids[ElfPspModuleNids["MODULE_STOP"] = 3471333692] = "MODULE_STOP";
    ElfPspModuleNids[ElfPspModuleNids["MODULE_STOP_THREAD_PARAMETER"] = 3473720983] = "MODULE_STOP_THREAD_PARAMETER";
})(exports.ElfPspModuleNids || (exports.ElfPspModuleNids = {}));
var ElfPspModuleNids = exports.ElfPspModuleNids;
(function (ElfRelocType) {
    ElfRelocType[ElfRelocType["None"] = 0] = "None";
    ElfRelocType[ElfRelocType["Mips16"] = 1] = "Mips16";
    ElfRelocType[ElfRelocType["Mips32"] = 2] = "Mips32";
    ElfRelocType[ElfRelocType["MipsRel32"] = 3] = "MipsRel32";
    ElfRelocType[ElfRelocType["Mips26"] = 4] = "Mips26";
    ElfRelocType[ElfRelocType["MipsHi16"] = 5] = "MipsHi16";
    ElfRelocType[ElfRelocType["MipsLo16"] = 6] = "MipsLo16";
    ElfRelocType[ElfRelocType["MipsGpRel16"] = 7] = "MipsGpRel16";
    ElfRelocType[ElfRelocType["MipsLiteral"] = 8] = "MipsLiteral";
    ElfRelocType[ElfRelocType["MipsGot16"] = 9] = "MipsGot16";
    ElfRelocType[ElfRelocType["MipsPc16"] = 10] = "MipsPc16";
    ElfRelocType[ElfRelocType["MipsCall16"] = 11] = "MipsCall16";
    ElfRelocType[ElfRelocType["MipsGpRel32"] = 12] = "MipsGpRel32";
    ElfRelocType[ElfRelocType["StopRelocation"] = 255] = "StopRelocation";
})(exports.ElfRelocType || (exports.ElfRelocType = {}));
var ElfRelocType = exports.ElfRelocType;
var ElfReloc = (function () {
    function ElfReloc() {
    }
    Object.defineProperty(ElfReloc.prototype, "pointeeSectionHeaderBase", {
        get: function () { return (this.info >> 16) & 0xFF; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElfReloc.prototype, "pointerSectionHeaderBase", {
        get: function () { return (this.info >> 8) & 0xFF; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElfReloc.prototype, "type", {
        get: function () { return ((this.info >> 0) & 0xFF); },
        enumerable: true,
        configurable: true
    });
    ElfReloc.struct = StructClass.create(ElfReloc, [
        { pointerAddress: UInt32 },
        { info: UInt32 },
    ]);
    return ElfReloc;
})();
exports.ElfReloc = ElfReloc;
var ElfLoader = (function () {
    function ElfLoader() {
        this.header = null;
        this.stream = null;
    }
    ElfLoader.prototype.load = function (stream) {
        var _this = this;
        this.stream = stream;
        this.readAndCheckHeaders(stream);
        var programHeadersStream = stream.sliceWithLength(this.header.programHeaderOffset, this.header.programHeaderCount * this.header.programHeaderEntrySize);
        var sectionHeadersStream = stream.sliceWithLength(this.header.sectionHeaderOffset, this.header.sectionHeaderCount * this.header.sectionHeaderEntrySize);
        this.programHeaders = StructArray(ElfProgramHeader.struct, this.header.programHeaderCount).read(programHeadersStream);
        this.sectionHeaders = StructArray(ElfSectionHeader.struct, this.header.sectionHeaderCount).read(sectionHeadersStream);
        this.sectionHeaderStringTable = this.sectionHeaders[this.header.sectionHeaderStringTable];
        this.stringTableStream = this.getSectionHeaderFileStream(this.sectionHeaderStringTable);
        this.sectionHeadersByName = {};
        this.sectionHeaders.forEach(function (sectionHeader) {
            var name = _this.getStringFromStringTable(sectionHeader.nameOffset);
            sectionHeader.name = name;
            if (sectionHeader.type != ElfSectionHeaderType.Null) {
                sectionHeader.stream = _this.getSectionHeaderFileStream(sectionHeader);
            }
            _this.sectionHeadersByName[name] = sectionHeader;
        });
        console.log(this.sectionHeadersByName);
    };
    ElfLoader.prototype.readAndCheckHeaders = function (stream) {
        this.stream = stream;
        var header = this.header = ElfHeader.struct.read(stream);
        if (!header.hasValidMagic)
            throw ('Not an ELF file');
        if (!header.hasValidMachine)
            throw ('Not a PSP ELF file');
        if (!header.hasValidType)
            throw ('Not a executable or a Prx but has type ' + header.type);
    };
    ElfLoader.prototype.getStringFromStringTable = function (index) {
        this.stringTableStream.position = index;
        return this.stringTableStream.readStringz();
    };
    ElfLoader.prototype.getSectionHeaderFileStream = function (sectionHeader) {
        switch (sectionHeader.type) {
            case ElfSectionHeaderType.NoBits:
            case ElfSectionHeaderType.Null:
                return this.stream.sliceWithLength(0, 0);
                break;
            default:
                return this.stream.sliceWithLength(sectionHeader.offset, sectionHeader.size);
        }
    };
    ElfLoader.fromStream = function (stream) {
        var elf = new ElfLoader();
        elf.load(stream);
        return elf;
    };
    Object.defineProperty(ElfLoader.prototype, "isPrx", {
        get: function () { return (this.header.type & ElfType.Prx) != 0; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElfLoader.prototype, "needsRelocation", {
        get: function () { return this.isPrx || (this.header.entryPoint < Memory.MAIN_OFFSET); },
        enumerable: true,
        configurable: true
    });
    return ElfLoader;
})();
exports.ElfLoader = ElfLoader;

},
"src/format/elf_dwarf": function(module, exports, require) {
///<reference path="../global.d.ts" />
var console = logger.named('elf.dwarf');
var Uleb128Class = (function () {
    function Uleb128Class() {
    }
    Uleb128Class.prototype.read = function (stream) {
        var val = 0;
        var b = 0x80;
        for (var shift = 0; ((stream.available) > 0 && (b & 0x80)); shift += 7) {
            b = stream.readUInt8();
            val |= (b & 0x7F) << shift;
        }
        return val;
    };
    Uleb128Class.prototype.write = function (stream, value) {
        throw (new Error("Not implemented"));
    };
    Object.defineProperty(Uleb128Class.prototype, "length", {
        get: function () { return 0; },
        enumerable: true,
        configurable: true
    });
    return Uleb128Class;
})();
var Uleb128 = new Uleb128Class();
var ElfDwarfHeader = (function () {
    function ElfDwarfHeader() {
    }
    Object.defineProperty(ElfDwarfHeader.prototype, "total_length_real", {
        get: function () { return this.total_length + 4; },
        enumerable: true,
        configurable: true
    });
    ElfDwarfHeader.struct = StructClass.create(ElfDwarfHeader, [
        { total_length: UInt32 },
        { version: UInt16 },
        { prologue_length: UInt32 },
        { minimum_instruction_length: UInt8 },
        { default_is_stmt: UInt8 },
        { line_base: Int8 },
        { line_range: UInt8 },
        { opcode_base: UInt8 },
    ]);
    return ElfDwarfHeader;
})();
var DW_LNS;
(function (DW_LNS) {
    DW_LNS[DW_LNS["extended_op"] = 0] = "extended_op";
    DW_LNS[DW_LNS["copy"] = 1] = "copy";
    DW_LNS[DW_LNS["advance_pc"] = 2] = "advance_pc";
    DW_LNS[DW_LNS["advance_line"] = 3] = "advance_line";
    DW_LNS[DW_LNS["set_file"] = 4] = "set_file";
    DW_LNS[DW_LNS["set_column"] = 5] = "set_column";
    DW_LNS[DW_LNS["negate_stmt"] = 6] = "negate_stmt";
    DW_LNS[DW_LNS["set_basic_block"] = 7] = "set_basic_block";
    DW_LNS[DW_LNS["const_add_pc"] = 8] = "const_add_pc";
    DW_LNS[DW_LNS["fixed_advance_pc"] = 9] = "fixed_advance_pc";
})(DW_LNS || (DW_LNS = {}));
var DW_LNE;
(function (DW_LNE) {
    DW_LNE[DW_LNE["end_sequence"] = 1] = "end_sequence";
    DW_LNE[DW_LNE["set_address"] = 2] = "set_address";
    DW_LNE[DW_LNE["define_file"] = 3] = "define_file";
})(DW_LNE || (DW_LNE = {}));
var FileEntry = (function () {
    function FileEntry() {
        this.name = '';
        this.directory = '';
        this.directory_index = 0;
        this.time_mod = 0;
        this.size = 0;
    }
    FileEntry.prototype.full_path = function () {
        if (this.directory.length) {
            return this.directory + "/" + this.name;
        }
        else {
            return name;
        }
    };
    FileEntry.struct = StructClass.create(FileEntry, [
        { name: StringzVariable },
        { directory_index: Uleb128 },
        { time_mod: Uleb128 },
        { size: Uleb128 },
    ]);
    return FileEntry;
})();
var ElfSymbol = (function () {
    function ElfSymbol() {
        this.name = '';
        this.index = -1;
        this.nameIndex = 0;
        this.value = 0;
        this.size = 0;
        this.info = 0;
        this.other = 0;
        this.shndx = 0;
    }
    Object.defineProperty(ElfSymbol.prototype, "type", {
        get: function () { return BitUtils.extract(this.info, 0, 4); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElfSymbol.prototype, "bind", {
        get: function () { return BitUtils.extract(this.info, 4, 4); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElfSymbol.prototype, "typeName", {
        get: function () { return SymInfoType[this.type]; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElfSymbol.prototype, "bindName", {
        get: function () { return SymInfoBind[this.bind]; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElfSymbol.prototype, "address", {
        get: function () { return this.value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElfSymbol.prototype, "low", {
        get: function () { return this.value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElfSymbol.prototype, "high", {
        get: function () { return this.value + this.size; },
        enumerable: true,
        configurable: true
    });
    ElfSymbol.prototype.toString = function () {
        return "ElfSymbol(\"" + this.name + "\", " + addressToHex(this.low) + "-" + addressToHex(this.high);
    };
    ElfSymbol.prototype.contains = function (address) {
        return (address >= this.low) && (address < (this.high));
    };
    ElfSymbol.struct = StructClass.create(ElfSymbol, [
        { nameIndex: UInt32 },
        { value: UInt32 },
        { size: UInt32 },
        { info: UInt8 },
        { other: UInt8 },
        { shndx: UInt16 },
    ]);
    return ElfSymbol;
})();
exports.ElfSymbol = ElfSymbol;
(function (SymInfoBind) {
    SymInfoBind[SymInfoBind["LOCAL"] = 0] = "LOCAL";
    SymInfoBind[SymInfoBind["GLOBAL"] = 1] = "GLOBAL";
    SymInfoBind[SymInfoBind["WEAK"] = 2] = "WEAK";
    SymInfoBind[SymInfoBind["OS_1"] = 10] = "OS_1";
    SymInfoBind[SymInfoBind["OS_2"] = 11] = "OS_2";
    SymInfoBind[SymInfoBind["OS_3"] = 12] = "OS_3";
    SymInfoBind[SymInfoBind["PROC_1"] = 13] = "PROC_1";
    SymInfoBind[SymInfoBind["PROC_2"] = 14] = "PROC_2";
    SymInfoBind[SymInfoBind["PROC_3"] = 15] = "PROC_3";
})(exports.SymInfoBind || (exports.SymInfoBind = {}));
var SymInfoBind = exports.SymInfoBind;
(function (SymInfoType) {
    SymInfoType[SymInfoType["NOTYPE"] = 0] = "NOTYPE";
    SymInfoType[SymInfoType["OBJECT"] = 1] = "OBJECT";
    SymInfoType[SymInfoType["FUNC"] = 2] = "FUNC";
    SymInfoType[SymInfoType["SECTION"] = 3] = "SECTION";
    SymInfoType[SymInfoType["FILE"] = 4] = "FILE";
    SymInfoType[SymInfoType["OS_1"] = 10] = "OS_1";
    SymInfoType[SymInfoType["OS_2"] = 11] = "OS_2";
    SymInfoType[SymInfoType["OS_3"] = 12] = "OS_3";
    SymInfoType[SymInfoType["PROC_1"] = 13] = "PROC_1";
    SymInfoType[SymInfoType["PROC_2"] = 14] = "PROC_2";
    SymInfoType[SymInfoType["PROC_3"] = 15] = "PROC_3";
})(exports.SymInfoType || (exports.SymInfoType = {}));
var SymInfoType = exports.SymInfoType;
var ElfDwarfLoader = (function () {
    function ElfDwarfLoader() {
        this.symbolEntries = [];
    }
    ElfDwarfLoader.prototype.parseElfLoader = function (elf) {
        this.parseSymtab(elf);
    };
    ElfDwarfLoader.prototype.parseSymtab = function (elf) {
        console.log('ElfDwarfLoader.parseSymtab');
        var symtabHeader = elf.sectionHeadersByName[".symtab"];
        if (!symtabHeader)
            return;
        var nameSection = elf.sectionHeaders[symtabHeader.link];
        var nameStream = nameSection.stream.sliceWithLength(0);
        var stream = symtabHeader.stream.sliceWithLength(0);
        var n = 0;
        try {
            while (stream.available > 0) {
                var entry = ElfSymbol.struct.read(stream);
                entry.name = nameStream.sliceWithLength(entry.nameIndex).readStringz();
                entry.index = n;
                this.symbolEntries.push(entry);
                n++;
            }
        }
        catch (e) {
            console.warn(e);
        }
        this.symbolEntries.sortBy(function (item) { return item.value; });
    };
    ElfDwarfLoader.prototype.getSymbolAt = function (address) {
        for (var n = 0; n < this.symbolEntries.length; n++) {
            var entry = this.symbolEntries[n];
            if (entry.contains(address))
                return entry;
        }
        return null;
    };
    ElfDwarfLoader.prototype.parseDebugLine = function (elf) {
        console.log('ElfDwarfLoader.parseDebugLine');
        console.log(sectionHeader);
        var sectionHeader = elf.sectionHeadersByName[".debug_line"];
        var stream = sectionHeader.stream.sliceWithLength(0);
        var header = ElfDwarfHeader.struct.read(stream);
        console.log(header);
        var opcodes = StructArray(Uleb128, header.opcode_base).read(stream);
        console.log(opcodes);
        while (stream.available > 0) {
            console.log('item:');
            var item = StringzVariable.read(stream);
            if (!item.length)
                break;
            console.log(item);
        }
        while (stream.available > 0) {
            var entry = FileEntry.struct.read(stream);
            console.log(entry);
            if (!entry.name.length)
                break;
        }
    };
    return ElfDwarfLoader;
})();
exports.ElfDwarfLoader = ElfDwarfLoader;

},
"src/format/format": function(module, exports, require) {
///<reference path="../global.d.ts" />
function detectFormatAsync(asyncStream) {
    return asyncStream.readChunkAsync(0, 4).then(function (data) {
        var stream = Stream.fromArrayBuffer(data);
        if (stream.length < 4) {
            console.error(asyncStream);
            throw (new Error("detectFormatAsync: Buffer is too small (" + data.byteLength + ")"));
        }
        var magic = stream.readString(4);
        switch (magic) {
            case 'PK\u0001\u0002':
            case 'PK\u0003\u0004':
            case 'PK\u0005\u0006':
                return 'zip';
            case '\u0000PBP': return 'pbp';
            case '\u007FELF': return 'elf';
            case '~PSP': return 'psp';
            case 'CISO': return 'ciso';
            case '\u0000\u0000\u0000\u0000':
                return asyncStream.readChunkAsync(0x10 * 0x800, 6).then(function (data) {
                    var stream = Stream.fromArrayBuffer(data);
                    var magic = stream.readString(6);
                    switch (magic) {
                        case '\u0001CD001':
                            return 'iso';
                        default:
                            throw "Unknown format. Magic: '" + magic + "'";
                    }
                });
            default:
                break;
        }
        throw "Unknown format. Magic: '" + magic + "'";
    });
}
exports.detectFormatAsync = detectFormatAsync;

},
"src/format/iso": function(module, exports, require) {
///<reference path="../global.d.ts" />
var SECTOR_SIZE = 0x800;
var DirectoryRecordDate = (function () {
    function DirectoryRecordDate() {
        this.year = 2004;
        this.month = 1;
        this.day = 1;
        this.hour = 0;
        this.minute = 0;
        this.second = 0;
        this.offset = 0;
    }
    Object.defineProperty(DirectoryRecordDate.prototype, "date", {
        get: function () {
            return new Date(this.year, this.month, this.day, this.hour, this.minute, this.second);
        },
        enumerable: true,
        configurable: true
    });
    DirectoryRecordDate.struct = StructClass.create(DirectoryRecordDate, [
        { year: UInt8 },
        { month: UInt8 },
        { day: UInt8 },
        { hour: UInt8 },
        { minute: UInt8 },
        { second: UInt8 },
        { offset: UInt8 },
    ]);
    return DirectoryRecordDate;
})();
var IsoStringDate = (function () {
    function IsoStringDate() {
    }
    Object.defineProperty(IsoStringDate.prototype, "year", {
        get: function () { return parseInt(this.data.substr(0, 4)); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IsoStringDate.prototype, "month", {
        get: function () { return parseInt(this.data.substr(4, 2)); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IsoStringDate.prototype, "day", {
        get: function () { return parseInt(this.data.substr(6, 2)); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IsoStringDate.prototype, "hour", {
        get: function () { return parseInt(this.data.substr(8, 2)); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IsoStringDate.prototype, "minute", {
        get: function () { return parseInt(this.data.substr(10, 2)); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IsoStringDate.prototype, "second", {
        get: function () { return parseInt(this.data.substr(12, 2)); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IsoStringDate.prototype, "hsecond", {
        get: function () { return parseInt(this.data.substr(14, 2)); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IsoStringDate.prototype, "offset", {
        get: function () { return parseInt(this.data.substr(16, 1)); },
        enumerable: true,
        configurable: true
    });
    IsoStringDate.struct = StructClass.create(IsoStringDate, [
        { data: Stringz(17) },
    ]);
    return IsoStringDate;
})();
var VolumeDescriptorHeaderType;
(function (VolumeDescriptorHeaderType) {
    VolumeDescriptorHeaderType[VolumeDescriptorHeaderType["BootRecord"] = 0] = "BootRecord";
    VolumeDescriptorHeaderType[VolumeDescriptorHeaderType["VolumePartitionSetTerminator"] = 255] = "VolumePartitionSetTerminator";
    VolumeDescriptorHeaderType[VolumeDescriptorHeaderType["PrimaryVolumeDescriptor"] = 1] = "PrimaryVolumeDescriptor";
    VolumeDescriptorHeaderType[VolumeDescriptorHeaderType["SupplementaryVolumeDescriptor"] = 2] = "SupplementaryVolumeDescriptor";
    VolumeDescriptorHeaderType[VolumeDescriptorHeaderType["VolumePartitionDescriptor"] = 3] = "VolumePartitionDescriptor";
})(VolumeDescriptorHeaderType || (VolumeDescriptorHeaderType = {}));
var VolumeDescriptorHeader = (function () {
    function VolumeDescriptorHeader() {
    }
    VolumeDescriptorHeader.struct = StructClass.create(VolumeDescriptorHeader, [
        { type: UInt8 },
        { id: Stringz(5) },
        { version: UInt8 },
    ]);
    return VolumeDescriptorHeader;
})();
var DirectoryRecordFlags;
(function (DirectoryRecordFlags) {
    DirectoryRecordFlags[DirectoryRecordFlags["Unknown1"] = 1] = "Unknown1";
    DirectoryRecordFlags[DirectoryRecordFlags["Directory"] = 2] = "Directory";
    DirectoryRecordFlags[DirectoryRecordFlags["Unknown2"] = 4] = "Unknown2";
    DirectoryRecordFlags[DirectoryRecordFlags["Unknown3"] = 8] = "Unknown3";
    DirectoryRecordFlags[DirectoryRecordFlags["Unknown4"] = 16] = "Unknown4";
    DirectoryRecordFlags[DirectoryRecordFlags["Unknown5"] = 32] = "Unknown5";
})(DirectoryRecordFlags || (DirectoryRecordFlags = {}));
var DirectoryRecord = (function () {
    function DirectoryRecord() {
        this.length = 0;
        this.extendedAttributeLength = 0;
        this.extent = 0;
        this.size = 0;
        this.date = new DirectoryRecordDate();
        this.flags = DirectoryRecordFlags.Directory;
        this.fileUnitSize = 0;
        this.interleave = 0;
        this.volumeSequenceNumber = 0;
        this.nameLength = 0;
        this.name = '';
    }
    Object.defineProperty(DirectoryRecord.prototype, "offset", {
        get: function () { return this.extent * SECTOR_SIZE; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectoryRecord.prototype, "isDirectory", {
        get: function () { return (this.flags & DirectoryRecordFlags.Directory) != 0; },
        enumerable: true,
        configurable: true
    });
    DirectoryRecord.struct = StructClass.create(DirectoryRecord, [
        { length: UInt8 },
        { extendedAttributeLength: UInt8 },
        { extent: UInt32_2lb },
        { size: UInt32_2lb },
        { date: DirectoryRecordDate.struct },
        { flags: UInt8 },
        { fileUnitSize: UInt8 },
        { interleave: UInt8 },
        { volumeSequenceNumber: UInt16_2lb },
        { nameLength: UInt8 },
    ]);
    return DirectoryRecord;
})();
var PrimaryVolumeDescriptor = (function () {
    function PrimaryVolumeDescriptor() {
    }
    PrimaryVolumeDescriptor.struct = StructClass.create(PrimaryVolumeDescriptor, [
        { header: VolumeDescriptorHeader.struct },
        { _pad1: UInt8 },
        { systemId: Stringz(0x20) },
        { volumeId: Stringz(0x20) },
        { _pad2: Int64 },
        { volumeSpaceSize: UInt32_2lb },
        { _pad3: StructArray(Int64, 4) },
        { volumeSetSize: UInt32 },
        { volumeSequenceNumber: UInt32 },
        { logicalBlockSize: UInt16_2lb },
        { pathTableSize: UInt32_2lb },
        { typeLPathTable: UInt32 },
        { optType1PathTable: UInt32 },
        { typeMPathTable: UInt32 },
        { optTypeMPathTable: UInt32 },
        { directoryRecord: DirectoryRecord.struct },
        { _pad4: UInt8 },
        { volumeSetId: Stringz(0x80) },
        { publisherId: Stringz(0x80) },
        { preparerId: Stringz(0x80) },
        { applicationId: Stringz(0x80) },
        { copyrightFileId: Stringz(37) },
        { abstractFileId: Stringz(37) },
        { bibliographicFileId: Stringz(37) },
        { creationDate: IsoStringDate.struct },
        { modificationDate: IsoStringDate.struct },
        { expirationDate: IsoStringDate.struct },
        { effectiveDate: IsoStringDate.struct },
        { fileStructureVersion: UInt8 },
        { pad5: UInt8 },
        { pad6: StructArray(UInt8, 0x200) },
        { pad7: StructArray(UInt8, 653) },
    ]);
    return PrimaryVolumeDescriptor;
})();
var IsoNode = (function () {
    function IsoNode(iso, directoryRecord, parent) {
        if (parent === void 0) { parent = null; }
        this.iso = iso;
        this.directoryRecord = directoryRecord;
        this.parent = parent;
        this.childs = [];
        this.childsByName = {};
    }
    Object.defineProperty(IsoNode.prototype, "isRoot", {
        get: function () { return this.parent == null; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IsoNode.prototype, "size", {
        get: function () { return this.directoryRecord.size; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IsoNode.prototype, "path", {
        get: function () { return (this.parent && !this.parent.isRoot) ? (this.parent.path + '/' + this.name) : this.name; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IsoNode.prototype, "name", {
        get: function () { return this.directoryRecord.name; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IsoNode.prototype, "isDirectory", {
        get: function () { return this.directoryRecord.isDirectory; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IsoNode.prototype, "date", {
        get: function () { return this.directoryRecord.date.date; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IsoNode.prototype, "extent", {
        get: function () { return this.directoryRecord.extent; },
        enumerable: true,
        configurable: true
    });
    IsoNode.prototype.readChunkAsync = function (offset, count) {
        var fileBaseLow = this.directoryRecord.offset;
        var low = fileBaseLow + offset;
        var high = Math.min(low + count, fileBaseLow + this.size);
        return this.iso.readChunkAsync(low, high - low);
    };
    IsoNode.prototype.addChild = function (child) {
        this.childs.push(child);
        this.childsByName[child.name] = child;
    };
    IsoNode.prototype.toString = function () {
        return "IsoNode(" + this.path + ", " + this.size + ")";
    };
    return IsoNode;
})();
var Iso = (function () {
    function Iso() {
        this.date = new Date();
    }
    Object.defineProperty(Iso.prototype, "name", {
        get: function () { return this.asyncStream.name; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Iso.prototype, "root", {
        get: function () { return this._root; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Iso.prototype, "childrenByPath", {
        get: function () { return this._childrenByPath; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Iso.prototype, "children", {
        get: function () { return this._children.slice(0); },
        enumerable: true,
        configurable: true
    });
    Iso.fromStreamAsync = function (asyncStream) {
        return new Iso().loadAsync(asyncStream);
    };
    Iso.prototype.get = function (path) {
        path = path.replace(/^\/+/, '');
        var sce_file = path.match(/^sce_lbn(0x[0-9a-f]+|\d+)_size(0x[0-9a-f]+|\d+)$/i);
        if (sce_file) {
            var lba = parseIntFormat(sce_file[1]);
            var size = parseIntFormat(sce_file[2]);
            var dr = new DirectoryRecord();
            dr.extent = lba;
            dr.size = size;
            dr.name = '';
            return new IsoNode(this, dr, null);
        }
        if (path == '')
            return this.root;
        var node = this._childrenByPath[path];
        if (!node) {
            throw (new Error("Can't find node '" + path + "'"));
        }
        return node;
    };
    Object.defineProperty(Iso.prototype, "size", {
        get: function () { return this.asyncStream.size; },
        enumerable: true,
        configurable: true
    });
    Iso.prototype.readChunkAsync = function (offset, count) {
        return this.asyncStream.readChunkAsync(offset, count);
    };
    Iso.prototype.loadAsync = function (asyncStream) {
        var _this = this;
        this.asyncStream = asyncStream;
        this.date = asyncStream.date;
        if (PrimaryVolumeDescriptor.struct.length != SECTOR_SIZE)
            throw "Invalid PrimaryVolumeDescriptor.struct size " + PrimaryVolumeDescriptor.struct.length + " != " + SECTOR_SIZE;
        return asyncStream.readChunkAsync(SECTOR_SIZE * 0x10, 0x800).then(function (arrayBuffer) {
            var stream = Stream.fromArrayBuffer(arrayBuffer);
            var pvd = PrimaryVolumeDescriptor.struct.read(stream);
            if (pvd.header.type != VolumeDescriptorHeaderType.PrimaryVolumeDescriptor)
                throw "Not an ISO file";
            if (pvd.header.id != 'CD001')
                throw "Not an ISO file";
            _this._children = [];
            _this._childrenByPath = {};
            _this._root = new IsoNode(_this, pvd.directoryRecord);
            return _this.processDirectoryRecordAsync(_this._root).then(function () { return _this; });
        });
    };
    Iso.prototype.processDirectoryRecordAsync = function (parentIsoNode) {
        var _this = this;
        var directoryStart = parentIsoNode.directoryRecord.extent * SECTOR_SIZE;
        var directoryLength = parentIsoNode.directoryRecord.size;
        return this.asyncStream.readChunkAsync(directoryStart, directoryLength).then(function (data) {
            var directoryStream = Stream.fromArrayBuffer(data);
            while (directoryStream.available) {
                var directoryRecordSize = directoryStream.readUInt8();
                if (directoryRecordSize == 0) {
                    directoryStream.position = MathUtils.nextAligned(directoryStream.position, SECTOR_SIZE);
                    continue;
                }
                directoryStream.position = directoryStream.position - 1;
                var directoryRecordStream = directoryStream.readStream(directoryRecordSize);
                var directoryRecord = DirectoryRecord.struct.read(directoryRecordStream);
                directoryRecord.name = directoryRecordStream.readStringz(directoryRecordStream.available);
                if (directoryRecord.name == "" || directoryRecord.name == "\x01")
                    continue;
                var child = new IsoNode(_this, directoryRecord, parentIsoNode);
                parentIsoNode.addChild(child);
                _this._children.push(child);
                _this._childrenByPath[child.path] = child;
            }
            var promiseGenerators = [];
            parentIsoNode.childs.forEach(function (child) {
                if (child.isDirectory) {
                    promiseGenerators.push(function () { return _this.processDirectoryRecordAsync(child); });
                }
            });
            return PromiseUtils.sequence(promiseGenerators);
        });
    };
    return Iso;
})();
exports.Iso = Iso;

},
"src/format/pbp": function(module, exports, require) {
///<reference path="../global.d.ts" />
var PbpMagic;
(function (PbpMagic) {
    PbpMagic[PbpMagic["expected"] = 1346523136] = "expected";
})(PbpMagic || (PbpMagic = {}));
var PbpHeader = (function () {
    function PbpHeader() {
    }
    PbpHeader.struct = StructClass.create(PbpHeader, [
        { magic: Int32 },
        { version: Int32 },
        { offsets: StructArray(Int32, 8) },
    ]);
    return PbpHeader;
})();
var Names = (function () {
    function Names() {
    }
    Names.ParamSfo = "param.sfo";
    Names.Icon0Png = "icon0.png";
    Names.Icon1Pmf = "icon1.pmf";
    Names.Pic0Png = "pic0.png";
    Names.Pic1Png = "pic1.png";
    Names.Snd0At3 = "snd0.at3";
    Names.PspData = "psp.data";
    Names.PsarData = "psar.data";
    return Names;
})();
exports.Names = Names;
var Pbp = (function () {
    function Pbp() {
    }
    Pbp.fromStream = function (stream) {
        var pbp = new Pbp();
        pbp.load(stream);
        return pbp;
    };
    Pbp.prototype.load = function (stream) {
        this.stream = stream;
        this.header = PbpHeader.struct.read(stream);
        if (this.header.magic != PbpMagic.expected)
            throw ("Not a PBP file");
        this.header.offsets.push(stream.length);
    };
    Pbp.prototype.get = function (name) {
        var index = Pbp.names.indexOf(name);
        return this.getByIndex(index);
    };
    Pbp.prototype.getByIndex = function (index) {
        var offsets = this.header.offsets;
        return this.stream.sliceWithLowHigh(offsets[index + 0], offsets[index + 1]);
    };
    Pbp.names = [Names.ParamSfo, Names.Icon0Png, Names.Icon1Pmf, Names.Pic0Png, Names.Pic1Png, Names.Snd0At3, Names.PspData, Names.PsarData];
    return Pbp;
})();
exports.Pbp = Pbp;

},
"src/format/psf": function(module, exports, require) {
///<reference path="../global.d.ts" />
var DataType;
(function (DataType) {
    DataType[DataType["Binary"] = 0] = "Binary";
    DataType[DataType["Text"] = 2] = "Text";
    DataType[DataType["Int"] = 4] = "Int";
})(DataType || (DataType = {}));
var HeaderStruct = (function () {
    function HeaderStruct() {
    }
    HeaderStruct.struct = StructClass.create(HeaderStruct, [
        { magic: UInt32 },
        { version: UInt32 },
        { keyTable: UInt32 },
        { valueTable: UInt32 },
        { numberOfPairs: UInt32 },
    ]);
    return HeaderStruct;
})();
var EntryStruct = (function () {
    function EntryStruct() {
    }
    EntryStruct.struct = StructClass.create(EntryStruct, [
        { keyOffset: UInt16 },
        { unknown: UInt8 },
        { dataType: UInt8 },
        { valueSize: UInt32 },
        { valueSizePad: UInt32 },
        { valueOffset: UInt32 },
    ]);
    return EntryStruct;
})();
var Psf = (function () {
    function Psf() {
        this.entries = [];
        this.entriesByName = {};
    }
    Psf.fromStream = function (stream) {
        var psf = new Psf();
        psf.load(stream);
        return psf;
    };
    Psf.prototype.load = function (stream) {
        var header = this.header = HeaderStruct.struct.read(stream);
        if (header.magic != 0x46535000)
            throw ("Not a PSF file");
        var entries = StructArray(EntryStruct.struct, header.numberOfPairs).read(stream);
        var entriesByName = {};
        var keysStream = stream.sliceWithLength(header.keyTable);
        var valuesStream = stream.sliceWithLength(header.valueTable);
        entries.forEach(function (entry) {
            var key = keysStream.sliceWithLength(entry.keyOffset).readUtf8Stringz();
            var valueStream = valuesStream.sliceWithLength(entry.valueOffset, entry.valueSize);
            entry.key = key;
            switch (entry.dataType) {
                case DataType.Binary:
                    entry.value = valueStream.sliceWithLength(0);
                    break;
                case DataType.Int:
                    entry.value = valueStream.readInt32();
                    break;
                case DataType.Text:
                    entry.value = valueStream.readUtf8Stringz();
                    break;
                default: throw "Unknown dataType: " + entry.dataType;
            }
            entriesByName[entry.key] = entry.value;
        });
        this.entries = entries;
        this.entriesByName = entriesByName;
    };
    return Psf;
})();
exports.Psf = Psf;

},
"src/format/riff": function(module, exports, require) {
///<reference path="../global.d.ts" />
var Riff = (function () {
    function Riff() {
        this.handlers = {};
    }
    Riff.prototype.addHandler = function (name, handler) {
        this.handlers[name] = handler;
    };
    Riff.prototype.load = function (stream) {
        if (stream.readString(4) != 'RIFF')
            throw (new Error("Not a riff file"));
        var chunkSize = stream.readInt32();
        var chunkStream = stream.readStream(chunkSize);
        var chunkType = chunkStream.readString(4);
        switch (chunkType) {
            case 'WAVE':
                this.loadWave(chunkStream);
                break;
            default:
                throw (new Error("Don't know how to handle chunk '" + chunkType + "'"));
        }
    };
    Riff.prototype.loadWave = function (stream) {
        while (stream.available > 0) {
            var type = stream.readString(4);
            var length = stream.readInt32();
            var data = stream.readStream(length);
            console.info('subchunk', type, length, data);
            if (this.handlers[type] === undefined)
                throw (new Error("Don't know how to handle subchunk '" + type + "'"));
            (this.handlers[type])(data);
        }
    };
    Riff.fromStreamWithHandlers = function (stream, handlers) {
        var riff = new Riff();
        for (var handlerName in handlers)
            riff.addHandler(handlerName, handlers[handlerName]);
        riff.load(stream);
        return riff;
    };
    return Riff;
})();
exports.Riff = Riff;

},
"src/format/vag": function(module, exports, require) {
///<reference path="../global.d.ts" />
var _audio = require('../core/audio');
var Sample = _audio.Sample;
var VAG_f = [0, 0, 60, 0, 115, -52, 98, -55, 122, -60];
var VagDecoder = (function () {
    function VagDecoder(blockStream, BlockTotalCount) {
        this.blockStream = blockStream;
        this.BlockTotalCount = BlockTotalCount;
        this.decodedBlockSamples = (new Array(VagDecoder.DECOMPRESSED_SAMPLES_IN_BLOCK));
        this.predict1 = 0;
        this.predict2 = 0;
        this.loopStack = [];
        this.currentState = new VagState();
        this.currentLoopCount = 0;
        this.totalLoopCount = 0;
        this.sample = new Sample(0, 0);
        this.reset();
    }
    Object.defineProperty(VagDecoder.prototype, "hasMore", {
        get: function () { return !this.reachedEnd; },
        enumerable: true,
        configurable: true
    });
    VagDecoder.prototype.reset = function () {
        this.currentState = new VagState();
        this.sampleIndexInBlock = 0;
        this.sampleIndexInBlock2 = 0;
        this.reachedEnd = false;
        this.currentLoopCount = 0;
    };
    VagDecoder.prototype.setLoopCount = function (LoopCount) {
        this.currentLoopCount = 0;
        this.totalLoopCount = LoopCount;
    };
    VagDecoder.prototype.seekNextBlock = function () {
        if (this.reachedEnd || this.currentState.blockIndex >= this.BlockTotalCount) {
            this.reachedEnd = true;
            return;
        }
        this.blockStream.position = this.currentState.blockIndex * 16;
        this.currentState.blockIndex++;
        var block = this.blockStream.readBytes(16);
        switch (block[1]) {
            case VagBlockType.LOOP_START:
                var copyState = this.currentState.clone();
                copyState.blockIndex--;
                this.loopStack.push(copyState);
                break;
            case VagBlockType.LOOP_END:
                if (this.currentLoopCount++ < this.totalLoopCount) {
                    this.currentState = this.loopStack.pop();
                }
                else {
                    this.loopStack.pop();
                }
                break;
            case VagBlockType.END:
                this.reachedEnd = true;
                return;
        }
        this.decodeBlock(block);
    };
    VagDecoder.prototype.getNextSample = function () {
        if (this.reachedEnd)
            return this.sample.set(0, 0);
        this.sampleIndexInBlock %= VagDecoder.DECOMPRESSED_SAMPLES_IN_BLOCK;
        if (this.sampleIndexInBlock == 0) {
            this.seekNextBlock();
        }
        if (this.reachedEnd)
            return this.sample.set(0, 0);
        var value = this.decodedBlockSamples[this.sampleIndexInBlock++];
        return this.sample.set(value, value);
    };
    VagDecoder.prototype.decodeBlock = function (block) {
        var sampleOffset = 0;
        var shiftFactor = BitUtils.extract(block[0], 0, 4);
        var predictIndex = BitUtils.extract(block[0], 4, 4) % VAG_f.length;
        this.predict1 = VAG_f[predictIndex * 2 + 0];
        this.predict2 = VAG_f[predictIndex * 2 + 1];
        for (var n = 0; n < VagDecoder.COMPRESSED_BYTES_IN_BLOCK; n++) {
            var dataByte = block[n + 2];
            var v1 = MathUtils.sextend16((((dataByte >>> 0) & 0xF) << 12)) >> shiftFactor;
            var v2 = MathUtils.sextend16((((dataByte >>> 4) & 0xF) << 12)) >> shiftFactor;
            this.decodedBlockSamples[sampleOffset + 0] = this.handleSampleKeepHistory(v1);
            this.decodedBlockSamples[sampleOffset + 1] = this.handleSampleKeepHistory(v2);
            sampleOffset += 2;
        }
    };
    VagDecoder.prototype.handleSampleKeepHistory = function (unpackedSample) {
        var sample = this.handleSample(unpackedSample);
        this.currentState.history2 = this.currentState.history1;
        this.currentState.history1 = sample;
        return sample;
    };
    VagDecoder.prototype.handleSample = function (unpackedSample) {
        var sample = 0;
        sample += unpackedSample * 1;
        sample += ((this.currentState.history1 * this.predict1) / 64) >> 0;
        sample += ((this.currentState.history2 * this.predict2) / 64) >> 0;
        return MathUtils.clamp(sample, -32768, 32767);
    };
    VagDecoder.COMPRESSED_BYTES_IN_BLOCK = 14;
    VagDecoder.DECOMPRESSED_SAMPLES_IN_BLOCK = VagDecoder.COMPRESSED_BYTES_IN_BLOCK * 2;
    return VagDecoder;
})();
var VagBlockType;
(function (VagBlockType) {
    VagBlockType[VagBlockType["LOOP_END"] = 3] = "LOOP_END";
    VagBlockType[VagBlockType["LOOP_START"] = 6] = "LOOP_START";
    VagBlockType[VagBlockType["END"] = 7] = "END";
})(VagBlockType || (VagBlockType = {}));
var VagHeader = (function () {
    function VagHeader() {
    }
    VagHeader.struct = StructClass.create(VagHeader, [
        { magic: UInt32 },
        { vagVersion: UInt32_b },
        { dataSize: UInt32_b },
        { sampleRate: UInt32_b },
    ]);
    return VagHeader;
})();
var VagSoundSource = (function () {
    function VagSoundSource(stream, loopCount) {
        this.header = null;
        this.samplesCount = 0;
        this.decoder = null;
        if (stream.length < 0x10) {
            this.header = null;
            this.samplesCount = 0;
            this.decoder = new VagDecoder(stream, 0);
        }
        else {
            var headerStream = stream.sliceWithLength(0, VagHeader.struct.length);
            var dataStream = stream.sliceWithLength(VagHeader.struct.length);
            this.header = VagHeader.struct.read(headerStream);
            this.samplesCount = Math.floor(dataStream.length * 56 / 16);
            this.decoder = new VagDecoder(dataStream, Math.floor(dataStream.length / 16));
        }
    }
    VagSoundSource.prototype.reset = function () {
        this.decoder.reset();
    };
    Object.defineProperty(VagSoundSource.prototype, "hasMore", {
        get: function () {
            return this.decoder.hasMore;
        },
        enumerable: true,
        configurable: true
    });
    VagSoundSource.prototype.getNextSample = function () {
        return this.decoder.getNextSample();
    };
    return VagSoundSource;
})();
exports.VagSoundSource = VagSoundSource;
var VagState = (function () {
    function VagState(blockIndex, history1, history2) {
        if (blockIndex === void 0) { blockIndex = 0; }
        if (history1 === void 0) { history1 = 0; }
        if (history2 === void 0) { history2 = 0; }
        this.blockIndex = blockIndex;
        this.history1 = history1;
        this.history2 = history2;
    }
    VagState.prototype.clone = function () {
        return new VagState(this.blockIndex, this.history1, this.history2);
    };
    return VagState;
})();

},
"src/format/zip": function(module, exports, require) {
///<reference path="../global.d.ts" />
var ZipEntry = (function () {
    function ZipEntry(zip, name, parent) {
        this.zip = zip;
        this.name = name;
        this.parent = parent;
        this.children = {};
        this.normalizedName = ZipEntry.normalizeString(name);
    }
    Object.defineProperty(ZipEntry.prototype, "size", {
        get: function () {
            return this.uncompressedSize;
        },
        enumerable: true,
        configurable: true
    });
    ZipEntry.prototype.getChildList = function () {
        var list = [];
        for (var key in this.children)
            list.push(this.children[key]);
        return list;
    };
    Object.defineProperty(ZipEntry.prototype, "date", {
        get: function () {
            var dosDate = this.zipDirEntry.dosDate;
            var dosTime = this.zipDirEntry.dosTime;
            var seconds = BitUtils.extract(dosTime, 0, 5) * 2;
            var minutes = BitUtils.extract(dosTime, 5, 6);
            var hours = BitUtils.extract(dosTime, 11, 6);
            var day = BitUtils.extract(dosDate, 0, 5);
            var month = BitUtils.extract(dosDate, 5, 4);
            var year = BitUtils.extract(dosDate, 9, 7) + 1980;
            return new Date(year, month - 1, day, hours, minutes, seconds);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZipEntry.prototype, "compressedSize", {
        get: function () {
            return this.zipDirEntry.compressedSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZipEntry.prototype, "uncompressedSize", {
        get: function () {
            return this.zipDirEntry.uncompressedSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZipEntry.prototype, "compressionType", {
        get: function () {
            return this.zipDirEntry.compType;
        },
        enumerable: true,
        configurable: true
    });
    ZipEntry.normalizeString = function (string) {
        return string.toUpperCase();
    };
    ZipEntry.prototype.readRawCompressedAsync = function () {
        var _this = this;
        if (this.compressedData)
            return Promise2.resolve(this.compressedData);
        return this.zip.zipStream.readChunkAsync(this.zipDirEntry.headerOffset, this.zipDirEntry.compressedSize + 1024).then(function (data) {
            var stream = Stream.fromArrayBuffer(data);
            var zipFileRecord = ZipFileRecord.struct.read(stream);
            return _this.compressedData = stream.readBytes(zipFileRecord.compressedSize);
        });
    };
    ZipEntry.prototype.readChunkAsync = function (offset, length) {
        return this.readAsync().then(function (data) {
            return ArrayBufferUtils.fromUInt8Array(data.subarray(offset, offset + length));
        });
    };
    ZipEntry.prototype.readAsync = function () {
        var _this = this;
        if (this.uncompressedData)
            return Promise2.resolve(this.uncompressedData);
        return this.readRawCompressedAsync().then(function (data) {
            switch (_this.compressionType) {
                case ZipCompressionType.DEFLATE:
                    return inflateRawAsync(data);
                case ZipCompressionType.STORED:
                    return data;
                default:
                    throw (new Error("Unsupported compression type '" + _this.compressionType + "'"));
            }
        }).then(function (data) {
            return _this.uncompressedData = data;
        });
    };
    ZipEntry.prototype.access = function (path, create, fullPath) {
        if (create === void 0) { create = false; }
        if (fullPath === void 0) { fullPath = null; }
        if (fullPath === null)
            fullPath = path;
        if (path == '')
            return this;
        if (path == '.')
            return this;
        if (path == '..')
            return this.parent || this;
        var pathIndex = path.indexOf('/');
        if (pathIndex < 0) {
            var normalizedName = ZipEntry.normalizeString(path);
            var child = this.children[normalizedName];
            if (!child) {
                if (!create) {
                    throw (new Error("ZIP: Can't access to path '" + fullPath + "'"));
                }
                else {
                    child = this.children[normalizedName] = new ZipEntry(this.zip, path, this);
                }
            }
            return child;
        }
        else {
            return this.access(path.substr(0, pathIndex), create, fullPath).access(path.substr(pathIndex + 1), create, fullPath);
        }
    };
    return ZipEntry;
})();
exports.ZipEntry = ZipEntry;
var Zip = (function () {
    function Zip(zipStream, zipDirEntries) {
        var _this = this;
        this.zipStream = zipStream;
        this.zipDirEntries = zipDirEntries;
        this.root = new ZipEntry(this, '', null);
        zipDirEntries.forEach(function (zipDirEntry) {
            var item = _this.root.access(zipDirEntry.fileName, true);
            item.isDirectory = (zipDirEntry.fileName.substr(-1, 1) == '/');
            item.zipDirEntry = zipDirEntry;
        });
    }
    Zip.prototype.get = function (path) {
        return this.root.access(path);
    };
    Zip.prototype.has = function (path) {
        try {
            this.root.access(path);
            return true;
        }
        catch (e) {
            return false;
        }
    };
    Zip.fromStreamAsync = function (zipStream) {
        //console.info('zipStream', zipStream);
        return zipStream.readChunkAsync(zipStream.size - ZipEndLocator.struct.length, ZipEndLocator.struct.length).then(function (data) {
            var zipEndLocator = ZipEndLocator.struct.read(Stream.fromArrayBuffer(data));
            return zipStream.readChunkAsync(zipEndLocator.directoryOffset, zipEndLocator.directorySize).then(function (data) {
                var dirEntries = StructArray(ZipDirEntry.struct, zipEndLocator.entriesInDirectory).read(Stream.fromArrayBuffer(data));
                return new Zip(zipStream, dirEntries);
            });
        });
    };
    return Zip;
})();
exports.Zip = Zip;
(function (ZipCompressionType) {
    ZipCompressionType[ZipCompressionType["STORED"] = 0] = "STORED";
    ZipCompressionType[ZipCompressionType["SHRUNK"] = 1] = "SHRUNK";
    ZipCompressionType[ZipCompressionType["REDUCED1"] = 2] = "REDUCED1";
    ZipCompressionType[ZipCompressionType["REDUCED2"] = 3] = "REDUCED2";
    ZipCompressionType[ZipCompressionType["REDUCED3"] = 4] = "REDUCED3";
    ZipCompressionType[ZipCompressionType["REDUCED4"] = 5] = "REDUCED4";
    ZipCompressionType[ZipCompressionType["IMPLODED"] = 6] = "IMPLODED";
    ZipCompressionType[ZipCompressionType["TOKEN"] = 7] = "TOKEN";
    ZipCompressionType[ZipCompressionType["DEFLATE"] = 8] = "DEFLATE";
    ZipCompressionType[ZipCompressionType["DEFLATE64"] = 9] = "DEFLATE64";
})(exports.ZipCompressionType || (exports.ZipCompressionType = {}));
var ZipCompressionType = exports.ZipCompressionType;
var ZipEndLocator = (function () {
    function ZipEndLocator() {
    }
    ZipEndLocator.struct = StructClass.create(ZipEndLocator, [
        { magic: UInt32 },
        { currentDiskNumber: UInt16 },
        { startDiskNumber: UInt16 },
        { entriesOnDisk: UInt16 },
        { entriesInDirectory: UInt16 },
        { directorySize: UInt32 },
        { directoryOffset: UInt32 },
        { commentLength: UInt16 },
    ]);
    return ZipEndLocator;
})();
exports.ZipEndLocator = ZipEndLocator;
var ZipFileRecord = (function () {
    function ZipFileRecord() {
    }
    ZipFileRecord.struct = StructClass.create(ZipFileRecord, [
        { magic: UInt32 },
        { version: UInt16 },
        { flags: UInt16 },
        { compType: UInt16 },
        { dosTime: UInt16 },
        { dosDate: UInt16 },
        { crc32: UInt32 },
        { compressedSize: UInt32 },
        { uncompressedSize: UInt32 },
        { fileNameLength: UInt16 },
        { extraFieldLength: UInt16 },
        { fileName: StringWithSize(function (context) { return context.fileNameLength; }) },
        { extraField: StringWithSize(function (context) { return context.extraFieldLength; }) },
    ]);
    return ZipFileRecord;
})();
exports.ZipFileRecord = ZipFileRecord;
var ZipDirEntry = (function () {
    function ZipDirEntry() {
    }
    ZipDirEntry.struct = StructClass.create(ZipDirEntry, [
        { magic: UInt32 },
        { versionMadeBy: UInt16 },
        { versionToExtract: UInt16 },
        { flags: UInt16 },
        { compType: UInt16 },
        { dosTime: UInt16 },
        { dosDate: UInt16 },
        { crc32: UInt32 },
        { compressedSize: UInt32 },
        { uncompressedSize: UInt32 },
        { fileNameLength: UInt16 },
        { extraFieldLength: UInt16 },
        { fileCommentsLength: UInt16 },
        { diskNumberStart: UInt16 },
        { internalAttributes: UInt16 },
        { externalAttributes: UInt32 },
        { headerOffset: UInt32 },
        { fileName: StringWithSize(function (context) { return context.fileNameLength; }) },
        { extraField: StringWithSize(function (context) { return context.extraFieldLength; }) },
        { fileComments: StringWithSize(function (context) { return context.fileCommentsLength; }) },
    ]);
    return ZipDirEntry;
})();
exports.ZipDirEntry = ZipDirEntry;

},
"src/format/zlib": function(module, exports, require) {
'use strict';
var exported = {};
var l = exported;
function p(b, e) {
    var a = b.split(".");
    var c = l;
    !(a[0] in c) && c.execScript && c.execScript("var " + a[0]);
    for (var d; a.length && (d = a.shift());)
        !a.length && void 0 !== e ? c[d] = e : c = c[d] ? c[d] : c[d] = {};
}
function t(b) {
    var e = b.length, a = 0, c = Number.POSITIVE_INFINITY, d, f, g, h, k, m, r, n, s, J;
    for (n = 0; n < e; ++n)
        b[n] > a && (a = b[n]), b[n] < c && (c = b[n]);
    d = 1 << a;
    f = new Uint32Array(d);
    g = 1;
    h = 0;
    for (k = 2; g <= a;) {
        for (n = 0; n < e; ++n)
            if (b[n] === g) {
                m = 0;
                r = h;
                for (s = 0; s < g; ++s)
                    m = m << 1 | r & 1, r >>= 1;
                J = g << 16 | n;
                for (s = m; s < d; s += k)
                    f[s] = J;
                ++h;
            }
        ++g;
        h <<= 1;
        k <<= 1;
    }
    return [f, a, c];
}
;
function u(b, e) {
    this.g = [];
    this.h = 32768;
    this.c = this.f = this.d = this.k = 0;
    this.input = new Uint8Array(b);
    this.l = !1;
    this.i = v;
    this.q = !1;
    if (e || !(e = {}))
        e.index && (this.d = e.index), e.bufferSize && (this.h = e.bufferSize), e.bufferType && (this.i = e.bufferType), e.resize && (this.q = e.resize);
    switch (this.i) {
        case w:
            this.a = 32768;
            this.b = new Uint8Array(32768 + this.h + 258);
            break;
        case v:
            this.a = 0;
            this.b = new Uint8Array(this.h);
            this.e = this.v;
            this.m = this.s;
            this.j = this.t;
            break;
        default:
            throw Error("invalid inflate mode");
    }
}
var w = 0, v = 1;
u.prototype.u = function () {
    for (; !this.l;) {
        var b = x(this, 3);
        b & 1 && (this.l = !0);
        b >>>= 1;
        switch (b) {
            case 0:
                var e = this.input, a = this.d, c = this.b, d = this.a, f = e.length, g = void 0, h = void 0, k = c.length, m = void 0;
                this.c = this.f = 0;
                if (a + 1 >= f)
                    throw Error("invalid uncompressed block header: LEN");
                g = e[a++] | e[a++] << 8;
                if (a + 1 >= f)
                    throw Error("invalid uncompressed block header: NLEN");
                h = e[a++] | e[a++] << 8;
                if (g === ~h)
                    throw Error("invalid uncompressed block header: length verify");
                if (a + g > e.length)
                    throw Error("input buffer is broken");
                switch (this.i) {
                    case w:
                        for (; d +
                            g > c.length;) {
                            m = k - d;
                            g -= m;
                            c.set(e.subarray(a, a + m), d), d += m, a += m;
                            this.a = d;
                            c = this.e();
                            d = this.a;
                        }
                        break;
                    case v:
                        for (; d + g > c.length;)
                            c = this.e({
                                o: 2
                            });
                        break;
                    default:
                        throw Error("invalid inflate mode");
                }
                c.set(e.subarray(a, a + g), d), d += g, a += g;
                this.d = a;
                this.a = d;
                this.b = c;
                break;
            case 1:
                this.j(y, z);
                break;
            case 2:
                A(this);
                break;
            default:
                throw Error("unknown BTYPE: " + b);
        }
    }
    return this.m();
};
var B = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], C = new Uint16Array(B), D = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258], E = new Uint16Array(D), F = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0], G = new Uint8Array(F), H = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], I = new Uint16Array(H), K = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13,
    13
], L = new Uint8Array(K), M = new Uint8Array(288), N, O;
N = 0;
for (O = M.length; N < O; ++N)
    M[N] = 143 >= N ? 8 : 255 >= N ? 9 : 279 >= N ? 7 : 8;
var y = t(M), P = new Uint8Array(30), Q, R;
Q = 0;
for (R = P.length; Q < R; ++Q)
    P[Q] = 5;
var z = t(P);
function x(b, e) {
    for (var a = b.f, c = b.c, d = b.input, f = b.d, g = d.length, h; c < e;) {
        if (f >= g)
            throw Error("input buffer is broken");
        a |= d[f++] << c;
        c += 8;
    }
    h = a & (1 << e) - 1;
    b.f = a >>> e;
    b.c = c - e;
    b.d = f;
    return h;
}
function S(b, e) {
    for (var a = b.f, c = b.c, d = b.input, f = b.d, g = d.length, h = e[0], k = e[1], m, r; c < k && !(f >= g);)
        a |= d[f++] << c, c += 8;
    m = h[a & (1 << k) - 1];
    r = m >>> 16;
    b.f = a >> r;
    b.c = c - r;
    b.d = f;
    return m & 65535;
}
function A(b) {
    function e(a, b, c) {
        var e, d = this.p, f, g;
        for (g = 0; g < a;)
            switch (e = S(this, b), e) {
                case 16:
                    for (f = 3 + x(this, 2); f--;)
                        c[g++] = d;
                    break;
                case 17:
                    for (f = 3 + x(this, 3); f--;)
                        c[g++] = 0;
                    d = 0;
                    break;
                case 18:
                    for (f = 11 + x(this, 7); f--;)
                        c[g++] = 0;
                    d = 0;
                    break;
                default:
                    d = c[g++] = e;
            }
        this.p = d;
        return c;
    }
    var a = x(b, 5) + 257, c = x(b, 5) + 1, d = x(b, 4) + 4, f = new Uint8Array(C.length), g, h, k, m;
    for (m = 0; m < d; ++m)
        f[C[m]] = x(b, 3);
    g = t(f);
    h = new Uint8Array(a);
    k = new Uint8Array(c);
    b.p = 0;
    b.j(t(e.call(b, a, g, h)), t(e.call(b, c, g, k)));
}
u.prototype.j = function (b, e) {
    var a = this.b, c = this.a;
    this.n = b;
    for (var d = a.length - 258, f, g, h, k; 256 !== (f = S(this, b));)
        if (256 > f)
            c >= d && (this.a = c, a = this.e(), c = this.a), a[c++] = f;
        else {
            g = f - 257;
            k = E[g];
            0 < G[g] && (k += x(this, G[g]));
            f = S(this, e);
            h = I[f];
            0 < L[f] && (h += x(this, L[f]));
            c >= d && (this.a = c, a = this.e(), c = this.a);
            for (; k--;)
                a[c] = a[c++ - h];
        }
    for (; 8 <= this.c;)
        this.c -= 8, this.d--;
    this.a = c;
};
u.prototype.t = function (b, e) {
    var a = this.b, c = this.a;
    this.n = b;
    for (var d = a.length, f, g, h, k; 256 !== (f = S(this, b));)
        if (256 > f)
            c >= d && (a = this.e(), d = a.length), a[c++] = f;
        else {
            g = f - 257;
            k = E[g];
            0 < G[g] && (k += x(this, G[g]));
            f = S(this, e);
            h = I[f];
            0 < L[f] && (h += x(this, L[f]));
            c + k > d && (a = this.e(), d = a.length);
            for (; k--;)
                a[c] = a[c++ - h];
        }
    for (; 8 <= this.c;)
        this.c -= 8, this.d--;
    this.a = c;
};
u.prototype.e = function () {
    var b = new Uint8Array(this.a - 32768), e = this.a - 32768, a, c, d = this.b;
    b.set(d.subarray(32768, b.length));
    this.g.push(b);
    this.k += b.length;
    d.set(d.subarray(e, e + 32768));
    this.a = 32768;
    return d;
};
u.prototype.v = function (b) {
    var e, a = this.input.length / this.d + 1 | 0, c, d, f, g = this.input, h = this.b;
    b && ("number" === typeof b.o && (a = b.o), "number" === typeof b.r && (a += b.r));
    2 > a ? (c = (g.length - this.d) / this.n[2], f = 258 * (c / 2) | 0, d = f < h.length ? h.length + f : h.length << 1) : d = h.length * a;
    e = new Uint8Array(d);
    e.set(h);
    return this.b = e;
};
u.prototype.m = function () {
    var b = 0, e = this.b, a = this.g, c, d = new Uint8Array(this.k + (this.a - 32768)), f, g, h, k;
    if (0 === a.length)
        return this.b.subarray(32768, this.a);
    f = 0;
    for (g = a.length; f < g; ++f) {
        c = a[f];
        h = 0;
        for (k = c.length; h < k; ++h)
            d[b++] = c[h];
    }
    f = 32768;
    for (g = this.a; f < g; ++f)
        d[b++] = e[f];
    this.g = [];
    return this.buffer = d;
};
u.prototype.s = function () {
    var b, e = this.a;
    true ? this.q ? (b = new Uint8Array(e), b.set(this.b.subarray(0, e))) : b = this.b.subarray(0, e) : (this.b.length > e && (this.b.length = e), b = this.b);
    return this.buffer = b;
};
p("Zlib.RawInflate", u);
p("Zlib.RawInflate.prototype.decompress", u.prototype.u);
var T = {
    ADAPTIVE: v,
    BLOCK: w
}, U, V, W, X;
if (Object.keys)
    U = Object.keys(T);
else
    for (V in U = [], W = 0, T)
        U[W++] = V;
W = 0;
for (X = U.length; W < X; ++W)
    V = U[W], p("Zlib.RawInflate.BufferType." + V, T[V]);
function inflate_raw(data) {
    var clazz = exported.Zlib.RawInflate;
    var inflate = new clazz(data);
    return inflate.decompress();
}
exports.inflate_raw = inflate_raw;
function inflate_raw_arraybuffer(data) {
    return inflate_raw(new Uint8Array(data)).buffer;
}
exports.inflate_raw_arraybuffer = inflate_raw_arraybuffer;

},
"src/hle/SceKernelErrors": function(module, exports, require) {
var SceKernelErrors;
(function (SceKernelErrors) {
    SceKernelErrors[SceKernelErrors["ERROR_OK"] = 0] = "ERROR_OK";
    SceKernelErrors[SceKernelErrors["ERROR_ERROR"] = 2147614721] = "ERROR_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_NOTIMP"] = 2147614722] = "ERROR_NOTIMP";
    SceKernelErrors[SceKernelErrors["ERROR_ALREADY"] = 2147483680] = "ERROR_ALREADY";
    SceKernelErrors[SceKernelErrors["ERROR_BUSY"] = 2147483681] = "ERROR_BUSY";
    SceKernelErrors[SceKernelErrors["ERROR_OUT_OF_MEMORY"] = 2147483682] = "ERROR_OUT_OF_MEMORY";
    SceKernelErrors[SceKernelErrors["ERROR_INVALID_ID"] = 2147483904] = "ERROR_INVALID_ID";
    SceKernelErrors[SceKernelErrors["ERROR_INVALID_NAME"] = 2147483905] = "ERROR_INVALID_NAME";
    SceKernelErrors[SceKernelErrors["ERROR_INVALID_INDEX"] = 2147483906] = "ERROR_INVALID_INDEX";
    SceKernelErrors[SceKernelErrors["ERROR_INVALID_POINTER"] = 2147483907] = "ERROR_INVALID_POINTER";
    SceKernelErrors[SceKernelErrors["ERROR_INVALID_SIZE"] = 2147483908] = "ERROR_INVALID_SIZE";
    SceKernelErrors[SceKernelErrors["ERROR_INVALID_FLAG"] = 2147483909] = "ERROR_INVALID_FLAG";
    SceKernelErrors[SceKernelErrors["ERROR_INVALID_COMMAND"] = 2147483910] = "ERROR_INVALID_COMMAND";
    SceKernelErrors[SceKernelErrors["ERROR_INVALID_MODE"] = 2147483911] = "ERROR_INVALID_MODE";
    SceKernelErrors[SceKernelErrors["ERROR_INVALID_FORMAT"] = 2147483912] = "ERROR_INVALID_FORMAT";
    SceKernelErrors[SceKernelErrors["ERROR_INVALID_VALUE"] = 2147484158] = "ERROR_INVALID_VALUE";
    SceKernelErrors[SceKernelErrors["ERROR_INVALID_ARGUMENT"] = 2147484159] = "ERROR_INVALID_ARGUMENT";
    SceKernelErrors[SceKernelErrors["ERROR_BAD_FILE"] = 2147484169] = "ERROR_BAD_FILE";
    SceKernelErrors[SceKernelErrors["ERROR_ACCESS_ERROR"] = 2147484173] = "ERROR_ACCESS_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_OPERATION_NOT_PERMITTED"] = 2147549185] = "ERROR_ERRNO_OPERATION_NOT_PERMITTED";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_FILE_NOT_FOUND"] = 2147549186] = "ERROR_ERRNO_FILE_NOT_FOUND";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_FILE_OPEN_ERROR"] = 2147549187] = "ERROR_ERRNO_FILE_OPEN_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_IO_ERROR"] = 2147549189] = "ERROR_ERRNO_IO_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_ARG_LIST_TOO_LONG"] = 2147549191] = "ERROR_ERRNO_ARG_LIST_TOO_LONG";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_INVALID_FILE_DESCRIPTOR"] = 2147549193] = "ERROR_ERRNO_INVALID_FILE_DESCRIPTOR";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_RESOURCE_UNAVAILABLE"] = 2147549195] = "ERROR_ERRNO_RESOURCE_UNAVAILABLE";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_NO_MEMORY"] = 2147549196] = "ERROR_ERRNO_NO_MEMORY";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_NO_PERM"] = 2147549197] = "ERROR_ERRNO_NO_PERM";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_FILE_INVALID_ADDR"] = 2147549198] = "ERROR_ERRNO_FILE_INVALID_ADDR";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_DEVICE_BUSY"] = 2147549200] = "ERROR_ERRNO_DEVICE_BUSY";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_FILE_ALREADY_EXISTS"] = 2147549201] = "ERROR_ERRNO_FILE_ALREADY_EXISTS";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_CROSS_DEV_LINK"] = 2147549202] = "ERROR_ERRNO_CROSS_DEV_LINK";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_DEVICE_NOT_FOUND"] = 2147549203] = "ERROR_ERRNO_DEVICE_NOT_FOUND";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_NOT_A_DIRECTORY"] = 2147549204] = "ERROR_ERRNO_NOT_A_DIRECTORY";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_IS_DIRECTORY"] = 2147549205] = "ERROR_ERRNO_IS_DIRECTORY";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_INVALID_ARGUMENT"] = 2147549206] = "ERROR_ERRNO_INVALID_ARGUMENT";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_TOO_MANY_OPEN_SYSTEM_FILES"] = 2147549208] = "ERROR_ERRNO_TOO_MANY_OPEN_SYSTEM_FILES";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_FILE_IS_TOO_BIG"] = 2147549211] = "ERROR_ERRNO_FILE_IS_TOO_BIG";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_DEVICE_NO_FREE_SPACE"] = 2147549212] = "ERROR_ERRNO_DEVICE_NO_FREE_SPACE";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_READ_ONLY"] = 2147549214] = "ERROR_ERRNO_READ_ONLY";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_CLOSED"] = 2147549216] = "ERROR_ERRNO_CLOSED";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_FILE_PATH_TOO_LONG"] = 2147549220] = "ERROR_ERRNO_FILE_PATH_TOO_LONG";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_FILE_PROTOCOL"] = 2147549255] = "ERROR_ERRNO_FILE_PROTOCOL";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_DIRECTORY_IS_NOT_EMPTY"] = 2147549274] = "ERROR_ERRNO_DIRECTORY_IS_NOT_EMPTY";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_TOO_MANY_SYMBOLIC_LINKS"] = 2147549276] = "ERROR_ERRNO_TOO_MANY_SYMBOLIC_LINKS";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_FILE_ADDR_IN_USE"] = 2147549282] = "ERROR_ERRNO_FILE_ADDR_IN_USE";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_CONNECTION_ABORTED"] = 2147549287] = "ERROR_ERRNO_CONNECTION_ABORTED";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_CONNECTION_RESET"] = 2147549288] = "ERROR_ERRNO_CONNECTION_RESET";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_NO_FREE_BUF_SPACE"] = 2147549289] = "ERROR_ERRNO_NO_FREE_BUF_SPACE";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_FILE_TIMEOUT"] = 2147549294] = "ERROR_ERRNO_FILE_TIMEOUT";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_IN_PROGRESS"] = 2147549303] = "ERROR_ERRNO_IN_PROGRESS";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_ALREADY"] = 2147549304] = "ERROR_ERRNO_ALREADY";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_NO_MEDIA"] = 2147549307] = "ERROR_ERRNO_NO_MEDIA";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_INVALID_MEDIUM"] = 2147549308] = "ERROR_ERRNO_INVALID_MEDIUM";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_ADDRESS_NOT_AVAILABLE"] = 2147549309] = "ERROR_ERRNO_ADDRESS_NOT_AVAILABLE";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_IS_ALREADY_CONNECTED"] = 2147549311] = "ERROR_ERRNO_IS_ALREADY_CONNECTED";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_NOT_CONNECTED"] = 2147549312] = "ERROR_ERRNO_NOT_CONNECTED";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_FILE_QUOTA_EXCEEDED"] = 2147549316] = "ERROR_ERRNO_FILE_QUOTA_EXCEEDED";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_FUNCTION_NOT_SUPPORTED"] = 2147594240] = "ERROR_ERRNO_FUNCTION_NOT_SUPPORTED";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_ADDR_OUT_OF_MAIN_MEM"] = 2147594241] = "ERROR_ERRNO_ADDR_OUT_OF_MAIN_MEM";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_INVALID_UNIT_NUM"] = 2147594242] = "ERROR_ERRNO_INVALID_UNIT_NUM";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_INVALID_FILE_SIZE"] = 2147594243] = "ERROR_ERRNO_INVALID_FILE_SIZE";
    SceKernelErrors[SceKernelErrors["ERROR_ERRNO_INVALID_FLAG"] = 2147594244] = "ERROR_ERRNO_INVALID_FLAG";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_CANNOT_BE_CALLED_FROM_INTERRUPT"] = 2147614820] = "ERROR_KERNEL_CANNOT_BE_CALLED_FROM_INTERRUPT";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_INTERRUPTS_ALREADY_DISABLED"] = 2147614822] = "ERROR_KERNEL_INTERRUPTS_ALREADY_DISABLED";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_UNKNOWN_UID"] = 2147614923] = "ERROR_KERNEL_UNKNOWN_UID";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_UNMATCH_TYPE_UID"] = 2147614924] = "ERROR_KERNEL_UNMATCH_TYPE_UID";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NOT_EXIST_ID"] = 2147614925] = "ERROR_KERNEL_NOT_EXIST_ID";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NOT_FOUND_FUNCTION_UID"] = 2147614926] = "ERROR_KERNEL_NOT_FOUND_FUNCTION_UID";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ALREADY_HOLDER_UID"] = 2147614927] = "ERROR_KERNEL_ALREADY_HOLDER_UID";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NOT_HOLDER_UID"] = 2147614928] = "ERROR_KERNEL_NOT_HOLDER_UID";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_PERMISSION"] = 2147614929] = "ERROR_KERNEL_ILLEGAL_PERMISSION";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_ARGUMENT"] = 2147614930] = "ERROR_KERNEL_ILLEGAL_ARGUMENT";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_ADDR"] = 2147614931] = "ERROR_KERNEL_ILLEGAL_ADDR";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MEMORY_AREA_OUT_OF_RANGE"] = 2147614932] = "ERROR_KERNEL_MEMORY_AREA_OUT_OF_RANGE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MEMORY_AREA_IS_OVERLAP"] = 2147614933] = "ERROR_KERNEL_MEMORY_AREA_IS_OVERLAP";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_PARTITION_ID"] = 2147614934] = "ERROR_KERNEL_ILLEGAL_PARTITION_ID";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_PARTITION_IN_USE"] = 2147614935] = "ERROR_KERNEL_PARTITION_IN_USE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_MEMBLOCK_ALLOC_TYPE"] = 2147614936] = "ERROR_KERNEL_ILLEGAL_MEMBLOCK_ALLOC_TYPE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_FAILED_ALLOC_MEMBLOCK"] = 2147614937] = "ERROR_KERNEL_FAILED_ALLOC_MEMBLOCK";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_INHIBITED_RESIZE_MEMBLOCK"] = 2147614938] = "ERROR_KERNEL_INHIBITED_RESIZE_MEMBLOCK";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_FAILED_RESIZE_MEMBLOCK"] = 2147614939] = "ERROR_KERNEL_FAILED_RESIZE_MEMBLOCK";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_FAILED_ALLOC_HEAPBLOCK"] = 2147614940] = "ERROR_KERNEL_FAILED_ALLOC_HEAPBLOCK";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_FAILED_ALLOC_HEAP"] = 2147614941] = "ERROR_KERNEL_FAILED_ALLOC_HEAP";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_CHUNK_ID"] = 2147614942] = "ERROR_KERNEL_ILLEGAL_CHUNK_ID";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_CANNOT_FIND_CHUNK_NAME"] = 2147614943] = "ERROR_KERNEL_CANNOT_FIND_CHUNK_NAME";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NO_FREE_CHUNK"] = 2147614944] = "ERROR_KERNEL_NO_FREE_CHUNK";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MEMBLOCK_FRAGMENTED"] = 2147614945] = "ERROR_KERNEL_MEMBLOCK_FRAGMENTED";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MEMBLOCK_CANNOT_JOINT"] = 2147614946] = "ERROR_KERNEL_MEMBLOCK_CANNOT_JOINT";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MEMBLOCK_CANNOT_SEPARATE"] = 2147614947] = "ERROR_KERNEL_MEMBLOCK_CANNOT_SEPARATE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_ALIGNMENT_SIZE"] = 2147614948] = "ERROR_KERNEL_ILLEGAL_ALIGNMENT_SIZE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_DEVKIT_VER"] = 2147614949] = "ERROR_KERNEL_ILLEGAL_DEVKIT_VER";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MODULE_LINK_ERROR"] = 2147615020] = "ERROR_KERNEL_MODULE_LINK_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_OBJECT_FORMAT"] = 2147615021] = "ERROR_KERNEL_ILLEGAL_OBJECT_FORMAT";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_UNKNOWN_MODULE"] = 2147615022] = "ERROR_KERNEL_UNKNOWN_MODULE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_UNKNOWN_MODULE_FILE"] = 2147615023] = "ERROR_KERNEL_UNKNOWN_MODULE_FILE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_FILE_READ_ERROR"] = 2147615024] = "ERROR_KERNEL_FILE_READ_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MEMORY_IN_USE"] = 2147615025] = "ERROR_KERNEL_MEMORY_IN_USE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_PARTITION_MISMATCH"] = 2147615026] = "ERROR_KERNEL_PARTITION_MISMATCH";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MODULE_ALREADY_STARTED"] = 2147615027] = "ERROR_KERNEL_MODULE_ALREADY_STARTED";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MODULE_NOT_STARTED"] = 2147615028] = "ERROR_KERNEL_MODULE_NOT_STARTED";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MODULE_ALREADY_STOPPED"] = 2147615029] = "ERROR_KERNEL_MODULE_ALREADY_STOPPED";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MODULE_CANNOT_STOP"] = 2147615030] = "ERROR_KERNEL_MODULE_CANNOT_STOP";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MODULE_NOT_STOPPED"] = 2147615031] = "ERROR_KERNEL_MODULE_NOT_STOPPED";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MODULE_CANNOT_REMOVE"] = 2147615032] = "ERROR_KERNEL_MODULE_CANNOT_REMOVE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_EXCLUSIVE_LOAD"] = 2147615033] = "ERROR_KERNEL_EXCLUSIVE_LOAD";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_LIBRARY_IS_NOT_LINKED"] = 2147615034] = "ERROR_KERNEL_LIBRARY_IS_NOT_LINKED";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_LIBRARY_ALREADY_EXISTS"] = 2147615035] = "ERROR_KERNEL_LIBRARY_ALREADY_EXISTS";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_LIBRARY_NOT_FOUND"] = 2147615036] = "ERROR_KERNEL_LIBRARY_NOT_FOUND";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_LIBRARY_HEADER"] = 2147615037] = "ERROR_KERNEL_ILLEGAL_LIBRARY_HEADER";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_LIBRARY_IN_USE"] = 2147615038] = "ERROR_KERNEL_LIBRARY_IN_USE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MODULE_ALREADY_STOPPING"] = 2147615039] = "ERROR_KERNEL_MODULE_ALREADY_STOPPING";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_OFFSET_VALUE"] = 2147615040] = "ERROR_KERNEL_ILLEGAL_OFFSET_VALUE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_POSITION_CODE"] = 2147615041] = "ERROR_KERNEL_ILLEGAL_POSITION_CODE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_ACCESS_CODE"] = 2147615042] = "ERROR_KERNEL_ILLEGAL_ACCESS_CODE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MODULE_MANAGER_BUSY"] = 2147615043] = "ERROR_KERNEL_MODULE_MANAGER_BUSY";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_FLAG"] = 2147615044] = "ERROR_KERNEL_ILLEGAL_FLAG";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_CANNOT_GET_MODULE_LIST"] = 2147615045] = "ERROR_KERNEL_CANNOT_GET_MODULE_LIST";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_PROHIBIT_LOADMODULE_DEVICE"] = 2147615046] = "ERROR_KERNEL_PROHIBIT_LOADMODULE_DEVICE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_PROHIBIT_LOADEXEC_DEVICE"] = 2147615047] = "ERROR_KERNEL_PROHIBIT_LOADEXEC_DEVICE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_UNSUPPORTED_PRX_TYPE"] = 2147615048] = "ERROR_KERNEL_UNSUPPORTED_PRX_TYPE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_PERMISSION_CALL"] = 2147615049] = "ERROR_KERNEL_ILLEGAL_PERMISSION_CALL";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_CANNOT_GET_MODULE_INFO"] = 2147615050] = "ERROR_KERNEL_CANNOT_GET_MODULE_INFO";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_LOADEXEC_BUFFER"] = 2147615051] = "ERROR_KERNEL_ILLEGAL_LOADEXEC_BUFFER";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_LOADEXEC_FILENAME"] = 2147615052] = "ERROR_KERNEL_ILLEGAL_LOADEXEC_FILENAME";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NO_EXIT_CALLBACK"] = 2147615053] = "ERROR_KERNEL_NO_EXIT_CALLBACK";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MEDIA_CHANGED"] = 2147615054] = "ERROR_KERNEL_MEDIA_CHANGED";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_CANNOT_USE_BETA_VER_MODULE"] = 2147615055] = "ERROR_KERNEL_CANNOT_USE_BETA_VER_MODULE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NO_MEMORY"] = 2147615120] = "ERROR_KERNEL_NO_MEMORY";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_ATTR"] = 2147615121] = "ERROR_KERNEL_ILLEGAL_ATTR";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_THREAD_ENTRY_ADDR"] = 2147615122] = "ERROR_KERNEL_ILLEGAL_THREAD_ENTRY_ADDR";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_PRIORITY"] = 2147615123] = "ERROR_KERNEL_ILLEGAL_PRIORITY";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_STACK_SIZE"] = 2147615124] = "ERROR_KERNEL_ILLEGAL_STACK_SIZE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_MODE"] = 2147615125] = "ERROR_KERNEL_ILLEGAL_MODE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_MASK"] = 2147615126] = "ERROR_KERNEL_ILLEGAL_MASK";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_THREAD"] = 2147615127] = "ERROR_KERNEL_ILLEGAL_THREAD";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NOT_FOUND_THREAD"] = 2147615128] = "ERROR_KERNEL_NOT_FOUND_THREAD";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NOT_FOUND_SEMAPHORE"] = 2147615129] = "ERROR_KERNEL_NOT_FOUND_SEMAPHORE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NOT_FOUND_EVENT_FLAG"] = 2147615130] = "ERROR_KERNEL_NOT_FOUND_EVENT_FLAG";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NOT_FOUND_MESSAGE_BOX"] = 2147615131] = "ERROR_KERNEL_NOT_FOUND_MESSAGE_BOX";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NOT_FOUND_VPOOL"] = 2147615132] = "ERROR_KERNEL_NOT_FOUND_VPOOL";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NOT_FOUND_FPOOL"] = 2147615133] = "ERROR_KERNEL_NOT_FOUND_FPOOL";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NOT_FOUND_MESSAGE_PIPE"] = 2147615134] = "ERROR_KERNEL_NOT_FOUND_MESSAGE_PIPE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NOT_FOUND_ALARM"] = 2147615135] = "ERROR_KERNEL_NOT_FOUND_ALARM";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NOT_FOUND_THREAD_EVENT_HANDLER"] = 2147615136] = "ERROR_KERNEL_NOT_FOUND_THREAD_EVENT_HANDLER";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NOT_FOUND_CALLBACK"] = 2147615137] = "ERROR_KERNEL_NOT_FOUND_CALLBACK";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_THREAD_ALREADY_DORMANT"] = 2147615138] = "ERROR_KERNEL_THREAD_ALREADY_DORMANT";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_THREAD_ALREADY_SUSPEND"] = 2147615139] = "ERROR_KERNEL_THREAD_ALREADY_SUSPEND";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_THREAD_IS_NOT_DORMANT"] = 2147615140] = "ERROR_KERNEL_THREAD_IS_NOT_DORMANT";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_THREAD_IS_NOT_SUSPEND"] = 2147615141] = "ERROR_KERNEL_THREAD_IS_NOT_SUSPEND";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_THREAD_IS_NOT_WAIT"] = 2147615142] = "ERROR_KERNEL_THREAD_IS_NOT_WAIT";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_WAIT_CAN_NOT_WAIT"] = 2147615143] = "ERROR_KERNEL_WAIT_CAN_NOT_WAIT";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_WAIT_TIMEOUT"] = 2147615144] = "ERROR_KERNEL_WAIT_TIMEOUT";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_WAIT_CANCELLED"] = 2147615145] = "ERROR_KERNEL_WAIT_CANCELLED";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_WAIT_STATUS_RELEASED"] = 2147615146] = "ERROR_KERNEL_WAIT_STATUS_RELEASED";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_WAIT_STATUS_RELEASED_CALLBACK"] = 2147615147] = "ERROR_KERNEL_WAIT_STATUS_RELEASED_CALLBACK";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_THREAD_IS_TERMINATED"] = 2147615148] = "ERROR_KERNEL_THREAD_IS_TERMINATED";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_SEMA_ZERO"] = 2147615149] = "ERROR_KERNEL_SEMA_ZERO";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_SEMA_OVERFLOW"] = 2147615150] = "ERROR_KERNEL_SEMA_OVERFLOW";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_EVENT_FLAG_POLL_FAILED"] = 2147615151] = "ERROR_KERNEL_EVENT_FLAG_POLL_FAILED";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_EVENT_FLAG_NO_MULTI_PERM"] = 2147615152] = "ERROR_KERNEL_EVENT_FLAG_NO_MULTI_PERM";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_EVENT_FLAG_ILLEGAL_WAIT_PATTERN"] = 2147615153] = "ERROR_KERNEL_EVENT_FLAG_ILLEGAL_WAIT_PATTERN";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MESSAGEBOX_NO_MESSAGE"] = 2147615154] = "ERROR_KERNEL_MESSAGEBOX_NO_MESSAGE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MESSAGE_PIPE_FULL"] = 2147615155] = "ERROR_KERNEL_MESSAGE_PIPE_FULL";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MESSAGE_PIPE_EMPTY"] = 2147615156] = "ERROR_KERNEL_MESSAGE_PIPE_EMPTY";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_WAIT_DELETE"] = 2147615157] = "ERROR_KERNEL_WAIT_DELETE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_MEMBLOCK"] = 2147615158] = "ERROR_KERNEL_ILLEGAL_MEMBLOCK";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_MEMSIZE"] = 2147615159] = "ERROR_KERNEL_ILLEGAL_MEMSIZE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_SCRATCHPAD_ADDR"] = 2147615160] = "ERROR_KERNEL_ILLEGAL_SCRATCHPAD_ADDR";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_SCRATCHPAD_IN_USE"] = 2147615161] = "ERROR_KERNEL_SCRATCHPAD_IN_USE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_SCRATCHPAD_NOT_IN_USE"] = 2147615162] = "ERROR_KERNEL_SCRATCHPAD_NOT_IN_USE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_TYPE"] = 2147615163] = "ERROR_KERNEL_ILLEGAL_TYPE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_SIZE"] = 2147615164] = "ERROR_KERNEL_ILLEGAL_SIZE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_COUNT"] = 2147615165] = "ERROR_KERNEL_ILLEGAL_COUNT";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NOT_FOUND_VTIMER"] = 2147615166] = "ERROR_KERNEL_NOT_FOUND_VTIMER";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_VTIMER"] = 2147615167] = "ERROR_KERNEL_ILLEGAL_VTIMER";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ILLEGAL_KTLS"] = 2147615168] = "ERROR_KERNEL_ILLEGAL_KTLS";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_KTLS_IS_FULL"] = 2147615169] = "ERROR_KERNEL_KTLS_IS_FULL";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_KTLS_IS_BUSY"] = 2147615170] = "ERROR_KERNEL_KTLS_IS_BUSY";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MUTEX_NOT_FOUND"] = 2147615171] = "ERROR_KERNEL_MUTEX_NOT_FOUND";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MUTEX_LOCKED"] = 2147615172] = "ERROR_KERNEL_MUTEX_LOCKED";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MUTEX_UNLOCKED"] = 2147615173] = "ERROR_KERNEL_MUTEX_UNLOCKED";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MUTEX_LOCK_OVERFLOW"] = 2147615174] = "ERROR_KERNEL_MUTEX_LOCK_OVERFLOW";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MUTEX_UNLOCK_UNDERFLOW"] = 2147615175] = "ERROR_KERNEL_MUTEX_UNLOCK_UNDERFLOW";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MUTEX_RECURSIVE_NOT_ALLOWED"] = 2147615176] = "ERROR_KERNEL_MUTEX_RECURSIVE_NOT_ALLOWED";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MESSAGEBOX_DUPLICATE_MESSAGE"] = 2147615177] = "ERROR_KERNEL_MESSAGEBOX_DUPLICATE_MESSAGE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_LWMUTEX_NOT_FOUND"] = 2147615178] = "ERROR_KERNEL_LWMUTEX_NOT_FOUND";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_LWMUTEX_LOCKED"] = 2147615179] = "ERROR_KERNEL_LWMUTEX_LOCKED";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_LWMUTEX_UNLOCKED"] = 2147615180] = "ERROR_KERNEL_LWMUTEX_UNLOCKED";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_LWMUTEX_LOCK_OVERFLOW"] = 2147615181] = "ERROR_KERNEL_LWMUTEX_LOCK_OVERFLOW";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_LWMUTEX_UNLOCK_UNDERFLOW"] = 2147615182] = "ERROR_KERNEL_LWMUTEX_UNLOCK_UNDERFLOW";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_LWMUTEX_RECURSIVE_NOT_ALLOWED"] = 2147615183] = "ERROR_KERNEL_LWMUTEX_RECURSIVE_NOT_ALLOWED";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_POWER_CANNOT_CANCEL"] = 2147615329] = "ERROR_KERNEL_POWER_CANNOT_CANCEL";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_TOO_MANY_OPEN_FILES"] = 2147615520] = "ERROR_KERNEL_TOO_MANY_OPEN_FILES";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NO_SUCH_DEVICE"] = 2147615521] = "ERROR_KERNEL_NO_SUCH_DEVICE";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_BAD_FILE_DESCRIPTOR"] = 2147615523] = "ERROR_KERNEL_BAD_FILE_DESCRIPTOR";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_UNSUPPORTED_OPERATION"] = 2147615525] = "ERROR_KERNEL_UNSUPPORTED_OPERATION";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NOCWD"] = 2147615532] = "ERROR_KERNEL_NOCWD";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_FILENAME_TOO_LONG"] = 2147615533] = "ERROR_KERNEL_FILENAME_TOO_LONG";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_ASYNC_BUSY"] = 2147615529] = "ERROR_KERNEL_ASYNC_BUSY";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NO_ASYNC_OP"] = 2147615530] = "ERROR_KERNEL_NO_ASYNC_OP";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_NOT_CACHE_ALIGNED"] = 2147615820] = "ERROR_KERNEL_NOT_CACHE_ALIGNED";
    SceKernelErrors[SceKernelErrors["ERROR_KERNEL_MAX_ERROR"] = 2147615821] = "ERROR_KERNEL_MAX_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_UTILITY_INVALID_STATUS"] = 2148597761] = "ERROR_UTILITY_INVALID_STATUS";
    SceKernelErrors[SceKernelErrors["ERROR_UTILITY_INVALID_PARAM_ADDR"] = 2148597762] = "ERROR_UTILITY_INVALID_PARAM_ADDR";
    SceKernelErrors[SceKernelErrors["ERROR_UTILITY_IS_UNKNOWN"] = 2148597763] = "ERROR_UTILITY_IS_UNKNOWN";
    SceKernelErrors[SceKernelErrors["ERROR_UTILITY_INVALID_PARAM_SIZE"] = 2148597764] = "ERROR_UTILITY_INVALID_PARAM_SIZE";
    SceKernelErrors[SceKernelErrors["ERROR_UTILITY_WRONG_TYPE"] = 2148597765] = "ERROR_UTILITY_WRONG_TYPE";
    SceKernelErrors[SceKernelErrors["ERROR_UTILITY_MODULE_NOT_FOUND"] = 2148597766] = "ERROR_UTILITY_MODULE_NOT_FOUND";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_LOAD_NO_MEMSTICK"] = 2148598529] = "ERROR_SAVEDATA_LOAD_NO_MEMSTICK";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_LOAD_MEMSTICK_REMOVED"] = 2148598530] = "ERROR_SAVEDATA_LOAD_MEMSTICK_REMOVED";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_LOAD_ACCESS_ERROR"] = 2148598533] = "ERROR_SAVEDATA_LOAD_ACCESS_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_LOAD_DATA_BROKEN"] = 2148598534] = "ERROR_SAVEDATA_LOAD_DATA_BROKEN";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_LOAD_NO_DATA"] = 2148598535] = "ERROR_SAVEDATA_LOAD_NO_DATA";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_LOAD_BAD_PARAMS"] = 2148598536] = "ERROR_SAVEDATA_LOAD_BAD_PARAMS";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_LOAD_NO_UMD"] = 2148598537] = "ERROR_SAVEDATA_LOAD_NO_UMD";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_LOAD_INTERNAL_ERROR"] = 2148598537] = "ERROR_SAVEDATA_LOAD_INTERNAL_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_RW_NO_MEMSTICK"] = 2148598561] = "ERROR_SAVEDATA_RW_NO_MEMSTICK";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_RW_MEMSTICK_REMOVED"] = 2148598562] = "ERROR_SAVEDATA_RW_MEMSTICK_REMOVED";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_RW_MEMSTICK_FULL"] = 2148598563] = "ERROR_SAVEDATA_RW_MEMSTICK_FULL";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_RW_MEMSTICK_PROTECTED"] = 2148598564] = "ERROR_SAVEDATA_RW_MEMSTICK_PROTECTED";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_RW_ACCESS_ERROR"] = 2148598565] = "ERROR_SAVEDATA_RW_ACCESS_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_RW_DATA_BROKEN"] = 2148598566] = "ERROR_SAVEDATA_RW_DATA_BROKEN";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_RW_NO_DATA"] = 2148598567] = "ERROR_SAVEDATA_RW_NO_DATA";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_RW_BAD_PARAMS"] = 2148598568] = "ERROR_SAVEDATA_RW_BAD_PARAMS";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_RW_FILE_NOT_FOUND"] = 2148598569] = "ERROR_SAVEDATA_RW_FILE_NOT_FOUND";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_RW_CAN_NOT_SUSPEND"] = 2148598570] = "ERROR_SAVEDATA_RW_CAN_NOT_SUSPEND";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_RW_INTERNAL_ERROR"] = 2148598571] = "ERROR_SAVEDATA_RW_INTERNAL_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_RW_BAD_STATUS"] = 2148598572] = "ERROR_SAVEDATA_RW_BAD_STATUS";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_RW_SECURE_FILE_FULL"] = 2148598573] = "ERROR_SAVEDATA_RW_SECURE_FILE_FULL";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_DELETE_NO_MEMSTICK"] = 2148598593] = "ERROR_SAVEDATA_DELETE_NO_MEMSTICK";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_DELETE_MEMSTICK_REMOVED"] = 2148598594] = "ERROR_SAVEDATA_DELETE_MEMSTICK_REMOVED";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_DELETE_MEMSTICK_PROTECTED"] = 2148598596] = "ERROR_SAVEDATA_DELETE_MEMSTICK_PROTECTED";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_DELETE_ACCESS_ERROR"] = 2148598597] = "ERROR_SAVEDATA_DELETE_ACCESS_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_DELETE_DATA_BROKEN"] = 2148598598] = "ERROR_SAVEDATA_DELETE_DATA_BROKEN";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_DELETE_NO_DATA"] = 2148598599] = "ERROR_SAVEDATA_DELETE_NO_DATA";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_DELETE_BAD_PARAMS"] = 2148598600] = "ERROR_SAVEDATA_DELETE_BAD_PARAMS";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_DELETE_INTERNAL_ERROR"] = 2148598603] = "ERROR_SAVEDATA_DELETE_INTERNAL_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_SAVE_NO_MEMSTICK"] = 2148598657] = "ERROR_SAVEDATA_SAVE_NO_MEMSTICK";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_SAVE_MEMSTICK_REMOVED"] = 2148598658] = "ERROR_SAVEDATA_SAVE_MEMSTICK_REMOVED";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_SAVE_NO_SPACE"] = 2148598659] = "ERROR_SAVEDATA_SAVE_NO_SPACE";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_SAVE_MEMSTICK_PROTECTED"] = 2148598660] = "ERROR_SAVEDATA_SAVE_MEMSTICK_PROTECTED";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_SAVE_ACCESS_ERROR"] = 2148598661] = "ERROR_SAVEDATA_SAVE_ACCESS_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_SAVE_BAD_PARAMS"] = 2148598664] = "ERROR_SAVEDATA_SAVE_BAD_PARAMS";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_SAVE_NO_UMD"] = 2148598665] = "ERROR_SAVEDATA_SAVE_NO_UMD";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_SAVE_WRONG_UMD"] = 2148598666] = "ERROR_SAVEDATA_SAVE_WRONG_UMD";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_SAVE_INTERNAL_ERROR"] = 2148598667] = "ERROR_SAVEDATA_SAVE_INTERNAL_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_SIZES_NO_MEMSTICK"] = 2148598721] = "ERROR_SAVEDATA_SIZES_NO_MEMSTICK";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_SIZES_MEMSTICK_REMOVED"] = 2148598722] = "ERROR_SAVEDATA_SIZES_MEMSTICK_REMOVED";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_SIZES_ACCESS_ERROR"] = 2148598725] = "ERROR_SAVEDATA_SIZES_ACCESS_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_SIZES_DATA_BROKEN"] = 2148598726] = "ERROR_SAVEDATA_SIZES_DATA_BROKEN";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_SIZES_NO_DATA"] = 2148598727] = "ERROR_SAVEDATA_SIZES_NO_DATA";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_SIZES_BAD_PARAMS"] = 2148598728] = "ERROR_SAVEDATA_SIZES_BAD_PARAMS";
    SceKernelErrors[SceKernelErrors["ERROR_SAVEDATA_SIZES_INTERNAL_ERROR"] = 2148598731] = "ERROR_SAVEDATA_SIZES_INTERNAL_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_NETPARAM_BAD_NETCONF"] = 2148599297] = "ERROR_NETPARAM_BAD_NETCONF";
    SceKernelErrors[SceKernelErrors["ERROR_NETPARAM_BAD_PARAM"] = 2148599300] = "ERROR_NETPARAM_BAD_PARAM";
    SceKernelErrors[SceKernelErrors["ERROR_NET_MODULE_BAD_ID"] = 2148599809] = "ERROR_NET_MODULE_BAD_ID";
    SceKernelErrors[SceKernelErrors["ERROR_NET_MODULE_ALREADY_LOADED"] = 2148599810] = "ERROR_NET_MODULE_ALREADY_LOADED";
    SceKernelErrors[SceKernelErrors["ERROR_NET_MODULE_NOT_LOADED"] = 2148599811] = "ERROR_NET_MODULE_NOT_LOADED";
    SceKernelErrors[SceKernelErrors["ERROR_AV_MODULE_BAD_ID"] = 2148600065] = "ERROR_AV_MODULE_BAD_ID";
    SceKernelErrors[SceKernelErrors["ERROR_AV_MODULE_ALREADY_LOADED"] = 2148600066] = "ERROR_AV_MODULE_ALREADY_LOADED";
    SceKernelErrors[SceKernelErrors["ERROR_AV_MODULE_NOT_LOADED"] = 2148600067] = "ERROR_AV_MODULE_NOT_LOADED";
    SceKernelErrors[SceKernelErrors["ERROR_MODULE_BAD_ID"] = 2148602113] = "ERROR_MODULE_BAD_ID";
    SceKernelErrors[SceKernelErrors["ERROR_MODULE_ALREADY_LOADED"] = 2148602114] = "ERROR_MODULE_ALREADY_LOADED";
    SceKernelErrors[SceKernelErrors["ERROR_MODULE_NOT_LOADED"] = 2148602115] = "ERROR_MODULE_NOT_LOADED";
    SceKernelErrors[SceKernelErrors["ERROR_SCREENSHOT_CONT_MODE_NOT_INIT"] = 2148602409] = "ERROR_SCREENSHOT_CONT_MODE_NOT_INIT";
    SceKernelErrors[SceKernelErrors["ERROR_UMD_NOT_READY"] = 2149646337] = "ERROR_UMD_NOT_READY";
    SceKernelErrors[SceKernelErrors["ERROR_UMD_LBA_OUT_OF_BOUNDS"] = 2149646338] = "ERROR_UMD_LBA_OUT_OF_BOUNDS";
    SceKernelErrors[SceKernelErrors["ERROR_UMD_NO_DISC"] = 2149646339] = "ERROR_UMD_NO_DISC";
    SceKernelErrors[SceKernelErrors["ERROR_MEMSTICK_DEVCTL_BAD_PARAMS"] = 2149712001] = "ERROR_MEMSTICK_DEVCTL_BAD_PARAMS";
    SceKernelErrors[SceKernelErrors["ERROR_MEMSTICK_DEVCTL_TOO_MANY_CALLBACKS"] = 2149712002] = "ERROR_MEMSTICK_DEVCTL_TOO_MANY_CALLBACKS";
    SceKernelErrors[SceKernelErrors["ERROR_AUDIO_CHANNEL_NOT_INIT"] = 2149974017] = "ERROR_AUDIO_CHANNEL_NOT_INIT";
    SceKernelErrors[SceKernelErrors["ERROR_AUDIO_CHANNEL_BUSY"] = 2149974018] = "ERROR_AUDIO_CHANNEL_BUSY";
    SceKernelErrors[SceKernelErrors["ERROR_AUDIO_INVALID_CHANNEL"] = 2149974019] = "ERROR_AUDIO_INVALID_CHANNEL";
    SceKernelErrors[SceKernelErrors["ERROR_AUDIO_PRIV_REQUIRED"] = 2149974020] = "ERROR_AUDIO_PRIV_REQUIRED";
    SceKernelErrors[SceKernelErrors["ERROR_AUDIO_NO_CHANNELS_AVAILABLE"] = 2149974021] = "ERROR_AUDIO_NO_CHANNELS_AVAILABLE";
    SceKernelErrors[SceKernelErrors["ERROR_AUDIO_OUTPUT_SAMPLE_DATA_SIZE_NOT_ALIGNED"] = 2149974022] = "ERROR_AUDIO_OUTPUT_SAMPLE_DATA_SIZE_NOT_ALIGNED";
    SceKernelErrors[SceKernelErrors["ERROR_AUDIO_INVALID_FORMAT"] = 2149974023] = "ERROR_AUDIO_INVALID_FORMAT";
    SceKernelErrors[SceKernelErrors["ERROR_AUDIO_CHANNEL_NOT_RESERVED"] = 2149974024] = "ERROR_AUDIO_CHANNEL_NOT_RESERVED";
    SceKernelErrors[SceKernelErrors["ERROR_AUDIO_NOT_OUTPUT"] = 2149974025] = "ERROR_AUDIO_NOT_OUTPUT";
    SceKernelErrors[SceKernelErrors["ERROR_POWER_VMEM_IN_USE"] = 2150302208] = "ERROR_POWER_VMEM_IN_USE";
    SceKernelErrors[SceKernelErrors["ERROR_NET_RESOLVER_BAD_ID"] = 2151744520] = "ERROR_NET_RESOLVER_BAD_ID";
    SceKernelErrors[SceKernelErrors["ERROR_NET_RESOLVER_ALREADY_STOPPED"] = 2151744522] = "ERROR_NET_RESOLVER_ALREADY_STOPPED";
    SceKernelErrors[SceKernelErrors["ERROR_NET_RESOLVER_INVALID_HOST"] = 2151744532] = "ERROR_NET_RESOLVER_INVALID_HOST";
    SceKernelErrors[SceKernelErrors["ERROR_WLAN_BAD_PARAMS"] = 2151746835] = "ERROR_WLAN_BAD_PARAMS";
    SceKernelErrors[SceKernelErrors["ERROR_HTTP_NOT_INIT"] = 2151878657] = "ERROR_HTTP_NOT_INIT";
    SceKernelErrors[SceKernelErrors["ERROR_HTTP_ALREADY_INIT"] = 2151878688] = "ERROR_HTTP_ALREADY_INIT";
    SceKernelErrors[SceKernelErrors["ERROR_HTTP_NO_MEMORY"] = 2151878775] = "ERROR_HTTP_NO_MEMORY";
    SceKernelErrors[SceKernelErrors["ERROR_HTTP_SYSTEM_COOKIE_NOT_LOADED"] = 2151878776] = "ERROR_HTTP_SYSTEM_COOKIE_NOT_LOADED";
    SceKernelErrors[SceKernelErrors["ERROR_HTTP_INVALID_PARAMETER"] = 2151879166] = "ERROR_HTTP_INVALID_PARAMETER";
    SceKernelErrors[SceKernelErrors["ERROR_SSL_NOT_INIT"] = 2151895041] = "ERROR_SSL_NOT_INIT";
    SceKernelErrors[SceKernelErrors["ERROR_SSL_ALREADY_INIT"] = 2151895072] = "ERROR_SSL_ALREADY_INIT";
    SceKernelErrors[SceKernelErrors["ERROR_SSL_OUT_OF_MEMORY"] = 2151895074] = "ERROR_SSL_OUT_OF_MEMORY";
    SceKernelErrors[SceKernelErrors["ERROR_HTTPS_CERT_ERROR"] = 2151895136] = "ERROR_HTTPS_CERT_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_HTTPS_HANDSHAKE_ERROR"] = 2151895137] = "ERROR_HTTPS_HANDSHAKE_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_HTTPS_IO_ERROR"] = 2151895138] = "ERROR_HTTPS_IO_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_HTTPS_INTERNAL_ERROR"] = 2151895139] = "ERROR_HTTPS_INTERNAL_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_HTTPS_PROXY_ERROR"] = 2151895140] = "ERROR_HTTPS_PROXY_ERROR";
    SceKernelErrors[SceKernelErrors["ERROR_SSL_INVALID_PARAMETER"] = 2151895550] = "ERROR_SSL_INVALID_PARAMETER";
    SceKernelErrors[SceKernelErrors["ERROR_WAVE_NOT_INIT"] = 2151940097] = "ERROR_WAVE_NOT_INIT";
    SceKernelErrors[SceKernelErrors["ERROR_WAVE_FAILED_EXIT"] = 2151940098] = "ERROR_WAVE_FAILED_EXIT";
    SceKernelErrors[SceKernelErrors["ERROR_WAVE_BAD_VOL"] = 2151940106] = "ERROR_WAVE_BAD_VOL";
    SceKernelErrors[SceKernelErrors["ERROR_WAVE_INVALID_CHANNEL"] = 2151940112] = "ERROR_WAVE_INVALID_CHANNEL";
    SceKernelErrors[SceKernelErrors["ERROR_WAVE_INVALID_SAMPLE_COUNT"] = 2151940113] = "ERROR_WAVE_INVALID_SAMPLE_COUNT";
    SceKernelErrors[SceKernelErrors["ERROR_FONT_INVALID_LIBID"] = 2152071170] = "ERROR_FONT_INVALID_LIBID";
    SceKernelErrors[SceKernelErrors["ERROR_FONT_INVALID_PARAMETER"] = 2152071171] = "ERROR_FONT_INVALID_PARAMETER";
    SceKernelErrors[SceKernelErrors["ERROR_FONT_TOO_MANY_OPEN_FONTS"] = 2152071177] = "ERROR_FONT_TOO_MANY_OPEN_FONTS";
    SceKernelErrors[SceKernelErrors["ERROR_MPEG_BAD_VERSION"] = 2153840642] = "ERROR_MPEG_BAD_VERSION";
    SceKernelErrors[SceKernelErrors["ERROR_MPEG_NO_MEMORY"] = 2153840674] = "ERROR_MPEG_NO_MEMORY";
    SceKernelErrors[SceKernelErrors["ERROR_MPEG_INVALID_ADDR"] = 2153840899] = "ERROR_MPEG_INVALID_ADDR";
    SceKernelErrors[SceKernelErrors["ERROR_MPEG_INVALID_VALUE"] = 2153841150] = "ERROR_MPEG_INVALID_VALUE";
    SceKernelErrors[SceKernelErrors["ERROR_PSMF_NOT_INITIALIZED"] = 2153861121] = "ERROR_PSMF_NOT_INITIALIZED";
    SceKernelErrors[SceKernelErrors["ERROR_PSMF_BAD_VERSION"] = 2153861122] = "ERROR_PSMF_BAD_VERSION";
    SceKernelErrors[SceKernelErrors["ERROR_PSMF_NOT_FOUND"] = 2153861157] = "ERROR_PSMF_NOT_FOUND";
    SceKernelErrors[SceKernelErrors["ERROR_PSMF_INVALID_ID"] = 2153861376] = "ERROR_PSMF_INVALID_ID";
    SceKernelErrors[SceKernelErrors["ERROR_PSMF_INVALID_VALUE"] = 2153861630] = "ERROR_PSMF_INVALID_VALUE";
    SceKernelErrors[SceKernelErrors["ERROR_PSMF_INVALID_TIMESTAMP"] = 2153862400] = "ERROR_PSMF_INVALID_TIMESTAMP";
    SceKernelErrors[SceKernelErrors["ERROR_PSMF_INVALID_PSMF"] = 2153862401] = "ERROR_PSMF_INVALID_PSMF";
    SceKernelErrors[SceKernelErrors["ERROR_PSMFPLAYER_NOT_INITIALIZED"] = 2153865217] = "ERROR_PSMFPLAYER_NOT_INITIALIZED";
    SceKernelErrors[SceKernelErrors["ERROR_PSMFPLAYER_NO_MORE_DATA"] = 2153865228] = "ERROR_PSMFPLAYER_NO_MORE_DATA";
    SceKernelErrors[SceKernelErrors["ERROR_MPEG_NO_DATA"] = 2153873409] = "ERROR_MPEG_NO_DATA";
    SceKernelErrors[SceKernelErrors["ERROR_AVC_VIDEO_FATAL"] = 2153938946] = "ERROR_AVC_VIDEO_FATAL";
    SceKernelErrors[SceKernelErrors["ERROR_ATRAC_NO_ID"] = 2153971715] = "ERROR_ATRAC_NO_ID";
    SceKernelErrors[SceKernelErrors["ERROR_ATRAC_INVALID_CODEC"] = 2153971716] = "ERROR_ATRAC_INVALID_CODEC";
    SceKernelErrors[SceKernelErrors["ERROR_ATRAC_BAD_ID"] = 2153971717] = "ERROR_ATRAC_BAD_ID";
    SceKernelErrors[SceKernelErrors["ERROR_ATRAC_ALL_DATA_LOADED"] = 2153971721] = "ERROR_ATRAC_ALL_DATA_LOADED";
    SceKernelErrors[SceKernelErrors["ERROR_ATRAC_NO_DATA"] = 2153971728] = "ERROR_ATRAC_NO_DATA";
    SceKernelErrors[SceKernelErrors["ERROR_ATRAC_SECOND_BUFFER_NEEDED"] = 2153971730] = "ERROR_ATRAC_SECOND_BUFFER_NEEDED";
    SceKernelErrors[SceKernelErrors["ERROR_ATRAC_SECOND_BUFFER_NOT_NEEDED"] = 2153971746] = "ERROR_ATRAC_SECOND_BUFFER_NOT_NEEDED";
    SceKernelErrors[SceKernelErrors["ERROR_ATRAC_BUFFER_IS_EMPTY"] = 2153971747] = "ERROR_ATRAC_BUFFER_IS_EMPTY";
    SceKernelErrors[SceKernelErrors["ERROR_ATRAC_ALL_DATA_DECODED"] = 2153971748] = "ERROR_ATRAC_ALL_DATA_DECODED";
    SceKernelErrors[SceKernelErrors["ERROR_CODEC_AUDIO_FATAL"] = 2155806972] = "ERROR_CODEC_AUDIO_FATAL";
    SceKernelErrors[SceKernelErrors["FATAL_UMD_UNKNOWN_MEDIUM"] = 3223388164] = "FATAL_UMD_UNKNOWN_MEDIUM";
    SceKernelErrors[SceKernelErrors["FATAL_UMD_HARDWARE_FAILURE"] = 3223388165] = "FATAL_UMD_HARDWARE_FAILURE";
    SceKernelErrors[SceKernelErrors["ERROR_AUDIO_INVALID_FREQUENCY"] = 2149974026] = "ERROR_AUDIO_INVALID_FREQUENCY";
    SceKernelErrors[SceKernelErrors["ERROR_AUDIO_INVALID_VOLUME"] = 2149974027] = "ERROR_AUDIO_INVALID_VOLUME";
    SceKernelErrors[SceKernelErrors["ERROR_AUDIO_CHANNEL_ALREADY_RESERVED"] = 2150006786] = "ERROR_AUDIO_CHANNEL_ALREADY_RESERVED";
    SceKernelErrors[SceKernelErrors["PSP_AUDIO_ERROR_SRC_FORMAT_4"] = 2147483651] = "PSP_AUDIO_ERROR_SRC_FORMAT_4";
    SceKernelErrors[SceKernelErrors["ATRAC_ERROR_API_FAIL"] = 2153971714] = "ATRAC_ERROR_API_FAIL";
    SceKernelErrors[SceKernelErrors["ATRAC_ERROR_NO_ATRACID"] = 2153971715] = "ATRAC_ERROR_NO_ATRACID";
    SceKernelErrors[SceKernelErrors["ATRAC_ERROR_INVALID_CODECTYPE"] = 2153971716] = "ATRAC_ERROR_INVALID_CODECTYPE";
    SceKernelErrors[SceKernelErrors["ATRAC_ERROR_BAD_ATRACID"] = 2153971717] = "ATRAC_ERROR_BAD_ATRACID";
    SceKernelErrors[SceKernelErrors["ATRAC_ERROR_ALL_DATA_LOADED"] = 2153971721] = "ATRAC_ERROR_ALL_DATA_LOADED";
    SceKernelErrors[SceKernelErrors["ATRAC_ERROR_NO_DATA"] = 2153971728] = "ATRAC_ERROR_NO_DATA";
    SceKernelErrors[SceKernelErrors["ATRAC_ERROR_SECOND_BUFFER_NEEDED"] = 2153971730] = "ATRAC_ERROR_SECOND_BUFFER_NEEDED";
    SceKernelErrors[SceKernelErrors["ATRAC_ERROR_INCORRECT_READ_SIZE"] = 2153971731] = "ATRAC_ERROR_INCORRECT_READ_SIZE";
    SceKernelErrors[SceKernelErrors["ATRAC_ERROR_ADD_DATA_IS_TOO_BIG"] = 2153971736] = "ATRAC_ERROR_ADD_DATA_IS_TOO_BIG";
    SceKernelErrors[SceKernelErrors["ATRAC_ERROR_UNSET_PARAM"] = 2153971745] = "ATRAC_ERROR_UNSET_PARAM";
    SceKernelErrors[SceKernelErrors["ATRAC_ERROR_SECOND_BUFFER_NOT_NEEDED"] = 2153971746] = "ATRAC_ERROR_SECOND_BUFFER_NOT_NEEDED";
    SceKernelErrors[SceKernelErrors["ATRAC_ERROR_BUFFER_IS_EMPTY"] = 2153971747] = "ATRAC_ERROR_BUFFER_IS_EMPTY";
    SceKernelErrors[SceKernelErrors["ATRAC_ERROR_ALL_DATA_DECODED"] = 2153971748] = "ATRAC_ERROR_ALL_DATA_DECODED";
    SceKernelErrors[SceKernelErrors["PSP_SYSTEMPARAM_RETVAL"] = 2148598019] = "PSP_SYSTEMPARAM_RETVAL";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_VOICE"] = 2151809040] = "ERROR_SAS_INVALID_VOICE";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_ADSR_CURVE_MODE"] = 2151809043] = "ERROR_SAS_INVALID_ADSR_CURVE_MODE";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_PARAMETER"] = 2151809044] = "ERROR_SAS_INVALID_PARAMETER";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_LOOP_POS"] = 2151809045] = "ERROR_SAS_INVALID_LOOP_POS";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_VOICE_PAUSED"] = 2151809046] = "ERROR_SAS_VOICE_PAUSED";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_BUSY"] = 2151809072] = "ERROR_SAS_BUSY";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_NOT_INIT"] = 2151809280] = "ERROR_SAS_NOT_INIT";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_GRAIN"] = 2151809025] = "ERROR_SAS_INVALID_GRAIN";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_MAX_VOICES"] = 2151809026] = "ERROR_SAS_INVALID_MAX_VOICES";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_OUTPUT_MODE"] = 2151809027] = "ERROR_SAS_INVALID_OUTPUT_MODE";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_SAMPLE_RATE"] = 2151809028] = "ERROR_SAS_INVALID_SAMPLE_RATE";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_ADDRESS"] = 2151809029] = "ERROR_SAS_INVALID_ADDRESS";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_VOICE_INDEX"] = 2151809040] = "ERROR_SAS_INVALID_VOICE_INDEX";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_NOISE_CLOCK"] = 2151809041] = "ERROR_SAS_INVALID_NOISE_CLOCK";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_PITCH_VAL"] = 2151809042] = "ERROR_SAS_INVALID_PITCH_VAL";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_ADPCM_SIZE"] = 2151809044] = "ERROR_SAS_INVALID_ADPCM_SIZE";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_LOOP_MODE"] = 2151809045] = "ERROR_SAS_INVALID_LOOP_MODE";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_VOLUME_VAL"] = 2151809048] = "ERROR_SAS_INVALID_VOLUME_VAL";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_ADSR_VAL"] = 2151809049] = "ERROR_SAS_INVALID_ADSR_VAL";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_SIZE"] = 2151809050] = "ERROR_SAS_INVALID_SIZE";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_FX_TYPE"] = 2151809056] = "ERROR_SAS_INVALID_FX_TYPE";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_FX_FEEDBACK"] = 2151809057] = "ERROR_SAS_INVALID_FX_FEEDBACK";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_FX_DELAY"] = 2151809058] = "ERROR_SAS_INVALID_FX_DELAY";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_INVALID_FX_VOLUME_VAL"] = 2151809059] = "ERROR_SAS_INVALID_FX_VOLUME_VAL";
    SceKernelErrors[SceKernelErrors["ERROR_SAS_ALREADY_INIT"] = 2151809281] = "ERROR_SAS_ALREADY_INIT";
    SceKernelErrors[SceKernelErrors["PSP_POWER_ERROR_TAKEN_SLOT"] = 2147483680] = "PSP_POWER_ERROR_TAKEN_SLOT";
    SceKernelErrors[SceKernelErrors["PSP_POWER_ERROR_SLOTS_FULL"] = 2147483682] = "PSP_POWER_ERROR_SLOTS_FULL";
    SceKernelErrors[SceKernelErrors["PSP_POWER_ERROR_PRIVATE_SLOT"] = 2147483683] = "PSP_POWER_ERROR_PRIVATE_SLOT";
    SceKernelErrors[SceKernelErrors["PSP_POWER_ERROR_EMPTY_SLOT"] = 2147483685] = "PSP_POWER_ERROR_EMPTY_SLOT";
    SceKernelErrors[SceKernelErrors["PSP_POWER_ERROR_INVALID_CB"] = 2147483904] = "PSP_POWER_ERROR_INVALID_CB";
    SceKernelErrors[SceKernelErrors["PSP_POWER_ERROR_INVALID_SLOT"] = 2147483906] = "PSP_POWER_ERROR_INVALID_SLOT";
})(SceKernelErrors || (SceKernelErrors = {}));
module.exports = SceKernelErrors;

},
"src/hle/config": function(module, exports, require) {
///<reference path="../global.d.ts" />
var _structs = require('./structs');
var PspLanguages = _structs.PspLanguages;
var ButtonPreference = _structs.ButtonPreference;
var Config = (function () {
    function Config() {
        this.language = PspLanguages.ENGLISH;
        this.buttonPreference = ButtonPreference.NA;
        this.language = this.detectLanguage();
    }
    Config.prototype.detectLanguage = function () {
        if (typeof navigator == 'undefined')
            return PspLanguages.ENGLISH;
        if (!navigator.language)
            return PspLanguages.ENGLISH;
        switch (navigator.language.split(/[_\-]/g)[0]) {
            case 'ja': return PspLanguages.JAPANESE;
            case 'en': return PspLanguages.ENGLISH;
            case 'fr': return PspLanguages.FRENCH;
            case 'es': return PspLanguages.SPANISH;
            case 'de': return PspLanguages.GERMAN;
            case 'it': return PspLanguages.ITALIAN;
            case 'nl': return PspLanguages.DUTCH;
            case 'pt': return PspLanguages.PORTUGUESE;
            case 'ru': return PspLanguages.RUSSIAN;
            case 'ko': return PspLanguages.KOREAN;
            case 'zh': return PspLanguages.TRADITIONAL_CHINESE;
            case 'zh2': return PspLanguages.SIMPLIFIED_CHINESE;
            default: return PspLanguages.ENGLISH;
        }
    };
    return Config;
})();
exports.Config = Config;

},
"src/hle/elf_crypted_prx": function(module, exports, require) {
var kirk = require('../core/kirk');
var keys144 = require('./elf_crypted_prx_keys_144');
var keys16 = require('./elf_crypted_prx_keys_16');
var Header = (function () {
    function Header() {
    }
    Header.struct = StructClass.create(Header, [
        { magic: UInt32 },
        { modAttr: UInt16 },
        { compModAttr: UInt16 },
        { modVerLo: UInt8 },
        { modVerHi: UInt8 },
        { moduleName: Stringz(28) },
        { modVersion: UInt8 },
        { nsegments: UInt8 },
        { elfSize: UInt32 },
        { pspSize: UInt32 },
        { bootEntry: UInt32 },
        { modInfoOffset: UInt32 },
        { bssSize: UInt32 },
        { segAlign: StructArray(UInt16, 4) },
        { segAddress: StructArray(UInt32, 4) },
        { segSize: StructArray(UInt32, 4) },
        { reserved: StructArray(UInt32, 5) },
        { devkitVersion: UInt32 },
        { decMode: UInt8 },
        { pad: UInt8 },
        { overlapSize: UInt16 },
        { aesKey: StructArray(UInt8, 16) },
        { cmacKey: StructArray(UInt8, 16) },
        { cmacHeaderHash: StructArray(UInt8, 16) },
        { compressedSize: UInt32 },
        { compressedOffset: UInt32 },
        { unk1: UInt32 },
        { unk2: UInt32 },
        { cmacDataHash: StructArray(UInt8, 16) },
        { tag: UInt32 },
        { sigcheck: StructArray(UInt8, 88) },
        { sha1Hash: StructArray(UInt8, 20) },
        { keyData: StructArray(UInt8, 16) },
    ]);
    return Header;
})();
function getTagInfo(checkTag) {
    return keys144.g_tagInfo.first(function (item) { return item.tag == checkTag; });
}
function getTagInfo2(checkTag) {
    return keys16.g_tagInfo2.first(function (item) { return item.tag == checkTag; });
}
function copyFromTo(from, fromOffset, to, toOffset, count) {
    for (var n = 0; n < count; n++) {
        to[toOffset + n] = from[fromOffset + n];
    }
}
function memset(array, offset, count, value) {
    for (var n = 0; n < count; n++)
        array[offset + n] = value;
}
function decrypt1(pbIn) {
    var cbTotal = pbIn.length;
    var _pbOut = new Uint8Array(cbTotal);
    var pbOut = Stream.fromUint8Array(_pbOut);
    pbOut.slice().writeStream(pbIn);
    var header = Header.struct.read(pbIn.slice());
    var pti = getTagInfo(header.tag);
    if (!pti)
        throw (new Error("Can't find tag " + header.tag));
    pbOut.slice().writeStream(pbIn);
    pbOut.slice().writeByteRepeated(0x00, 0x150);
    pbOut.slice().writeByteRepeated(0x55, 0x40);
    var h7_header = new (kirk.KIRK_AES128CBC_HEADER)();
    h7_header.mode = kirk.KirkMode.DecryptCbc;
    h7_header.unk_4 = 0;
    h7_header.unk_8 = 0;
    h7_header.keyseed = pti.code;
    h7_header.data_size = 0x70;
    kirk.KIRK_AES128CBC_HEADER.struct.write(pbOut.sliceFrom(0x2C), h7_header);
    var buffer1 = Stream.fromSize(0x150);
    buffer1.sliceWithLength(0x00).writeStream(pbIn.sliceWithLength(0xD0, 0x80));
    buffer1.sliceWithLength(0x80).writeStream(pbIn.sliceWithLength(0x80, 0x50));
    buffer1.sliceWithLength(0xD0).writeStream(pbIn.sliceWithLength(0x00, 0x80));
    if (pti.codeExtra != 0) {
        var buffer2 = Stream.fromSize(20 + 0xA0);
        buffer2.slice()
            .writeUInt32(5)
            .writeUInt32(0)
            .writeUInt32(0)
            .writeUInt32(pti.codeExtra)
            .writeUInt32(0xA0)
            .writeStream(buffer1.sliceWithLength(0x10, 0xA0));
        kirk.hleUtilsBufferCopyWithRange(buffer2.sliceWithLength(0, 20 + 0xA0), buffer2.sliceWithLength(0, 20 + 0xA0), kirk.CommandEnum.DECRYPT_IV_0);
        buffer1.slice().writeStream(buffer2.sliceWithLength(0, 0xA0));
    }
    pbOut.sliceFrom(0x40).writeStream(buffer1.sliceWithLength(0x40, 0x40));
    for (var iXOR = 0; iXOR < 0x70; iXOR++)
        pbOut.set(0x40 + iXOR, ((pbOut.get(0x40 + iXOR) ^ pti.key[0x14 + iXOR]) & 0xFF));
    kirk.hleUtilsBufferCopyWithRange(pbOut.sliceWithLength(0x2C, 20 + 0x70), pbOut.sliceWithLength(0x2C, 20 + 0x70), kirk.CommandEnum.DECRYPT_IV_0);
    for (var iXOR = 0x6F; iXOR >= 0; iXOR--)
        pbOut.set(0x40 + iXOR, ((pbOut.get(0x2C + iXOR) ^ pti.key[0x20 + iXOR]) & 0xFF));
    pbOut.sliceFrom(0x80).writeByteRepeated(0, 0x30);
    pbOut.set(0xA0, 1);
    pbOut.sliceFrom(0xB0).writeStream(pbIn.sliceWithLength(0xB0, 0x20));
    pbOut.sliceFrom(0xD0).writeStream(pbIn.sliceWithLength(0x00, 0x80));
    kirk.hleUtilsBufferCopyWithRange(pbOut.sliceWithLength(0x00, cbTotal), pbOut.sliceWithLength(0x40, cbTotal - 0x40), kirk.CommandEnum.DECRYPT_PRIVATE);
    var outputSize = pbIn.sliceFrom(0xB0).readUInt32();
    return pbOut.sliceWithLength(0, outputSize);
}
function decrypt(input) {
    return decrypt1(input.slice());
}
exports.decrypt = decrypt;

},
"src/hle/elf_crypted_prx_keys_144": function(module, exports, require) {
var g_key0 = new Uint32Array([
    0x7b21f3be, 0x299c5e1d, 0x1c9c5e71, 0x96cb4645, 0x3c9b1be0, 0xeb85de3d,
    0x4a7f2022, 0xc2206eaa, 0xd50b3265, 0x55770567, 0x3c080840, 0x981d55f2,
    0x5fd8f6f3, 0xee8eb0c5, 0x944d8152, 0xf8278651, 0x2705bafa, 0x8420e533,
    0x27154ae9, 0x4819aa32, 0x59a3aa40, 0x2cb3cf65, 0xf274466d, 0x3a655605,
    0x21b0f88f, 0xc5b18d26, 0x64c19051, 0xd669c94e, 0xe87035f2, 0x9d3a5909,
    0x6f4e7102, 0xdca946ce, 0x8416881b, 0xbab097a5, 0x249125c6, 0xb34c0872,
]);
var g_key2 = new Uint32Array([
    0xccfda932, 0x51c06f76, 0x046dcccf, 0x49e1821e, 0x7d3b024c, 0x9dda5865,
    0xcc8c9825, 0xd1e97db5, 0x6874d8cb, 0x3471c987, 0x72edb3fc, 0x81c8365d,
    0xe161e33a, 0xfc92db59, 0x2009b1ec, 0xb1a94ce4, 0x2f03696b, 0x87e236d8,
    0x3b2b8ce9, 0x0305e784, 0xf9710883, 0xb039db39, 0x893bea37, 0xe74d6805,
    0x2a5c38bd, 0xb08dc813, 0x15b32375, 0x46be4525, 0x0103fd90, 0xa90e87a2,
    0x52aba66a, 0x85bf7b80, 0x45e8ce63, 0x4dd716d3, 0xf5e30d2d, 0xaf3ae456,
]);
var g_key3 = new Uint32Array([
    0xa6c8f5ca, 0x6d67c080, 0x924f4d3a, 0x047ca06a, 0x08640297, 0x4fd4a758,
    0xbd685a87, 0x9b2701c2, 0x83b62a35, 0x726b533c, 0xe522fa0c, 0xc24b06b4,
    0x459d1cac, 0xa8c5417b, 0x4fea62a2, 0x0615d742, 0x30628d09, 0xc44fab14,
    0x69ff715e, 0xd2d8837d, 0xbeed0b8b, 0x1e6e57ae, 0x61e8c402, 0xbe367a06,
    0x543f2b5e, 0xdb3ec058, 0xbe852075, 0x1e7e4dcc, 0x1564ea55, 0xec7825b4,
    0xc0538cad, 0x70f72c7f, 0x49e8c3d0, 0xeda97ec5, 0xf492b0a4, 0xe05eb02a,
]);
var g_key44 = new Uint32Array([
    0xef80e005, 0x3a54689f, 0x43c99ccd, 0x1b7727be, 0x5cb80038, 0xdd2efe62,
    0xf369f92c, 0x160f94c5, 0x29560019, 0xbf3c10c5, 0xf2ce5566, 0xcea2c626,
    0xb601816f, 0x64e7481e, 0x0c34debd, 0x98f29cb0, 0x3fc504d7, 0xc8fb39f0,
    0x0221b3d8, 0x63f936a2, 0x9a3a4800, 0x6ecc32e3, 0x8e120cfd, 0xb0361623,
    0xaee1e689, 0x745502eb, 0xe4a6c61c, 0x74f23eb4, 0xd7fa5813, 0xb01916eb,
    0x12328457, 0xd2bc97d2, 0x646425d8, 0x328380a5, 0x43da8ab1, 0x4b122ac9,
]);
var g_key20 = new Uint32Array([
    0x33b50800, 0xf32f5fcd, 0x3c14881f, 0x6e8a2a95, 0x29feefd5, 0x1394eae3,
    0xbd6bd443, 0x0821c083, 0xfab379d3, 0xe613e165, 0xf5a754d3, 0x108b2952,
    0x0a4b1e15, 0x61eadeba, 0x557565df, 0x3b465301, 0xae54ecc3, 0x61423309,
    0x70c9ff19, 0x5b0ae5ec, 0x989df126, 0x9d987a5f, 0x55bc750e, 0xc66eba27,
    0x2de988e8, 0xf76600da, 0x0382dccb, 0x5569f5f2, 0x8e431262, 0x288fe3d3,
    0x656f2187, 0x37d12e9c, 0x2f539eb4, 0xa492998e, 0xed3958f7, 0x39e96523,
]);
var g_key3A = new Uint32Array([
    0x67877069, 0x3abd5617, 0xc23ab1dc, 0xab57507d, 0x066a7f40, 0x24def9b9,
    0x06f759e4, 0xdcf524b1, 0x13793e5e, 0x0359022d, 0xaae7e1a2, 0x76b9b2fa,
    0x9a160340, 0x87822fba, 0x19e28fbb, 0x9e338a02, 0xd8007e9a, 0xea317af1,
    0x630671de, 0x0b67ca7c, 0x865192af, 0xea3c3526, 0x2b448c8e, 0x8b599254,
    0x4602e9cb, 0x4de16cda, 0xe164d5bb, 0x07ecd88e, 0x99ffe5f8, 0x768800c1,
    0x53b091ed, 0x84047434, 0xb426dbbc, 0x36f948bb, 0x46142158, 0x749bb492,
]);
var g_keyEBOOT1xx = new Uint32Array([
    0x18CB69EF, 0x158E8912, 0xDEF90EBB, 0x4CB0FB23, 0x3687EE18, 0x868D4A6E,
    0x19B5C756, 0xEE16551D, 0xE7CB2D6C, 0x9747C660, 0xCE95143F, 0x2956F477,
    0x03824ADE, 0x210C9DF1, 0x5029EB24, 0x81DFE69F, 0x39C89B00, 0xB00C8B91,
    0xEF2DF9C2, 0xE13A93FC, 0x8B94A4A8, 0x491DD09D, 0x686A400D, 0xCED4C7E4,
    0x96C8B7C9, 0x1EAADC28, 0xA4170B84, 0x505D5DDC, 0x5DA6C3CF, 0x0E5DFA2D,
    0x6E7919B5, 0xCE5E29C7, 0xAAACDB94, 0x45F70CDD, 0x62A73725, 0xCCE6563D,
]);
var g_keyEBOOT2xx = new Uint32Array([
    0xDA8E36FA, 0x5DD97447, 0x76C19874, 0x97E57EAF, 0x1CAB09BD, 0x9835BAC6,
    0x03D39281, 0x03B205CF, 0x2882E734, 0xE714F663, 0xB96E2775, 0xBD8AAFC7,
    0x1DD3EC29, 0xECA4A16C, 0x5F69EC87, 0x85981E92, 0x7CFCAE21, 0xBAE9DD16,
    0xE6A97804, 0x2EEE02FC, 0x61DF8A3D, 0xDD310564, 0x9697E149, 0xC2453F3B,
    0xF91D8456, 0x39DA6BC8, 0xB3E5FEF5, 0x89C593A3, 0xFB5C8ABC, 0x6C0B7212,
    0xE10DD3CB, 0x98D0B2A8, 0x5FD61847, 0xF0DC2357, 0x7701166A, 0x0F5C3B68,
]);
var g_keyUPDATER = new Uint32Array([
    0xA5603CBF, 0xD7482441, 0xF65764CC, 0x1F90060B, 0x4EA73E45, 0xE551D192,
    0xE7B75D8A, 0x465A506E, 0x40FB1022, 0x2C273350, 0x8096DA44, 0x9947198E,
    0x278DEE77, 0x745D062E, 0xC148FA45, 0x832582AF, 0x5FDB86DA, 0xCB15C4CE,
    0x2524C62F, 0x6C2EC3B1, 0x369BE39E, 0xF7EB1FC4, 0x1E51CE1A, 0xD70536F4,
    0xC34D39D8, 0x7418FB13, 0xE3C84DE1, 0xB118F03C, 0xA2018D4E, 0xE6D8770D,
    0x5720F390, 0x17F96341, 0x60A4A68F, 0x1327DD28, 0x05944C64, 0x0C2C4C12,
]);
var g_keyMEIMG250 = new Uint32Array([
    0xA381FEBC, 0x99B9D5C9, 0x6C560A8D, 0x30309F95, 0x792646CC, 0x82B64E5E,
    0x1A3951AD, 0x0A182EC4, 0xC46131B4, 0x77C50C8A, 0x325F16C6, 0x02D1942E,
    0x0AA38AC4, 0x2A940AC6, 0x67034726, 0xE52DB133, 0xD2EF2107, 0x85C81E90,
    0xC8D164BA, 0xC38DCE1D, 0x948BA275, 0x0DB84603, 0xE2473637, 0xCD74FCDA,
    0x588E3D66, 0x6D28E822, 0x891E548B, 0xF53CF56D, 0x0BBDDB66, 0xC4B286AA,
    0x2BEBBC4B, 0xFC261FF4, 0x92B8E705, 0xDCEE6952, 0x5E0442E5, 0x8BEB7F21,
]);
var g_keyMEIMG260 = new Uint32Array([
    0x11BFD698, 0xD7F9B324, 0xDD524927, 0x16215B86, 0x504AC36D, 0x5843B217,
    0xE5A0DA47, 0xBB73A1E7, 0x2915DB35, 0x375CFD3A, 0xBB70A905, 0x272BEFCA,
    0x2E960791, 0xEA0799BB, 0xB85AE6C8, 0xC9CAF773, 0x250EE641, 0x06E74A9E,
    0x5244895D, 0x466755A5, 0x9A84AF53, 0xE1024174, 0xEEBA031E, 0xED80B9CE,
    0xBC315F72, 0x5821067F, 0xE8313058, 0xD2D0E706, 0xE6D8933E, 0xD7D17FB4,
    0x505096C4, 0xFDA50B3B, 0x4635AE3D, 0xEB489C8A, 0x422D762D, 0x5A8B3231,
]);
var g_keyDEMOS27X = new Uint32Array([
    0x1ABF102F, 0xD596D071, 0x6FC552B2, 0xD4F2531F, 0xF025CDD9, 0xAF9AAF03,
    0xE0CF57CF, 0x255494C4, 0x7003675E, 0x907BC884, 0x002D4EE4, 0x0B687A0D,
    0x9E3AA44F, 0xF58FDA81, 0xEC26AC8C, 0x3AC9B49D, 0x3471C037, 0xB0F3834D,
    0x10DC4411, 0xA232EA31, 0xE2E5FA6B, 0x45594B03, 0xE43A1C87, 0x31DAD9D1,
    0x08CD7003, 0xFA9C2FDF, 0x5A891D25, 0x9B5C1934, 0x22F366E5, 0x5F084A32,
    0x695516D5, 0x2245BE9F, 0x4F6DD705, 0xC4B8B8A1, 0xBC13A600, 0x77B7FC3B,
]);
var g_keyUNK1 = new Uint32Array([
    0x33B50800, 0xF32F5FCD, 0x3C14881F, 0x6E8A2A95, 0x29FEEFD5, 0x1394EAE3,
    0xBD6BD443, 0x0821C083, 0xFAB379D3, 0xE613E165, 0xF5A754D3, 0x108B2952,
    0x0A4B1E15, 0x61EADEBA, 0x557565DF, 0x3B465301, 0xAE54ECC3, 0x61423309,
    0x70C9FF19, 0x5B0AE5EC, 0x989DF126, 0x9D987A5F, 0x55BC750E, 0xC66EBA27,
    0x2DE988E8, 0xF76600DA, 0x0382DCCB, 0x5569F5F2, 0x8E431262, 0x288FE3D3,
    0x656F2187, 0x37D12E9C, 0x2F539EB4, 0xA492998E, 0xED3958F7, 0x39E96523,
]);
var g_key_GAMESHARE1xx = new Uint32Array([
    0x721B53E8, 0xFC3E31C6, 0xF85BA2A2, 0x3CF0AC72, 0x54EEA7AB, 0x5959BFCB,
    0x54B8836B, 0xBC431313, 0x989EF2CF, 0xF0CE36B2, 0x98BA4CF8, 0xE971C931,
    0xA0375DC8, 0x08E52FA0, 0xAC0DD426, 0x57E4D601, 0xC56E61C7, 0xEF1AB98A,
    0xD1D9F8F4, 0x5FE9A708, 0x3EF09D07, 0xFA0C1A8C, 0xA91EEA5C, 0x58F482C5,
    0x2C800302, 0x7EE6F6C3, 0xFF6ABBBB, 0x2110D0D0, 0xD3297A88, 0x980012D3,
    0xDC59C87B, 0x7FDC5792, 0xDB3F5DA6, 0xFC23B787, 0x22698ED3, 0xB680E812,
]);
var g_key_GAMESHARE2xx = new Uint32Array([
    0x94A757C7, 0x9FD39833, 0xF8508371, 0x328B0B29, 0x2CBCB9DA, 0x2918B9C6,
    0x944C50BA, 0xF1DCE7D0, 0x640C3966, 0xC90B3D08, 0xF4AD17BA, 0x6CA0F84B,
    0xF7767C67, 0xA4D3A55A, 0x4A085C6A, 0x6BB27071, 0xFA8B38FB, 0x3FDB31B8,
    0x8B7196F2, 0xDB9BED4A, 0x51625B84, 0x4C1481B4, 0xF684F508, 0x30B44770,
    0x93AA8E74, 0x90C579BC, 0x246EC88D, 0x2E051202, 0xC774842E, 0xA185D997,
    0x7A2B3ADD, 0xFE835B6D, 0x508F184D, 0xEB4C4F13, 0x0E1993D3, 0xBA96DFD2,
]);
var g_key_INDEXDAT1xx = new Uint32Array([
    0x76CB00AF, 0x111CE62F, 0xB7B27E36, 0x6D8DE8F9, 0xD54BF16A, 0xD9E90373,
    0x7599D982, 0x51F82B0E, 0x636103AD, 0x8E40BC35, 0x2F332C94, 0xF513AAE9,
    0xD22AFEE9, 0x04343987, 0xFC5BB80C, 0x12349D89, 0x14A481BB, 0x25ED3AE8,
    0x7D500E4F, 0x43D1B757, 0x7B59FDAD, 0x4CFBBF34, 0xC3D17436, 0xC1DA21DB,
    0xA34D8C80, 0x962B235D, 0x3E420548, 0x09CF9FFE, 0xD4883F5C, 0xD90E9CB5,
    0x00AEF4E9, 0xF0886DE9, 0x62A58A5B, 0x52A55546, 0x971941B5, 0xF5B79FAC,
]);
function process(_item) {
    var item = _item;
    item.key = new Uint8Array(_item.ikey.buffer);
    return item;
}
exports.g_tagInfo = [
    process({ tag: 0x00000000, ikey: g_key0, code: 0x42, codeExtra: 0x00 }),
    process({ tag: 0x02000000, ikey: g_key2, code: 0x45, codeExtra: 0x00 }),
    process({ tag: 0x03000000, ikey: g_key3, code: 0x46, codeExtra: 0x00 }),
    process({ tag: 0x4467415d, ikey: g_key44, code: 0x59, codeExtra: 0x59 }),
    process({ tag: 0x207bbf2f, ikey: g_key20, code: 0x5A, codeExtra: 0x5A }),
    process({ tag: 0x3ace4dce, ikey: g_key3A, code: 0x5B, codeExtra: 0x5B }),
    process({ tag: 0x07000000, ikey: g_key_INDEXDAT1xx, code: 0x4A, codeExtra: 0x00 }),
    process({ tag: 0x08000000, ikey: g_keyEBOOT1xx, code: 0x4B, codeExtra: 0x00 }),
    process({ tag: 0xC0CB167C, ikey: g_keyEBOOT2xx, code: 0x5D, codeExtra: 0x5D }),
    process({ tag: 0x0B000000, ikey: g_keyUPDATER, code: 0x4E, codeExtra: 0x00 }),
    process({ tag: 0x0C000000, ikey: g_keyDEMOS27X, code: 0x4F, codeExtra: 0x00 }),
    process({ tag: 0x0F000000, ikey: g_keyMEIMG250, code: 0x52, codeExtra: 0x00 }),
    process({ tag: 0x862648D1, ikey: g_keyMEIMG260, code: 0x52, codeExtra: 0x52 }),
    process({ tag: 0x207BBF2F, ikey: g_keyUNK1, code: 0x5A, codeExtra: 0x5A }),
    process({ tag: 0x09000000, ikey: g_key_GAMESHARE1xx, code: 0x4C, codeExtra: 0x00 }),
    process({ tag: 0xBB67C59F, ikey: g_key_GAMESHARE2xx, code: 0x5E, codeExtra: 0x5E }),
];

},
"src/hle/elf_crypted_prx_keys_16": function(module, exports, require) {
exports.g_tagInfo2 = [
    { tag: 0x380228F0, key: keys620_5v, code: 0x5A },
    { tag: 0x4C942AF0, key: keys620_5k, code: 0x43 },
    { tag: 0x4C9428F0, key: keys620_5, code: 0x43 },
    { tag: 0x4C9429F0, key: keys570_5k, code: 0x43 },
    { tag: 0x4C941DF0, key: keys620_1, code: 0x43 },
    { tag: 0x4C941CF0, key: keys620_0, code: 0x43 },
    { tag: 0x457B1EF0, key: keys620_3, code: 0x5B },
    { tag: 0x457B0BF0, key: keys600_u1_457B0BF0, code: 0x5B },
    { tag: 0x457B0CF0, key: keys600_u1_457B0CF0, code: 0x5B },
    { tag: 0x4C9419F0, key: keys500_1, code: 0x43 },
    { tag: 0x4C9418F0, key: keys500_0, code: 0x43 },
    { tag: 0x4C941FF0, key: keys500_2, code: 0x43 },
    { tag: 0x4C9417F0, key: keys500_1, code: 0x43 },
    { tag: 0x4C9416F0, key: keys500_0, code: 0x43 },
    { tag: 0x4C9414F0, key: keys390_0, code: 0x43 },
    { tag: 0x4C9415F0, key: keys390_1, code: 0x43 },
    { tag: 0xD82310F0, key: keys02G_E, code: 0x51 },
    { tag: 0xD8231EF0, key: keys03G_E, code: 0x51 },
    { tag: 0xD82328F0, key: keys05G_E, code: 0x51 },
    { tag: 0x4C9412F0, key: keys370_0, code: 0x43 },
    { tag: 0x4C9413F0, key: keys370_1, code: 0x43 },
    { tag: 0x457B10F0, key: keys370_2, code: 0x5B },
    { tag: 0x4C940DF0, key: keys360_0, code: 0x43 },
    { tag: 0x4C9410F0, key: keys360_1, code: 0x43 },
    { tag: 0x4C940BF0, key: keys330_0, code: 0x43 },
    { tag: 0x457B0AF0, key: keys330_1, code: 0x5B },
    { tag: 0x38020AF0, key: keys330_2, code: 0x5A },
    { tag: 0x4C940AF0, key: keys330_3, code: 0x43 },
    { tag: 0x4C940CF0, key: keys330_4, code: 0x43 },
    { tag: 0xcfef09f0, key: keys310_0, code: 0x62 },
    { tag: 0x457b08f0, key: keys310_1, code: 0x5B },
    { tag: 0x380208F0, key: keys310_2, code: 0x5A },
    { tag: 0xcfef08f0, key: keys310_3, code: 0x62 },
    { tag: 0xCFEF07F0, key: keys303_0, code: 0x62 },
    { tag: 0xCFEF06F0, key: keys300_0, code: 0x62 },
    { tag: 0x457B06F0, key: keys300_1, code: 0x5B },
    { tag: 0x380206F0, key: keys300_2, code: 0x5A },
    { tag: 0xCFEF05F0, key: keys280_0, code: 0x62 },
    { tag: 0x457B05F0, key: keys280_1, code: 0x5B },
    { tag: 0x380205F0, key: keys280_2, code: 0x5A },
    { tag: 0x16D59E03, key: keys260_0, code: 0x62 },
    { tag: 0x76202403, key: keys260_1, code: 0x5B },
    { tag: 0x0F037303, key: keys260_2, code: 0x5A },
    { tag: 0x457B28F0, key: keys620_e, code: 0x5B },
    { tag: 0xADF305F0, key: demokeys_280, code: 0x60 },
    { tag: 0xADF306F0, key: demokeys_3XX_1, code: 0x60 },
    { tag: 0xADF308F0, key: demokeys_3XX_2, code: 0x60 },
    { tag: 0x8004FD03, key: ebootbin_271_new, code: 0x5D },
    { tag: 0xD91605F0, key: ebootbin_280_new, code: 0x5D },
    { tag: 0xD91606F0, key: ebootbin_300_new, code: 0x5D },
    { tag: 0xD91608F0, key: ebootbin_310_new, code: 0x5D },
    { tag: 0xD91609F0, key: key_D91609F0, code: 0x5D },
    { tag: 0x2E5E10F0, key: key_2E5E10F0, code: 0x48 },
    { tag: 0x2E5E12F0, key: key_2E5E12F0, code: 0x48 },
    { tag: 0x2E5E12F0, key: key_2E5E13F0, code: 0x48 },
    { tag: 0xD9160AF0, key: key_D9160AF0, code: 0x5D },
    { tag: 0xD9160BF0, key: key_D9160BF0, code: 0x5D },
    { tag: 0xD91611F0, key: key_D91611F0, code: 0x5D },
    { tag: 0xD91612F0, key: key_D91612F0, code: 0x5D },
    { tag: 0xD91613F0, key: key_D91613F0, code: 0x5D },
    { tag: 0x0A35EA03, key: gameshare_260_271, code: 0x5E },
    { tag: 0x7B0505F0, key: gameshare_280, code: 0x5E },
    { tag: 0x7B0506F0, key: gameshare_300, code: 0x5E },
    { tag: 0x7B0508F0, key: gameshare_310, code: 0x5E },
    { tag: 0x279D08F0, key: oneseg_310, code: 0x61 },
    { tag: 0x279D06F0, key: oneseg_300, code: 0x61 },
    { tag: 0x279D05F0, key: oneseg_280, code: 0x61 },
    { tag: 0xD66DF703, key: oneseg_260_271, code: 0x61 },
    { tag: 0x279D10F0, key: oneseg_slim, code: 0x61 },
    { tag: 0x3C2A08F0, key: ms_app_main, code: 0x67 },
];
var keys260_0 = new Uint8Array([0xC3, 0x24, 0x89, 0xD3, 0x80, 0x87, 0xB2, 0x4E, 0x4C, 0xD7, 0x49, 0xE4, 0x9D, 0x1D, 0x34, 0xD1]);
var keys260_1 = new Uint8Array([0xF3, 0xAC, 0x6E, 0x7C, 0x04, 0x0A, 0x23, 0xE7, 0x0D, 0x33, 0xD8, 0x24, 0x73, 0x39, 0x2B, 0x4A]);
var keys260_2 = new Uint8Array([0x72, 0xB4, 0x39, 0xFF, 0x34, 0x9B, 0xAE, 0x82, 0x30, 0x34, 0x4A, 0x1D, 0xA2, 0xD8, 0xB4, 0x3C]);
var keys280_0 = new Uint8Array([0xCA, 0xFB, 0xBF, 0xC7, 0x50, 0xEA, 0xB4, 0x40, 0x8E, 0x44, 0x5C, 0x63, 0x53, 0xCE, 0x80, 0xB1]);
var keys280_1 = new Uint8Array([0x40, 0x9B, 0xC6, 0x9B, 0xA9, 0xFB, 0x84, 0x7F, 0x72, 0x21, 0xD2, 0x36, 0x96, 0x55, 0x09, 0x74]);
var keys280_2 = new Uint8Array([0x03, 0xA7, 0xCC, 0x4A, 0x5B, 0x91, 0xC2, 0x07, 0xFF, 0xFC, 0x26, 0x25, 0x1E, 0x42, 0x4B, 0xB5]);
var keys300_0 = new Uint8Array([0x9F, 0x67, 0x1A, 0x7A, 0x22, 0xF3, 0x59, 0x0B, 0xAA, 0x6D, 0xA4, 0xC6, 0x8B, 0xD0, 0x03, 0x77]);
var keys300_1 = new Uint8Array([0x15, 0x07, 0x63, 0x26, 0xDB, 0xE2, 0x69, 0x34, 0x56, 0x08, 0x2A, 0x93, 0x4E, 0x4B, 0x8A, 0xB2]);
var keys300_2 = new Uint8Array([0x56, 0x3B, 0x69, 0xF7, 0x29, 0x88, 0x2F, 0x4C, 0xDB, 0xD5, 0xDE, 0x80, 0xC6, 0x5C, 0xC8, 0x73]);
var keys303_0 = new Uint8Array([0x7b, 0xa1, 0xe2, 0x5a, 0x91, 0xb9, 0xd3, 0x13, 0x77, 0x65, 0x4a, 0xb7, 0xc2, 0x8a, 0x10, 0xaf]);
var keys310_0 = new Uint8Array([0xa2, 0x41, 0xe8, 0x39, 0x66, 0x5b, 0xfa, 0xbb, 0x1b, 0x2d, 0x6e, 0x0e, 0x33, 0xe5, 0xd7, 0x3f]);
var keys310_1 = new Uint8Array([0xA4, 0x60, 0x8F, 0xAB, 0xAB, 0xDE, 0xA5, 0x65, 0x5D, 0x43, 0x3A, 0xD1, 0x5E, 0xC3, 0xFF, 0xEA]);
var keys310_2 = new Uint8Array([0xE7, 0x5C, 0x85, 0x7A, 0x59, 0xB4, 0xE3, 0x1D, 0xD0, 0x9E, 0xCE, 0xC2, 0xD6, 0xD4, 0xBD, 0x2B]);
var keys310_3 = new Uint8Array([0x2E, 0x00, 0xF6, 0xF7, 0x52, 0xCF, 0x95, 0x5A, 0xA1, 0x26, 0xB4, 0x84, 0x9B, 0x58, 0x76, 0x2F]);
var keys330_0 = new Uint8Array([0x3B, 0x9B, 0x1A, 0x56, 0x21, 0x80, 0x14, 0xED, 0x8E, 0x8B, 0x08, 0x42, 0xFA, 0x2C, 0xDC, 0x3A]);
var keys330_1 = new Uint8Array([0xE8, 0xBE, 0x2F, 0x06, 0xB1, 0x05, 0x2A, 0xB9, 0x18, 0x18, 0x03, 0xE3, 0xEB, 0x64, 0x7D, 0x26]);
var keys330_2 = new Uint8Array([0xAB, 0x82, 0x25, 0xD7, 0x43, 0x6F, 0x6C, 0xC1, 0x95, 0xC5, 0xF7, 0xF0, 0x63, 0x73, 0x3F, 0xE7]);
var keys330_3 = new Uint8Array([0xA8, 0xB1, 0x47, 0x77, 0xDC, 0x49, 0x6A, 0x6F, 0x38, 0x4C, 0x4D, 0x96, 0xBD, 0x49, 0xEC, 0x9B]);
var keys330_4 = new Uint8Array([0xEC, 0x3B, 0xD2, 0xC0, 0xFA, 0xC1, 0xEE, 0xB9, 0x9A, 0xBC, 0xFF, 0xA3, 0x89, 0xF2, 0x60, 0x1F]);
var demokeys_280 = new Uint8Array([0x12, 0x99, 0x70, 0x5E, 0x24, 0x07, 0x6C, 0xD0, 0x2D, 0x06, 0xFE, 0x7E, 0xB3, 0x0C, 0x11, 0x26]);
var demokeys_3XX_1 = new Uint8Array([0x47, 0x05, 0xD5, 0xE3, 0x56, 0x1E, 0x81, 0x9B, 0x09, 0x2F, 0x06, 0xDB, 0x6B, 0x12, 0x92, 0xE0]);
var demokeys_3XX_2 = new Uint8Array([0xF6, 0x62, 0x39, 0x6E, 0x26, 0x22, 0x4D, 0xCA, 0x02, 0x64, 0x16, 0x99, 0x7B, 0x9A, 0xE7, 0xB8]);
var ebootbin_271_new = new Uint8Array([0xF4, 0xAE, 0xF4, 0xE1, 0x86, 0xDD, 0xD2, 0x9C, 0x7C, 0xC5, 0x42, 0xA6, 0x95, 0xA0, 0x83, 0x88]);
var ebootbin_280_new = new Uint8Array([0xB8, 0x8C, 0x45, 0x8B, 0xB6, 0xE7, 0x6E, 0xB8, 0x51, 0x59, 0xA6, 0x53, 0x7C, 0x5E, 0x86, 0x31]);
var ebootbin_300_new = new Uint8Array([0xED, 0x10, 0xE0, 0x36, 0xC4, 0xFE, 0x83, 0xF3, 0x75, 0x70, 0x5E, 0xF6, 0xA4, 0x40, 0x05, 0xF7]);
var ebootbin_310_new = new Uint8Array([0x5C, 0x77, 0x0C, 0xBB, 0xB4, 0xC2, 0x4F, 0xA2, 0x7E, 0x3B, 0x4E, 0xB4, 0xB4, 0xC8, 0x70, 0xAF]);
var gameshare_260_271 = new Uint8Array([0xF9, 0x48, 0x38, 0x0C, 0x96, 0x88, 0xA7, 0x74, 0x4F, 0x65, 0xA0, 0x54, 0xC2, 0x76, 0xD9, 0xB8]);
var gameshare_280 = new Uint8Array([0x2D, 0x86, 0x77, 0x3A, 0x56, 0xA4, 0x4F, 0xDD, 0x3C, 0x16, 0x71, 0x93, 0xAA, 0x8E, 0x11, 0x43]);
var gameshare_300 = new Uint8Array([0x78, 0x1A, 0xD2, 0x87, 0x24, 0xBD, 0xA2, 0x96, 0x18, 0x3F, 0x89, 0x36, 0x72, 0x90, 0x92, 0x85]);
var gameshare_310 = new Uint8Array([0xC9, 0x7D, 0x3E, 0x0A, 0x54, 0x81, 0x6E, 0xC7, 0x13, 0x74, 0x99, 0x74, 0x62, 0x18, 0xE7, 0xDD]);
var keys360_0 = new Uint8Array([0x3C, 0x2B, 0x51, 0xD4, 0x2D, 0x85, 0x47, 0xDA, 0x2D, 0xCA, 0x18, 0xDF, 0xFE, 0x54, 0x09, 0xED]);
var keys360_1 = new Uint8Array([0x31, 0x1F, 0x98, 0xD5, 0x7B, 0x58, 0x95, 0x45, 0x32, 0xAB, 0x3A, 0xE3, 0x89, 0x32, 0x4B, 0x34]);
var keys370_0 = new Uint8Array([0x26, 0x38, 0x0A, 0xAC, 0xA5, 0xD8, 0x74, 0xD1, 0x32, 0xB7, 0x2A, 0xBF, 0x79, 0x9E, 0x6D, 0xDB]);
var keys370_1 = new Uint8Array([0x53, 0xE7, 0xAB, 0xB9, 0xC6, 0x4A, 0x4B, 0x77, 0x92, 0x17, 0xB5, 0x74, 0x0A, 0xDA, 0xA9, 0xEA]);
var keys370_2 = new Uint8Array([0x71, 0x10, 0xF0, 0xA4, 0x16, 0x14, 0xD5, 0x93, 0x12, 0xFF, 0x74, 0x96, 0xDF, 0x1F, 0xDA, 0x89]);
var oneseg_310 = new Uint8Array([0xC7, 0x27, 0x72, 0x85, 0xAB, 0xA7, 0xF7, 0xF0, 0x4C, 0xC1, 0x86, 0xCC, 0xE3, 0x7F, 0x17, 0xCA]);
var oneseg_300 = new Uint8Array([0x76, 0x40, 0x9E, 0x08, 0xDB, 0x9B, 0x3B, 0xA1, 0x47, 0x8A, 0x96, 0x8E, 0xF3, 0xF7, 0x62, 0x92]);
var oneseg_280 = new Uint8Array([0x23, 0xDC, 0x3B, 0xB5, 0xA9, 0x82, 0xD6, 0xEA, 0x63, 0xA3, 0x6E, 0x2B, 0x2B, 0xE9, 0xE1, 0x54]);
var oneseg_260_271 = new Uint8Array([0x22, 0x43, 0x57, 0x68, 0x2F, 0x41, 0xCE, 0x65, 0x4C, 0xA3, 0x7C, 0xC6, 0xC4, 0xAC, 0xF3, 0x60]);
var oneseg_slim = new Uint8Array([0x12, 0x57, 0x0D, 0x8A, 0x16, 0x6D, 0x87, 0x06, 0x03, 0x7D, 0xC8, 0x8B, 0x62, 0xA3, 0x32, 0xA9]);
var ms_app_main = new Uint8Array([0x1E, 0x2E, 0x38, 0x49, 0xDA, 0xD4, 0x16, 0x08, 0x27, 0x2E, 0xF3, 0xBC, 0x37, 0x75, 0x80, 0x93]);
var keys390_0 = new Uint8Array([0x45, 0xEF, 0x5C, 0x5D, 0xED, 0x81, 0x99, 0x84, 0x12, 0x94, 0x8F, 0xAB, 0xE8, 0x05, 0x6D, 0x7D]);
var keys390_1 = new Uint8Array([0x70, 0x1B, 0x08, 0x25, 0x22, 0xA1, 0x4D, 0x3B, 0x69, 0x21, 0xF9, 0x71, 0x0A, 0xA8, 0x41, 0xA9]);
var keys500_0 = new Uint8Array([0xEB, 0x1B, 0x53, 0x0B, 0x62, 0x49, 0x32, 0x58, 0x1F, 0x83, 0x0A, 0xF4, 0x99, 0x3D, 0x75, 0xD0]);
var keys500_1 = new Uint8Array([0xBA, 0xE2, 0xA3, 0x12, 0x07, 0xFF, 0x04, 0x1B, 0x64, 0xA5, 0x11, 0x85, 0xF7, 0x2F, 0x99, 0x5B]);
var keys500_2 = new Uint8Array([0x2C, 0x8E, 0xAF, 0x1D, 0xFF, 0x79, 0x73, 0x1A, 0xAD, 0x96, 0xAB, 0x09, 0xEA, 0x35, 0x59, 0x8B]);
var keys500_c = new Uint8Array([0xA3, 0x5D, 0x51, 0xE6, 0x56, 0xC8, 0x01, 0xCA, 0xE3, 0x77, 0xBF, 0xCD, 0xFF, 0x24, 0xDA, 0x4D]);
var keys505_a = new Uint8Array([0x7B, 0x94, 0x72, 0x27, 0x4C, 0xCC, 0x54, 0x3B, 0xAE, 0xDF, 0x46, 0x37, 0xAC, 0x01, 0x4D, 0x87]);
var keys505_0 = new Uint8Array([0x2E, 0x8E, 0x97, 0xA2, 0x85, 0x42, 0x70, 0x73, 0x18, 0xDA, 0xA0, 0x8A, 0xF8, 0x62, 0xA2, 0xB0]);
var keys505_1 = new Uint8Array([0x58, 0x2A, 0x4C, 0x69, 0x19, 0x7B, 0x83, 0x3D, 0xD2, 0x61, 0x61, 0xFE, 0x14, 0xEE, 0xAA, 0x11]);
var keys02G_E = new Uint8Array([0x9D, 0x09, 0xFD, 0x20, 0xF3, 0x8F, 0x10, 0x69, 0x0D, 0xB2, 0x6F, 0x00, 0xCC, 0xC5, 0x51, 0x2E]);
var keys03G_E = new Uint8Array([0x4F, 0x44, 0x5C, 0x62, 0xB3, 0x53, 0xC4, 0x30, 0xFC, 0x3A, 0xA4, 0x5B, 0xEC, 0xFE, 0x51, 0xEA]);
var key_D91609F0 = new Uint8Array([0xD0, 0x36, 0x12, 0x75, 0x80, 0x56, 0x20, 0x43, 0xC4, 0x30, 0x94, 0x3E, 0x1C, 0x75, 0xD1, 0xBF]);
var key_D9160AF0 = new Uint8Array([0x10, 0xA9, 0xAC, 0x16, 0xAE, 0x19, 0xC0, 0x7E, 0x3B, 0x60, 0x77, 0x86, 0x01, 0x6F, 0xF2, 0x63]);
var key_D9160BF0 = new Uint8Array([0x83, 0x83, 0xF1, 0x37, 0x53, 0xD0, 0xBE, 0xFC, 0x8D, 0xA7, 0x32, 0x52, 0x46, 0x0A, 0xC2, 0xC2]);
var key_D91611F0 = new Uint8Array([0x61, 0xB0, 0xC0, 0x58, 0x71, 0x57, 0xD9, 0xFA, 0x74, 0x67, 0x0E, 0x5C, 0x7E, 0x6E, 0x95, 0xB9]);
var key_D91612F0 = new Uint8Array([0x9E, 0x20, 0xE1, 0xCD, 0xD7, 0x88, 0xDE, 0xC0, 0x31, 0x9B, 0x10, 0xAF, 0xC5, 0xB8, 0x73, 0x23]);
var key_D91613F0 = new Uint8Array([0xEB, 0xFF, 0x40, 0xD8, 0xB4, 0x1A, 0xE1, 0x66, 0x91, 0x3B, 0x8F, 0x64, 0xB6, 0xFC, 0xB7, 0x12]);
var key_2E5E10F0 = new Uint8Array([0x9D, 0x5C, 0x5B, 0xAF, 0x8C, 0xD8, 0x69, 0x7E, 0x51, 0x9F, 0x70, 0x96, 0xE6, 0xD5, 0xC4, 0xE8]);
var key_2E5E12F0 = new Uint8Array([0x8A, 0x7B, 0xC9, 0xD6, 0x52, 0x58, 0x88, 0xEA, 0x51, 0x83, 0x60, 0xCA, 0x16, 0x79, 0xE2, 0x07]);
var key_2E5E13F0 = new Uint8Array([0xFF, 0xA4, 0x68, 0xC3, 0x31, 0xCA, 0xB7, 0x4C, 0xF1, 0x23, 0xFF, 0x01, 0x65, 0x3D, 0x26, 0x36]);
var keys600_u1_457B0BF0 = new Uint8Array([0x7B, 0x94, 0x72, 0x27, 0x4C, 0xCC, 0x54, 0x3B, 0xAE, 0xDF, 0x46, 0x37, 0xAC, 0x01, 0x4D, 0x87]);
var keys600_u1_457B0CF0 = new Uint8Array([0xAC, 0x34, 0xBA, 0xB1, 0x97, 0x8D, 0xAE, 0x6F, 0xBA, 0xE8, 0xB1, 0xD6, 0xDF, 0xDF, 0xF1, 0xA2]);
var keys05G_E = new Uint8Array([0x5D, 0xAA, 0x72, 0xF2, 0x26, 0x60, 0x4D, 0x1C, 0xE7, 0x2D, 0xC8, 0xA3, 0x2F, 0x79, 0xC5, 0x54]);
var keys570_5k = new Uint8Array([0x6D, 0x72, 0xA4, 0xBA, 0x7F, 0xBF, 0xD1, 0xF1, 0xA9, 0xF3, 0xBB, 0x07, 0x1B, 0xC0, 0xB3, 0x66]);
var keys620_0 = new Uint8Array([0xD6, 0xBD, 0xCE, 0x1E, 0x12, 0xAF, 0x9A, 0xE6, 0x69, 0x30, 0xDE, 0xDA, 0x88, 0xB8, 0xFF, 0xFB]);
var keys620_1 = new Uint8Array([0x1D, 0x13, 0xE9, 0x50, 0x04, 0x73, 0x3D, 0xD2, 0xE1, 0xDA, 0xB9, 0xC1, 0xE6, 0x7B, 0x25, 0xA7]);
var keys620_3 = new Uint8Array([0xA3, 0x5D, 0x51, 0xE6, 0x56, 0xC8, 0x01, 0xCA, 0xE3, 0x77, 0xBF, 0xCD, 0xFF, 0x24, 0xDA, 0x4D]);
var keys620_e = new Uint8Array([0xB1, 0xB3, 0x7F, 0x76, 0xC3, 0xFB, 0x88, 0xE6, 0xF8, 0x60, 0xD3, 0x35, 0x3C, 0xA3, 0x4E, 0xF3]);
var keys620_5 = new Uint8Array([0xF1, 0xBC, 0x17, 0x07, 0xAE, 0xB7, 0xC8, 0x30, 0xD8, 0x34, 0x9D, 0x40, 0x6A, 0x8E, 0xDF, 0x4E]);
var keys620_5k = new Uint8Array([0x41, 0x8A, 0x35, 0x4F, 0x69, 0x3A, 0xDF, 0x04, 0xFD, 0x39, 0x46, 0xA2, 0x5C, 0x2D, 0xF2, 0x21]);
var keys620_5v = new Uint8Array([0xF2, 0x8F, 0x75, 0xA7, 0x31, 0x91, 0xCE, 0x9E, 0x75, 0xBD, 0x27, 0x26, 0xB4, 0xB4, 0x0C, 0x32]);

},
"src/hle/elf_psp": function(module, exports, require) {
var _cpu = require('../core/cpu');
var _format_elf = require('../format/elf');
var _format_elf_dwarf = require('../format/elf_dwarf');
var NativeFunction = _cpu.NativeFunction;
var MipsAssembler = _cpu.MipsAssembler;
var Instruction = _cpu.Instruction;
var ElfLoader = _format_elf.ElfLoader;
var ElfSectionHeaderFlags = _format_elf.ElfSectionHeaderFlags;
var ElfSectionHeaderType = _format_elf.ElfSectionHeaderType;
var ElfReloc = _format_elf.ElfReloc;
var ElfRelocType = _format_elf.ElfRelocType;
var ElfProgramHeaderType = _format_elf.ElfProgramHeaderType;
var ElfDwarfLoader = _format_elf_dwarf.ElfDwarfLoader;
var console = logger.named('elf.psp');
var ElfPspModuleInfo = (function () {
    function ElfPspModuleInfo() {
    }
    ElfPspModuleInfo.struct = StructClass.create(ElfPspModuleInfo, [
        { moduleAtributes: UInt16 },
        { moduleVersion: UInt16 },
        { name: Stringz(28) },
        { gp: UInt32 },
        { exportsStart: UInt32 },
        { exportsEnd: UInt32 },
        { importsStart: UInt32 },
        { importsEnd: UInt32 },
    ]);
    return ElfPspModuleInfo;
})();
exports.ElfPspModuleInfo = ElfPspModuleInfo;
var ElfPspModuleImport = (function () {
    function ElfPspModuleImport() {
    }
    ElfPspModuleImport.struct = StructClass.create(ElfPspModuleImport, [
        { nameOffset: UInt32 },
        { version: UInt16 },
        { flags: UInt16 },
        { entrySize: UInt8 },
        { variableCount: UInt8 },
        { functionCount: UInt16 },
        { nidAddress: UInt32 },
        { callAddress: UInt32 },
    ]);
    return ElfPspModuleImport;
})();
exports.ElfPspModuleImport = ElfPspModuleImport;
var ElfPspModuleExport = (function () {
    function ElfPspModuleExport() {
    }
    ElfPspModuleExport.struct = StructClass.create(ElfPspModuleExport, [
        { name: UInt32 },
        { version: UInt16 },
        { flags: UInt16 },
        { entrySize: UInt8 },
        { variableCount: UInt8 },
        { functionCount: UInt16 },
        { exports: UInt32 },
    ]);
    return ElfPspModuleExport;
})();
exports.ElfPspModuleExport = ElfPspModuleExport;
(function (ElfPspModuleInfoAtributesEnum) {
    ElfPspModuleInfoAtributesEnum[ElfPspModuleInfoAtributesEnum["UserMode"] = 0] = "UserMode";
    ElfPspModuleInfoAtributesEnum[ElfPspModuleInfoAtributesEnum["KernelMode"] = 256] = "KernelMode";
})(exports.ElfPspModuleInfoAtributesEnum || (exports.ElfPspModuleInfoAtributesEnum = {}));
var ElfPspModuleInfoAtributesEnum = exports.ElfPspModuleInfoAtributesEnum;
var InstructionReader = (function () {
    function InstructionReader(memory) {
        this.memory = memory;
    }
    InstructionReader.prototype.read = function (address) {
        return new Instruction(address, this.memory.readUInt32(address));
    };
    InstructionReader.prototype.write = function (address, instruction) {
        this.memory.writeInt32(address, instruction.data);
    };
    return InstructionReader;
})();
var PspElfLoader = (function () {
    function PspElfLoader(memory, memoryManager, moduleManager, syscallManager) {
        this.memory = memory;
        this.memoryManager = memoryManager;
        this.moduleManager = moduleManager;
        this.syscallManager = syscallManager;
        this.assembler = new MipsAssembler();
        this.baseAddress = 0;
    }
    PspElfLoader.prototype.load = function (stream) {
        this.elfLoader = ElfLoader.fromStream(stream);
        this.allocateMemory();
        this.writeToMemory();
        this.relocateFromHeaders();
        this.readModuleInfo();
        this.updateModuleImports();
        this.elfDwarfLoader = new ElfDwarfLoader();
        this.elfDwarfLoader.parseElfLoader(this.elfLoader);
    };
    PspElfLoader.prototype.getSymbolAt = function (address) {
        return this.elfDwarfLoader.getSymbolAt(address);
    };
    PspElfLoader.prototype.getSectionHeaderMemoryStream = function (sectionHeader) {
        return this.memory.getPointerStream(this.baseAddress + sectionHeader.address, sectionHeader.size);
    };
    PspElfLoader.prototype.readModuleInfo = function () {
        this.moduleInfo = ElfPspModuleInfo.struct.read(this.getSectionHeaderMemoryStream(this.elfLoader.sectionHeadersByName['.rodata.sceModuleInfo']));
        this.moduleInfo.pc = this.baseAddress + this.elfLoader.header.entryPoint;
    };
    PspElfLoader.prototype.allocateMemory = function () {
        var _this = this;
        this.baseAddress = 0;
        if (this.elfLoader.needsRelocation) {
            this.baseAddress = this.memoryManager.userPartition.childPartitions.sortBy(function (partition) { return partition.size; }).reverse().first().low;
            this.baseAddress = MathUtils.nextAligned(this.baseAddress, 0x1000);
        }
        var lowest = 0xFFFFFFFF;
        var highest = 0;
        this.elfLoader.sectionHeaders.filter(function (section) { return ((section.flags & ElfSectionHeaderFlags.Allocate) != 0); }).forEach(function (section) {
            lowest = Math.min(lowest, (_this.baseAddress + section.address));
            highest = Math.max(highest, (_this.baseAddress + section.address + section.size));
        });
        this.elfLoader.programHeaders.forEach(function (program) {
            lowest = Math.min(lowest, (_this.baseAddress + program.virtualAddress));
            highest = Math.max(highest, (_this.baseAddress + program.virtualAddress + program.memorySize));
        });
        var memorySegment = this.memoryManager.userPartition.allocateSet(highest - lowest, lowest, 'Elf');
    };
    PspElfLoader.prototype.relocateFromHeaders = function () {
        var _this = this;
        var RelocProgramIndex = 0;
        this.elfLoader.programHeaders.forEach(function (programHeader) {
            switch (programHeader.type) {
                case ElfProgramHeaderType.Reloc1:
                    console.warn("SKIPPING Elf.ProgramHeader.TypeEnum.Reloc1!");
                    break;
                case ElfProgramHeaderType.Reloc2:
                    throw ("Not implemented");
            }
        });
        var RelocSectionIndex = 0;
        this.elfLoader.sectionHeaders.forEach(function (sectionHeader) {
            //RelocOutput.WriteLine("Section Header: %d : %s".Sprintf(RelocSectionIndex++, SectionHeader.ToString()));
            //console.info(sprintf('Section Header: '));
            switch (sectionHeader.type) {
                case ElfSectionHeaderType.Relocation:
                    console.log(sectionHeader);
                    console.error("Not implemented ElfSectionHeaderType.Relocation");
                    break;
                case ElfSectionHeaderType.PrxRelocation:
                    var relocs = StructArray(ElfReloc.struct, sectionHeader.stream.length / ElfReloc.struct.length).read(sectionHeader.stream);
                    _this.relocateRelocs(relocs);
                    break;
                case ElfSectionHeaderType.PrxRelocation_FW5:
                    throw ("Not implemented ElfSectionHeader.Type.PrxRelocation_FW5");
            }
        });
    };
    PspElfLoader.prototype.relocateRelocs = function (relocs) {
        var baseAddress = this.baseAddress;
        var hiValue;
        var deferredHi16 = [];
        var instructionReader = new InstructionReader(this.memory);
        for (var index = 0; index < relocs.length; index++) {
            var reloc = relocs[index];
            if (reloc.type == ElfRelocType.StopRelocation)
                break;
            var pointerBaseOffset = this.elfLoader.programHeaders[reloc.pointerSectionHeaderBase].virtualAddress;
            var pointeeBaseOffset = this.elfLoader.programHeaders[reloc.pointeeSectionHeaderBase].virtualAddress;
            var RelocatedPointerAddress = (baseAddress + reloc.pointerAddress + pointerBaseOffset);
            var instruction = instructionReader.read(RelocatedPointerAddress);
            var S = baseAddress + pointeeBaseOffset;
            var GP_ADDR = (baseAddress + reloc.pointerAddress);
            var GP_OFFSET = GP_ADDR - (baseAddress & 0xFFFF0000);
            switch (reloc.type) {
                case ElfRelocType.None: break;
                case ElfRelocType.Mips16:
                    instruction.u_imm16 += S;
                    break;
                case ElfRelocType.Mips32:
                    instruction.data += S;
                    break;
                case ElfRelocType.MipsRel32: throw ("Not implemented MipsRel32");
                case ElfRelocType.Mips26:
                    instruction.jump_real = instruction.jump_real + S;
                    break;
                case ElfRelocType.MipsHi16:
                    hiValue = instruction.u_imm16;
                    deferredHi16.push(RelocatedPointerAddress);
                    break;
                case ElfRelocType.MipsLo16:
                    var A = instruction.u_imm16;
                    instruction.u_imm16 = ((hiValue << 16) | (A & 0x0000FFFF)) + S;
                    deferredHi16.forEach(function (data_addr2) {
                        var data2 = instructionReader.read(data_addr2);
                        var result = ((data2.data & 0x0000FFFF) << 16) + A + S;
                        if ((A & 0x8000) != 0) {
                            result -= 0x10000;
                        }
                        if ((result & 0x8000) != 0) {
                            result += 0x10000;
                        }
                        data2.u_imm16 = (result >>> 16);
                        instructionReader.write(data_addr2, data2);
                    });
                    deferredHi16 = [];
                    break;
                case ElfRelocType.MipsGpRel16:
                    break;
                default: throw (new Error(sprintf("RelocType %d not implemented", reloc.type)));
            }
            instructionReader.write(RelocatedPointerAddress, instruction);
        }
    };
    PspElfLoader.prototype.writeToMemory = function () {
        var _this = this;
        var needsRelocate = this.elfLoader.needsRelocation;
        var loadAddress = this.baseAddress;
        console.info(sprintf("PspElfLoader: needsRelocate=%s, loadAddress=%08X", needsRelocate, loadAddress));
        this.elfLoader.programHeaders.filter(function (programHeader) { return (programHeader.type == 1); }).forEach(function (programHeader) {
            var fileOffset = programHeader.offset;
            var memOffset = _this.baseAddress + programHeader.virtualAddress;
            var fileSize = programHeader.fileSize;
            var memSize = programHeader.memorySize;
            _this.elfLoader.stream.sliceWithLength(fileOffset, fileSize).copyTo(_this.memory.getPointerStream(memOffset, fileSize));
            _this.memory.memset(memOffset + fileSize, 0, memSize - fileSize);
            console.info('Program Header: ', sprintf("%08X:%08X, %08X:%08X", fileOffset, fileSize, memOffset, memSize));
        });
        this.elfLoader.sectionHeaders.filter(function (sectionHeader) { return ((sectionHeader.flags & ElfSectionHeaderFlags.Allocate) != 0); }).forEach(function (sectionHeader) {
            var low = loadAddress + sectionHeader.address;
            console.info('Section Header: ', sectionHeader, sprintf('LOW:%08X, SIZE:%08X', low, sectionHeader.size));
            switch (sectionHeader.type) {
                case ElfSectionHeaderType.NoBits:
                    for (var n = 0; n < sectionHeader.size; n++)
                        _this.memory.writeInt8(low + n, 0);
                    break;
                default:
                    break;
                case ElfSectionHeaderType.ProgramBits:
                    var stream = sectionHeader.stream;
                    var length = stream.length;
                    _this.memory.writeStream(low, stream);
                    break;
            }
        });
    };
    PspElfLoader.prototype.updateModuleImports = function () {
        var _this = this;
        var moduleInfo = this.moduleInfo;
        console.log(moduleInfo);
        var importsBytesSize = moduleInfo.importsEnd - moduleInfo.importsStart;
        var importsStream = this.memory.sliceWithBounds(moduleInfo.importsStart, moduleInfo.importsEnd);
        var importsCount = importsBytesSize / ElfPspModuleImport.struct.length;
        var imports = StructArray(ElfPspModuleImport.struct, importsCount).read(importsStream);
        imports.forEach(function (_import) {
            _import.name = _this.memory.readStringz(_import.nameOffset);
            var imported = _this.updateModuleFunctions(_import);
            _this.updateModuleVars(_import);
            console.info('Imported: ', imported.name, imported.registeredNativeFunctions.map(function (i) { return i.name; }));
        });
    };
    PspElfLoader.prototype.updateModuleFunctions = function (moduleImport) {
        var _this = this;
        var _module = this.moduleManager.getByName(moduleImport.name);
        var nidsStream = this.memory.sliceWithSize(moduleImport.nidAddress, moduleImport.functionCount * 4);
        var callStream = this.memory.sliceWithSize(moduleImport.callAddress, moduleImport.functionCount * 8);
        var registeredNativeFunctions = [];
        var unknownFunctions = [];
        var registerN = function (nid, n) {
            var nfunc;
            nfunc = _module.getByNid(nid);
            if (!nfunc) {
                unknownFunctions.push(sprintf("'%s':0x%08X", _module.moduleName, nid));
                nfunc = new NativeFunction();
                nfunc.name = sprintf("%s:0x%08X", moduleImport.name, nid);
                nfunc.nid = nid;
                nfunc.firmwareVersion = 150;
                nfunc.nativeCall = function () {
                    console.info(_module);
                    throw (new Error("updateModuleFunctions: Not implemented '" + nfunc.name + "'"));
                };
                nfunc.call = function (context, state) {
                    nfunc.nativeCall();
                };
            }
            registeredNativeFunctions.push(nfunc);
            var syscallId = _this.syscallManager.register(nfunc);
            return syscallId;
        };
        for (var n = 0; n < moduleImport.functionCount; n++) {
            var nid = nidsStream.readUInt32();
            var syscall = registerN(nid, n);
            callStream.writeInt32(this.assembler.assemble(0, sprintf('jr $31'))[0].data);
            callStream.writeInt32(this.assembler.assemble(0, sprintf('syscall %d', syscall))[0].data);
        }
        console.warn("Can't find functions", unknownFunctions);
        return {
            name: moduleImport.name,
            registeredNativeFunctions: registeredNativeFunctions,
        };
    };
    PspElfLoader.prototype.updateModuleVars = function (moduleImport) {
    };
    return PspElfLoader;
})();
exports.PspElfLoader = PspElfLoader;

},
"src/hle/manager": function(module, exports, require) {
var _file = require('./manager/file');
_file.Device;
var _memory = require('./manager/memory');
_memory.MemoryManager;
var _module = require('./manager/module');
_module.ModuleManager;
var _thread = require('./manager/thread');
_thread.Thread;
var _callback = require('./manager/callback');
_callback.Callback;
var _interop = require('./manager/interop');
_interop.Interop;
var _net = require('./manager/net');
_net.NetManager;
exports.Device = _file.Device;
exports.FileManager = _file.FileManager;
exports.HleDirectory = _file.HleDirectory;
exports.HleFile = _file.HleFile;
exports.Uri = _file.Uri;
exports.MemoryAnchor = _memory.MemoryAnchor;
exports.MemoryManager = _memory.MemoryManager;
exports.MemoryPartition = _memory.MemoryPartition;
exports.OutOfMemoryError = _memory.OutOfMemoryError;
exports.ModuleManager = _module.ModuleManager;
exports.ModuleWrapper = _module.ModuleWrapper;
exports.Thread = _thread.Thread;
exports.ThreadManager = _thread.ThreadManager;
exports.ThreadStatus = _thread.ThreadStatus;
exports.PspThreadAttributes = _thread.PspThreadAttributes;
exports.Callback = _callback.Callback;
exports.CallbackManager = _callback.CallbackManager;
exports.Interop = _interop.Interop;
exports.NetManager = _net.NetManager;

},
"src/hle/manager/callback": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var CallbackManager = (function () {
    function CallbackManager(interop) {
        this.interop = interop;
        this.uids = new UidCollection(1);
        this.notifications = [];
        this.onAdded = new Signal();
        this.normalCallbacks = [];
    }
    Object.defineProperty(CallbackManager.prototype, "hasPendingCallbacks", {
        get: function () {
            return this.notifications.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    CallbackManager.prototype.register = function (callback) {
        return this.uids.allocate(callback);
    };
    CallbackManager.prototype.remove = function (id) {
        return this.uids.remove(id);
    };
    CallbackManager.prototype.get = function (id) {
        return this.uids.get(id);
    };
    CallbackManager.prototype.executeLater = function (callback, args) {
        this.normalCallbacks.push({ callback: callback, args: args });
    };
    CallbackManager.prototype.notify = function (id, arg2) {
        var callback = this.get(id);
        this.notifications.push(new CallbackNotification(callback, arg2));
        this.onAdded.dispatch(this.notifications.length);
    };
    CallbackManager.prototype.executeLaterPendingWithinThread = function (thread) {
        var state = thread.state;
        while (this.normalCallbacks.length > 0) {
            var normalCallback = this.normalCallbacks.shift();
            this.interop.execute(state, normalCallback.callback, normalCallback.args);
        }
    };
    CallbackManager.prototype.executePendingWithinThread = function (thread) {
        var state = thread.state;
        var count = 0;
        this.executeLaterPendingWithinThread(thread);
        while (this.notifications.length > 0) {
            var notification = this.notifications.shift();
            this.interop.execute(state, notification.callback.funcptr, [1, notification.arg2, notification.callback.argument]);
            count++;
        }
        return (count > 0);
    };
    return CallbackManager;
})();
exports.CallbackManager = CallbackManager;
var CallbackNotification = (function () {
    function CallbackNotification(callback, arg2) {
        this.callback = callback;
        this.arg2 = arg2;
    }
    return CallbackNotification;
})();
exports.CallbackNotification = CallbackNotification;
var Callback = (function () {
    function Callback(name, funcptr, argument) {
        this.name = name;
        this.funcptr = funcptr;
        this.argument = argument;
        this.count = 0;
    }
    return Callback;
})();
exports.Callback = Callback;

},
"src/hle/manager/file": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var Device = (function () {
    function Device(name, vfs) {
        this.name = name;
        this.vfs = vfs;
        this.cwd = '';
    }
    Device.prototype.devctlAsync = function (command, input, output) {
        return this.vfs.devctlAsync(command, input, output);
    };
    Device.prototype.openAsync = function (uri, flags, mode) {
        return this.vfs.openAsync(uri.pathWithoutDevice, flags, mode);
    };
    Device.prototype.openDirectoryAsync = function (uri) {
        return this.vfs.openDirectoryAsync(uri.pathWithoutDevice);
    };
    Device.prototype.getStatAsync = function (uri) {
        return this.vfs.getStatAsync(uri.pathWithoutDevice);
    };
    return Device;
})();
exports.Device = Device;
var HleFile = (function () {
    function HleFile(entry) {
        this.entry = entry;
        this.cursor = 0;
        this._asyncResult = null;
        this._asyncPromise = null;
    }
    Object.defineProperty(HleFile.prototype, "asyncResult", {
        get: function () { return this._asyncResult; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HleFile.prototype, "asyncOperation", {
        get: function () {
            return this._asyncPromise;
        },
        enumerable: true,
        configurable: true
    });
    HleFile.prototype.startAsyncOperation = function () {
        this._asyncResult = null;
    };
    HleFile.prototype.setAsyncOperation = function (operation) {
        var _this = this;
        this._asyncResult = null;
        this._asyncPromise = operation.then(function (value) {
            _this._asyncResult = value;
            return value;
        });
    };
    HleFile.prototype.setAsyncOperationNow = function (value) {
        this._asyncResult = value;
        this._asyncPromise = Promise2.resolve(value);
    };
    HleFile.prototype.close = function () {
        this.entry.close();
    };
    return HleFile;
})();
exports.HleFile = HleFile;
var HleDirectory = (function () {
    function HleDirectory(childs) {
        this.childs = childs;
        this.cursor = 0;
    }
    HleDirectory.prototype.read = function () {
        return this.childs[this.cursor++];
    };
    Object.defineProperty(HleDirectory.prototype, "left", {
        get: function () {
            return this.childs.length - this.cursor;
        },
        enumerable: true,
        configurable: true
    });
    HleDirectory.prototype.close = function () {
    };
    return HleDirectory;
})();
exports.HleDirectory = HleDirectory;
var Uri = (function () {
    function Uri(path) {
        this.path = path;
    }
    Object.defineProperty(Uri.prototype, "device", {
        get: function () {
            return (this.path.split(':'))[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Uri.prototype, "pathWithoutDevice", {
        get: function () {
            return (this.path.split(':'))[1];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Uri.prototype, "isAbsolute", {
        get: function () {
            return this.path.contains(':');
        },
        enumerable: true,
        configurable: true
    });
    Uri.prototype.append = function (that) {
        if (that.isAbsolute)
            return that;
        return new Uri(this.path + '/' + that.path);
    };
    return Uri;
})();
exports.Uri = Uri;
var FileManager = (function () {
    function FileManager() {
        this.devices = {};
        this.cwd = new Uri('ms0:/');
    }
    FileManager.prototype.chdir = function (cwd) {
        this.cwd = new Uri(cwd);
    };
    FileManager.prototype.getDevice = function (name) {
        name = name.replace(/:$/, '');
        var device = this.devices[name];
        if (!device)
            throw (new Error(sprintf("Can't find device '%s'", name)));
        return device;
    };
    FileManager.prototype.openAsync = function (name, flags, mode) {
        var uri = this.cwd.append(new Uri(name));
        return this.getDevice(uri.device).openAsync(uri, flags, mode).then(function (entry) { return new HleFile(entry); });
    };
    FileManager.prototype.devctlAsync = function (deviceName, command, input, output) {
        return this.getDevice(deviceName).devctlAsync(command, input, output);
    };
    FileManager.prototype.openDirectoryAsync = function (name) {
        var uri = this.cwd.append(new Uri(name));
        return this.getDevice(uri.device).openDirectoryAsync(uri).then(function (entry) {
            return entry.enumerateAsync().then(function (items) {
                entry.close();
                return new HleDirectory(items);
            });
        });
    };
    FileManager.prototype.getStatAsync = function (name) {
        var uri = this.cwd.append(new Uri(name));
        return this.getDevice(uri.device).getStatAsync(uri);
    };
    FileManager.prototype.mount = function (device, vfs) {
        this.devices[device] = new Device(device, vfs);
    };
    return FileManager;
})();
exports.FileManager = FileManager;

},
"src/hle/manager/interop": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _cpu = require('../../core/cpu');
_cpu.CpuState;
var Interop = (function () {
    function Interop() {
    }
    Interop.prototype.execute = function (state, address, gprArray) {
        state.preserveRegisters(function () {
            state.setRA(0x1234);
            for (var n = 0; n < gprArray.length; n++) {
                state.gpr[4 + n] = gprArray[n];
            }
            state.getFunction(address).execute(state);
        });
    };
    return Interop;
})();
exports.Interop = Interop;

},
"src/hle/manager/memory": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var MemoryPartitions;
(function (MemoryPartitions) {
    MemoryPartitions[MemoryPartitions["Kernel0"] = 0] = "Kernel0";
    MemoryPartitions[MemoryPartitions["User"] = 2] = "User";
    MemoryPartitions[MemoryPartitions["VolatilePartition"] = 5] = "VolatilePartition";
    MemoryPartitions[MemoryPartitions["UserStacks"] = 6] = "UserStacks";
})(MemoryPartitions || (MemoryPartitions = {}));
(function (MemoryAnchor) {
    MemoryAnchor[MemoryAnchor["Low"] = 0] = "Low";
    MemoryAnchor[MemoryAnchor["High"] = 1] = "High";
    MemoryAnchor[MemoryAnchor["Address"] = 2] = "Address";
    MemoryAnchor[MemoryAnchor["LowAligned"] = 3] = "LowAligned";
    MemoryAnchor[MemoryAnchor["HighAligned"] = 4] = "HighAligned";
})(exports.MemoryAnchor || (exports.MemoryAnchor = {}));
var MemoryAnchor = exports.MemoryAnchor;
var OutOfMemoryError = (function () {
    function OutOfMemoryError(message, name) {
        if (name === void 0) { name = 'OutOfMemoryError'; }
        this.message = message;
        this.name = name;
    }
    return OutOfMemoryError;
})();
exports.OutOfMemoryError = OutOfMemoryError;
var MemoryPartition = (function () {
    function MemoryPartition(name, low, high, allocated, parent) {
        this.name = name;
        this.low = low;
        this.high = high;
        this.allocated = allocated;
        this.parent = parent;
        this._childPartitions = [];
    }
    Object.defineProperty(MemoryPartition.prototype, "size", {
        get: function () { return this.high - this.low; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MemoryPartition.prototype, "root", {
        get: function () { return (this.parent) ? this.parent.root : this; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MemoryPartition.prototype, "childPartitions", {
        get: function () {
            if (this._childPartitions.length == 0)
                this._childPartitions.push(new MemoryPartition("", this.low, this.high, false));
            return this._childPartitions;
        },
        enumerable: true,
        configurable: true
    });
    MemoryPartition.prototype.contains = function (address) {
        return address >= this.low && address < this.high;
    };
    MemoryPartition.prototype.deallocate = function () {
        this.allocated = false;
        if (this.parent) {
            this.parent.cleanup();
        }
    };
    MemoryPartition.prototype.allocate = function (size, anchor, address, name) {
        if (address === void 0) { address = 0; }
        if (name === void 0) { name = ''; }
        switch (anchor) {
            case MemoryAnchor.LowAligned:
            case MemoryAnchor.Low: return this.allocateLow(size, name);
            case MemoryAnchor.High: return this.allocateHigh(size, name);
            case MemoryAnchor.Address: return this.allocateSet(size, address, name);
            default: throw (new Error(sprintf("Not implemented anchor %d:%s", anchor, MemoryAnchor[anchor])));
        }
    };
    MemoryPartition.prototype.allocateSet = function (size, addressLow, name) {
        if (name === void 0) { name = ''; }
        var childs = this.childPartitions;
        var addressHigh = addressLow + size;
        if (!this.contains(addressLow) || !this.contains(addressHigh)) {
            throw (new OutOfMemoryError(sprintf("Can't allocate [%08X-%08X] in [%08X-%08X]", addressLow, addressHigh, this.low, this.high)));
        }
        for (var n = 0; n < childs.length; n++) {
            var child = childs[n];
            if (!child.contains(addressLow))
                continue;
            if (child.allocated)
                throw (new Error("Memory already allocated"));
            if (!child.contains(addressHigh - 1))
                throw (new Error("Can't fit memory"));
            var p1 = new MemoryPartition('', child.low, addressLow, false, this);
            var p2 = new MemoryPartition(name, addressLow, addressHigh, true, this);
            var p3 = new MemoryPartition('', addressHigh, child.high, false, this);
            childs.splice(n, 1, p1, p2, p3);
            this.cleanup();
            return p2;
        }
        console.log(sprintf('address: %08X, size: %d', addressLow, size));
        console.log(this);
        throw (new Error("Can't find the segment"));
    };
    MemoryPartition.prototype.allocateLow = function (size, name) {
        if (name === void 0) { name = ''; }
        return this.allocateLowHigh(size, true, name);
    };
    MemoryPartition.prototype.allocateHigh = function (size, name, alignment) {
        if (name === void 0) { name = ''; }
        if (alignment === void 0) { alignment = 1; }
        return this.allocateLowHigh(size, false, name);
    };
    MemoryPartition.prototype._validateChilds = function () {
        var childs = this._childPartitions;
        if (childs[0].low != this.low)
            throw (new Error("Invalid state [1]"));
        if (childs[childs.length - 1].high != this.high)
            throw (new Error("Invalid state [2]"));
        for (var n = 0; n < childs.length - 1; n++) {
            if (childs[n + 0].high != childs[n + 1].low)
                throw (new Error("Invalid state [3] -> " + n));
        }
    };
    MemoryPartition.prototype.allocateLowHigh = function (size, low, name) {
        if (name === void 0) { name = ''; }
        var childs = this.childPartitions;
        for (var n = 0; n < childs.length; n++) {
            var child = childs[n];
            if (child.allocated)
                continue;
            if (child.size < size)
                continue;
            if (low) {
                var p1 = child.low;
                var p2 = child.low + size;
                var p3 = child.high;
                var allocatedChild = new MemoryPartition(name, p1, p2, true, this);
                var unallocatedChild = new MemoryPartition("", p2, p3, false, this);
                childs.splice(n, 1, allocatedChild, unallocatedChild);
            }
            else {
                var p1 = child.low;
                var p2 = child.high - size;
                var p3 = child.high;
                var unallocatedChild = new MemoryPartition("", p1, p2, false, this);
                var allocatedChild = new MemoryPartition(name, p2, p3, true, this);
                childs.splice(n, 1, unallocatedChild, allocatedChild);
            }
            this.cleanup();
            return allocatedChild;
        }
        throw (new OutOfMemoryError("Can't find a partition with " + size + " available"));
    };
    MemoryPartition.prototype.unallocate = function () {
        this.name = '';
        this.allocated = false;
        if (this.parent)
            this.parent.cleanup();
    };
    MemoryPartition.prototype.cleanup = function () {
        var startTotalFreeMemory = this.getTotalFreeMemory();
        var childs = this.childPartitions;
        if (childs.length >= 2) {
            for (var n = 0; n < childs.length - 1; n++) {
                var child = childs[n + 0];
                var c1 = childs[n + 1];
                if (!child.allocated && !c1.allocated) {
                    childs.splice(n, 2, new MemoryPartition("", child.low, c1.high, false, this));
                    n--;
                }
            }
        }
        for (var n = 0; n < childs.length; n++) {
            var child = childs[n];
            if (!child.allocated && child.size == 0)
                childs.splice(n, 1);
        }
        var endTotalFreeMemory = this.getTotalFreeMemory();
        if (endTotalFreeMemory != startTotalFreeMemory) {
            console.log('assertion failed! : ' + startTotalFreeMemory + ',' + endTotalFreeMemory);
        }
    };
    Object.defineProperty(MemoryPartition.prototype, "nonAllocatedPartitions", {
        get: function () {
            return this.childPartitions.filter(function (item) { return !item.allocated; });
        },
        enumerable: true,
        configurable: true
    });
    MemoryPartition.prototype.getTotalFreeMemory = function () {
        return this.nonAllocatedPartitions.reduce(function (prev, item) { return item.size + prev; }, 0);
    };
    MemoryPartition.prototype.getMaxContiguousFreeMemory = function () {
        return this.nonAllocatedPartitions.max(function (item) { return item.size; }).size;
    };
    MemoryPartition.prototype.findFreeChildWithSize = function (size) {
    };
    return MemoryPartition;
})();
exports.MemoryPartition = MemoryPartition;
var MemoryManager = (function () {
    function MemoryManager() {
        this.memoryPartitionsUid = {};
        this.init();
    }
    MemoryManager.prototype.init = function () {
        this.memoryPartitionsUid[MemoryPartitions.Kernel0] = new MemoryPartition("Kernel Partition 1", 0x88000000, 0x88300000, false);
        this.memoryPartitionsUid[MemoryPartitions.User] = new MemoryPartition("User Partition", 0x08800000, 0x08800000 + 0x100000 * 24, false);
        this.memoryPartitionsUid[MemoryPartitions.UserStacks] = new MemoryPartition("User Stacks Partition", 0x08800000, 0x08800000 + 0x100000 * 24, false);
        this.memoryPartitionsUid[MemoryPartitions.VolatilePartition] = new MemoryPartition("Volatile Partition", 0x08400000, 0x08800000, false);
    };
    Object.defineProperty(MemoryManager.prototype, "kernelPartition", {
        get: function () {
            return this.memoryPartitionsUid[MemoryPartitions.Kernel0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MemoryManager.prototype, "userPartition", {
        get: function () {
            return this.memoryPartitionsUid[MemoryPartitions.User];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MemoryManager.prototype, "stackPartition", {
        get: function () {
            return this.memoryPartitionsUid[MemoryPartitions.UserStacks];
        },
        enumerable: true,
        configurable: true
    });
    return MemoryManager;
})();
exports.MemoryManager = MemoryManager;

},
"src/hle/manager/module": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _cpu = require('../../core/cpu');
var NativeFunction = _cpu.NativeFunction;
var ModuleWrapper = (function () {
    function ModuleWrapper(moduleName, _modules) {
        var _this = this;
        this.moduleName = moduleName;
        this._modules = _modules;
        this.names = {};
        this.nids = {};
        _modules.forEach(function (_module) {
            for (var key in _module) {
                var item = _module[key];
                if (item && item instanceof NativeFunction) {
                    var nativeFunction = item;
                    nativeFunction.name = key;
                    _this.nids[nativeFunction.nid] = nativeFunction;
                    _this.names[nativeFunction.name] = nativeFunction;
                }
            }
        });
    }
    ModuleWrapper.prototype.getByName = function (name) {
        return this.names[name];
    };
    ModuleWrapper.prototype.getByNid = function (nid) {
        var result = this.nids[nid];
        return result;
    };
    return ModuleWrapper;
})();
exports.ModuleWrapper = ModuleWrapper;
var ModuleManager = (function () {
    function ModuleManager(context) {
        this.context = context;
        this.names = {};
        this.moduleWrappers = {};
    }
    ModuleManager.prototype.registerModule = function (_module) {
        for (var key in _module) {
            if (key == 'createNativeFunction')
                continue;
            var _class = _module[key];
            this.add(key, _class);
        }
    };
    ModuleManager.prototype.getByName = function (name) {
        var _this = this;
        var _moduleWrapper = this.moduleWrappers[name];
        if (_moduleWrapper)
            return _moduleWrapper;
        var _classes = this.names[name];
        if (!_classes)
            throw (new Error("Can't find module '" + name + "'"));
        var _modules = _classes.map(function (_class) { return new _class(_this.context); });
        return this.moduleWrappers[name] = new ModuleWrapper(name, _modules);
    };
    ModuleManager.prototype.add = function (name, _class) {
        if (!_class)
            throw (new Error("Can't find module '" + name + "'"));
        if (!this.names[name])
            this.names[name] = [];
        this.names[name].push(_class);
    };
    return ModuleManager;
})();
exports.ModuleManager = ModuleManager;

},
"src/hle/manager/net": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var NetManager = (function () {
    function NetManager() {
        this.connected = false;
        this.ws = null;
        this._onmessageSignals = {};
        this.onopen = new Signal();
        this.onclose = new Signal();
        this.mac = new Uint8Array(6);
    }
    NetManager.prototype.onmessage = function (port) {
        if (!this._onmessageSignals[port])
            this._onmessageSignals[port] = new Signal();
        return this._onmessageSignals[port];
    };
    NetManager.prototype.connectOnce = function () {
        var _this = this;
        if (this.ws)
            return;
        this.ws = new WebSocket('ws://' + location.host + '/adhoc', 'adhoc');
        this.ws.onopen = function (e) {
        };
        this.ws.onclose = function (e) {
            _this.connected = false;
            _this.onclose.dispatch();
            setTimeout(function () {
                _this.ws = null;
                _this.connectOnce();
            }, 5000);
        };
        this.ws.onmessage = function (e) {
            var info = JSON.parse(e.data);
            if (info.from == 'ff:ff:ff:ff:ff:ff') {
                console.info('NetManager: from_server:', info);
                switch (info.type) {
                    case 'setid':
                        _this.mac = string2mac(info.payload);
                        _this.connected = true;
                        _this.onopen.dispatch();
                        break;
                }
            }
            else {
                var packet = {
                    port: info.port,
                    type: info.type,
                    mac: string2mac(info.from),
                    payload: Stream.fromBase64(info.payload).toUInt8Array(),
                };
                _this.onmessage(info.port).dispatch(packet);
            }
        };
        this.ws.onerror = function (e) {
            _this.connected = false;
            console.error(e);
            setTimeout(function () {
                _this.connectOnce();
                _this.ws = null;
            }, 10000);
        };
    };
    NetManager.prototype.send = function (port, type, toMac, data) {
        this.connectOnce();
        this.ws.send(JSON.stringify({ type: type, port: port, to: mac2string(toMac), payload: Stream.fromUint8Array(data).toBase64() }));
    };
    return NetManager;
})();
exports.NetManager = NetManager;

},
"src/hle/manager/thread": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _cpu = require('../../core/cpu');
var SceKernelErrors = require('../SceKernelErrors');
var CpuState = _cpu.CpuState;
var CpuSpecialAddresses = _cpu.CpuSpecialAddresses;
var console = logger.named('hle.thread');
(function (ThreadStatus) {
    ThreadStatus[ThreadStatus["RUNNING"] = 1] = "RUNNING";
    ThreadStatus[ThreadStatus["READY"] = 2] = "READY";
    ThreadStatus[ThreadStatus["WAIT"] = 4] = "WAIT";
    ThreadStatus[ThreadStatus["SUSPEND"] = 8] = "SUSPEND";
    ThreadStatus[ThreadStatus["DORMANT"] = 16] = "DORMANT";
    ThreadStatus[ThreadStatus["DEAD"] = 32] = "DEAD";
    ThreadStatus[ThreadStatus["WAITSUSPEND"] = 12] = "WAITSUSPEND";
})(exports.ThreadStatus || (exports.ThreadStatus = {}));
var ThreadStatus = exports.ThreadStatus;
(function (PspThreadAttributes) {
    PspThreadAttributes[PspThreadAttributes["None"] = 0] = "None";
    PspThreadAttributes[PspThreadAttributes["LowFF"] = 255] = "LowFF";
    PspThreadAttributes[PspThreadAttributes["Vfpu"] = 16384] = "Vfpu";
    PspThreadAttributes[PspThreadAttributes["V0x2000"] = 8192] = "V0x2000";
    PspThreadAttributes[PspThreadAttributes["V0x4000"] = 16384] = "V0x4000";
    PspThreadAttributes[PspThreadAttributes["V0x400000"] = 4194304] = "V0x400000";
    PspThreadAttributes[PspThreadAttributes["V0x800000"] = 8388608] = "V0x800000";
    PspThreadAttributes[PspThreadAttributes["V0xf00000"] = 15728640] = "V0xf00000";
    PspThreadAttributes[PspThreadAttributes["V0x8000000"] = 134217728] = "V0x8000000";
    PspThreadAttributes[PspThreadAttributes["V0xf000000"] = 251658240] = "V0xf000000";
    PspThreadAttributes[PspThreadAttributes["User"] = 2147483648] = "User";
    PspThreadAttributes[PspThreadAttributes["UsbWlan"] = 2684354560] = "UsbWlan";
    PspThreadAttributes[PspThreadAttributes["Vsh"] = 3221225472] = "Vsh";
    PspThreadAttributes[PspThreadAttributes["NoFillStack"] = 1048576] = "NoFillStack";
    PspThreadAttributes[PspThreadAttributes["ClearStack"] = 2097152] = "ClearStack";
    PspThreadAttributes[PspThreadAttributes["ValidMask"] = -269459201] = "ValidMask";
})(exports.PspThreadAttributes || (exports.PspThreadAttributes = {}));
var PspThreadAttributes = exports.PspThreadAttributes;
var Thread = (function () {
    function Thread(name, manager, memoryManager, state, stackSize) {
        var _this = this;
        this.name = name;
        this.manager = manager;
        this.state = state;
        this.id = 0;
        this.status = ThreadStatus.DORMANT;
        this.initialPriority = 10;
        this.entryPoint = 0;
        this.priority = 10;
        this.attributes = 0;
        this.sceKernelCpuResumeIntrCount = 0;
        this.exitStatus = SceKernelErrors.ERROR_KERNEL_THREAD_ALREADY_DORMANT;
        this.running = false;
        this.preemptionCount = 0;
        this.info = null;
        this.waitingName = null;
        this.waitingObject = null;
        this.waitingPromise = null;
        this.runningPromise = null;
        this.acceptingCallbacks = false;
        this.wakeupCount = 0;
        this.wakeupPromise = null;
        this.wakeupFunc = null;
        this.accumulatedMicroseconds = 0;
        this.state.thread = this;
        this.runningPromise = new Promise2(function (resolve, reject) { _this.runningStop = resolve; });
        this.stackPartition = memoryManager.stackPartition.allocateHigh(stackSize, name + '-stack', 0x100);
    }
    Object.defineProperty(Thread.prototype, "runningOrAcceptingCallbacks", {
        get: function () {
            return this.running || this.acceptingCallbacks;
        },
        enumerable: true,
        configurable: true
    });
    Thread.prototype.delete = function () {
        this.stackPartition.deallocate();
    };
    Thread.prototype.waitEndAsync = function () {
        return this.runningPromise;
    };
    Thread.prototype.getWakeupPromise = function () {
        var _this = this;
        if (!this.wakeupPromise) {
            this.wakeupPromise = new Promise2(function (resolve, reject) {
                _this.wakeupFunc = resolve;
            });
        }
        return this.wakeupPromise;
    };
    Thread.prototype.wakeupSleepAsync = function (callbacks) {
        this.wakeupCount--;
        this.suspend();
        return this.getWakeupPromise();
    };
    Thread.prototype.wakeupWakeupAsync = function () {
        this.wakeupCount++;
        if (this.wakeupCount >= 0) {
            this.wakeupFunc();
            this.wakeupPromise = null;
            this.wakeupFunc = null;
        }
        return Promise2.resolve(0);
    };
    Thread.prototype.delayMicrosecondsAsync = function (delayMicroseconds, allowCompensating) {
        //console.error(delayMicroseconds, this.accumulatedMicroseconds);
        //return waitAsync(delayMicroseconds / 1000).then(() => 0);
        var _this = this;
        if (allowCompensating === void 0) { allowCompensating = false; }
        this.accumulatedMicroseconds = Math.min(this.accumulatedMicroseconds, 50000);
        if (allowCompensating) {
            var subtractAccumulatedMicroseconds = Math.min(delayMicroseconds, this.accumulatedMicroseconds);
            delayMicroseconds -= subtractAccumulatedMicroseconds;
            this.accumulatedMicroseconds -= subtractAccumulatedMicroseconds;
        }
        if (delayMicroseconds <= 0.00001) {
        }
        var start = performance.now();
        return waitAsync(delayMicroseconds / 1000).then(function () {
            var end = performance.now();
            var elapsedmicroseconds = (end - start) * 1000;
            _this.accumulatedMicroseconds += ((elapsedmicroseconds - delayMicroseconds) | 0);
            return 0;
        });
    };
    Thread.prototype.suspend = function () {
        this.running = false;
        this.manager.eventOcurred();
    };
    Thread.prototype.suspendUntilDone = function (info) {
        this.info = info;
        this.waitingName = info.name;
        this.waitingObject = info.object;
        this.acceptingCallbacks = (info.callbacks == AcceptCallbacks.YES);
        this._suspendUntilPromiseDone(info.promise, info.compensate);
    };
    Thread.prototype.suspendUntilPromiseDone = function (promise, info) {
        this.waitingName = info.name + ':0x' + info.nid.toString(16) + ' (Promise2)';
        this.waitingObject = info;
        this._suspendUntilPromiseDone(promise, Compensate.NO);
    };
    Thread.prototype._suspendUntilPromiseDone = function (promise, compensate) {
        var _this = this;
        if (compensate == Compensate.YES) {
            var startTime = performance.now();
        }
        this.waitingPromise = promise;
        this.suspend();
        promise.then(function (result) {
            _this.waitingPromise = null;
            _this.waitingName = null;
            _this.waitingObject = null;
            _this.acceptingCallbacks = false;
            if (result !== undefined)
                _this.state.V0 = result;
            if (compensate == Compensate.YES) {
                var endTime = performance.now();
                _this.accumulatedMicroseconds += (endTime - startTime) * 1000;
            }
            _this.resume();
        });
    };
    Thread.prototype.resume = function () {
        this.running = true;
        this.manager.eventOcurred();
    };
    Thread.prototype.start = function () {
        this.running = true;
        console.info('starting thread ', this.name);
        this.manager.threads.add(this);
        this.manager.eventOcurred();
    };
    Thread.prototype.stop = function (reason) {
        this.running = false;
        this.runningStop();
        console.info('stopping thread ', this.name, 'reason:', reason);
        this.manager.threads.delete(this);
        this.manager.eventOcurred();
    };
    Thread.prototype.runStep = function () {
        this.manager.current = this;
        this.preemptionCount++;
        this.state.executeAtPC();
    };
    return Thread;
})();
exports.Thread = Thread;
var ThreadManager = (function () {
    function ThreadManager(memory, interruptManager, callbackManager, memoryManager, display, syscallManager) {
        var _this = this;
        this.memory = memory;
        this.interruptManager = interruptManager;
        this.callbackManager = callbackManager;
        this.memoryManager = memoryManager;
        this.display = display;
        this.syscallManager = syscallManager;
        this.threads = new DSet();
        this.interval = -1;
        this.enqueued = false;
        this.enqueuedTime = 0;
        this.running = false;
        this.callbackAdded = null;
        this.rootCpuState = new CpuState(this.memory, this.syscallManager);
        this.exitPromise = new Promise2(function (resolve, reject) {
            _this.exitResolve = resolve;
        });
        this.interruptManager.event.add(this.eventOcurred);
    }
    ThreadManager.prototype.create = function (name, entryPoint, initialPriority, stackSize, attributes) {
        if (stackSize === void 0) { stackSize = 0x1000; }
        if (attributes === void 0) { attributes = 0; }
        var thread = new Thread(name, this, this.memoryManager, this.rootCpuState.clone(), stackSize);
        thread.entryPoint = entryPoint;
        thread.state.PC = entryPoint;
        thread.state.setRA(CpuSpecialAddresses.EXIT_THREAD);
        thread.state.SP = thread.stackPartition.high;
        thread.initialPriority = initialPriority;
        thread.priority = initialPriority;
        thread.attributes = attributes;
        if ((thread.stackPartition.high & 0xFF) != 0)
            throw (new Error("Stack not aligned"));
        if (!(thread.attributes & PspThreadAttributes.NoFillStack)) {
        }
        else if ((thread.attributes & PspThreadAttributes.ClearStack)) {
        }
        return thread;
    };
    ThreadManager.prototype.eventOcurred = function () {
        var _this = this;
        if (!this.running)
            return;
        if (this.enqueued)
            return;
        this.enqueued = true;
        this.enqueuedTime = performance.now();
        Microtask.queue(function () { return _this.eventOcurredCallback(); });
    };
    ThreadManager.getHighestPriority = function (threads) {
        var priority = -9999;
        threads.forEach(function (thread) {
            priority = Math.max(priority, thread.priority);
        });
        return priority;
    };
    ThreadManager.prototype.eventOcurredCallback = function () {
        var _this = this;
        if (!this.running)
            return;
        var microsecondsToCompensate = Math.round((performance.now() - this.enqueuedTime) * 1000);
        this.enqueued = false;
        var start = window.performance.now();
        while (true) {
            if (this.threads.elements.length > 0) {
                this.interruptManager.execute(this.threads.elements[0].state);
            }
            var callbackThreadCount = 0;
            var callbackPriority = Number.MAX_VALUE;
            var runningThreadCount = 0;
            var runningPriority = Number.MAX_VALUE;
            this.threads.forEach(function (thread) {
                if (_this.callbackManager.hasPendingCallbacks) {
                    if (thread.acceptingCallbacks) {
                        callbackThreadCount++;
                        callbackPriority = Math.min(callbackPriority, thread.priority);
                    }
                }
                if (thread.running) {
                    runningThreadCount++;
                    runningPriority = Math.min(runningPriority, thread.priority);
                }
            });
            if ((runningThreadCount == 0) && (callbackThreadCount == 0))
                break;
            if (callbackThreadCount != 0) {
                this.threads.forEach(function (thread) {
                    if (thread.acceptingCallbacks && (thread.priority == callbackPriority)) {
                        _this.callbackManager.executePendingWithinThread(thread);
                    }
                });
            }
            if (runningThreadCount != 0) {
                this.threads.forEach(function (thread) {
                    if (thread.running && (thread.priority == runningPriority)) {
                        _this.callbackManager.executeLaterPendingWithinThread(thread);
                        _this.runThreadStep(thread);
                    }
                });
            }
            var current = window.performance.now();
            if (current - start >= 100) {
                setTimeout(function () { return _this.eventOcurred(); }, 0);
                return;
            }
        }
    };
    ThreadManager.prototype.runThreadStep = function (thread) {
        try {
            do {
                thread.runStep();
                if (!this.interruptManager.enabled) {
                    console.log(thread.name, ':interrupts disabled, no thread scheduling!');
                }
            } while (!this.interruptManager.enabled);
        }
        catch (e) {
            if (e.message = 'CpuBreakException')
                return;
            console.error(e);
            console.error(e['stack']);
            thread.stop('error:' + e);
            throw (e);
        }
    };
    ThreadManager.prototype.debugThreads = function () {
        var html = '';
        this.threads.forEach(function (thread) {
            html += sprintf("%08X:%s:%s", thread.state.PC, thread.name, thread.running);
        });
        document.getElementById('thread_list').innerHTML = html;
    };
    ThreadManager.prototype.startAsync = function () {
        var _this = this;
        this.running = true;
        this.eventOcurred();
        this.callbackAdded = this.callbackManager.onAdded.add(function () {
            _this.eventOcurred();
        });
        return Promise2.resolve();
    };
    ThreadManager.prototype.stopAsync = function () {
        this.running = false;
        this.callbackManager.onAdded.remove(this.callbackAdded);
        clearInterval(this.interval);
        this.interval = -1;
        return Promise2.resolve();
    };
    ThreadManager.prototype.exitGame = function () {
        this.exitResolve();
    };
    ThreadManager.prototype.waitExitGameAsync = function () {
        return this.exitPromise;
    };
    return ThreadManager;
})();
exports.ThreadManager = ThreadManager;

},
"src/hle/module/ExceptionManagerForKernel": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var ExceptionManagerForKernel = (function () {
    function ExceptionManagerForKernel(context) {
        this.context = context;
        this.sceKernelRegisterDefaultExceptionHandler = createNativeFunction(0x565C0B0E, 150, 'uint', 'uint', this, function (exceptionHandlerFunction) {
            return 0;
        });
    }
    return ExceptionManagerForKernel;
})();
exports.ExceptionManagerForKernel = ExceptionManagerForKernel;

},
"src/hle/module/InterruptManager": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var _interrupt = require('../../core/interrupt');
var PspInterrupts = _interrupt.PspInterrupts;
var createNativeFunction = _utils.createNativeFunction;
var InterruptManager = (function () {
    function InterruptManager(context) {
        var _this = this;
        this.context = context;
        this.sceKernelRegisterSubIntrHandler = createNativeFunction(0xCA04A2B9, 150, 'uint', 'Thread/int/int/uint/uint', this, function (thread, interrupt, handlerIndex, callbackAddress, callbackArgument) {
            var interruptManager = _this.context.interruptManager;
            var interruptHandler = interruptManager.get(interrupt).get(handlerIndex);
            interruptHandler.address = callbackAddress;
            interruptHandler.argument = callbackArgument;
            interruptHandler.cpuState = thread.state;
            return 0;
        });
        this.sceKernelEnableSubIntr = createNativeFunction(0xFB8E22EC, 150, 'uint', 'int/int', this, function (interrupt, handlerIndex) {
            var interruptManager = _this.context.interruptManager;
            if (interrupt >= PspInterrupts.PSP_NUMBER_INTERRUPTS)
                return -1;
            if (!interruptManager.get(interrupt).has(handlerIndex))
                return -1;
            interruptManager.get(interrupt).get(handlerIndex).enabled = true;
            return 0;
        });
        this.sceKernelReleaseSubIntrHandler = createNativeFunction(0xD61E6961, 150, 'uint', 'int/int', this, function (pspInterrupt, handlerIndex) {
            var interruptManager = _this.context.interruptManager;
            if (pspInterrupt >= PspInterrupts.PSP_NUMBER_INTERRUPTS)
                return -1;
            if (!interruptManager.get(pspInterrupt).has(handlerIndex))
                return -1;
            interruptManager.get(pspInterrupt).get(handlerIndex).enabled = false;
            return 0;
        });
        this.context.display.vblank.add(function () {
        });
    }
    return InterruptManager;
})();
exports.InterruptManager = InterruptManager;

},
"src/hle/module/KDebugForKernel": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var KDebugForKernel = (function () {
    function KDebugForKernel(context) {
        this.context = context;
        this.Kprintf = createNativeFunction(0x84F370BC, 150, 'void', 'string', this, function (format) {
            console.info('Kprintf: ' + format);
        });
    }
    return KDebugForKernel;
})();
exports.KDebugForKernel = KDebugForKernel;

},
"src/hle/module/Kernel_Library": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var _manager = require('../manager');
_manager.Thread;
var createNativeFunction = _utils.createNativeFunction;
var Kernel_Library = (function () {
    function Kernel_Library(context) {
        var _this = this;
        this.context = context;
        this.sceKernelCpuSuspendIntr = createNativeFunction(0x092968F4, 150, 'uint', '', this, function () {
            return _this.context.interruptManager.suspend();
        });
        this.sceKernelCpuResumeIntr = createNativeFunction(0x5F10D406, 150, 'uint', 'Thread/uint', this, function (thread, flags) {
            _this.context.interruptManager.resume(flags);
            thread.sceKernelCpuResumeIntrCount++;
            if (thread.sceKernelCpuResumeIntrCount >= 3) {
                thread.sceKernelCpuResumeIntrCount = 0;
                return Promise2.resolve(0);
            }
            else {
                return 0;
            }
        });
        this.sceKernelMemset = createNativeFunction(0xA089ECA4, 150, 'uint', 'uint/int/int', this, function (address, value, size) {
            _this.context.memory.memset(address, value, size);
            return address;
        });
        this.sceKernelMemcpy = createNativeFunction(0x1839852A, 150, 'uint', 'uint/uint/int', this, function (dst, src, size) {
            _this.context.memory.copy(src, dst, size);
            return dst;
        });
    }
    return Kernel_Library;
})();
exports.Kernel_Library = Kernel_Library;

},
"src/hle/module/LoadCoreForKernel": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var LoadCoreForKernel = (function () {
    function LoadCoreForKernel(context) {
        var _this = this;
        this.context = context;
        this.sceKernelIcacheClearAll = createNativeFunction(0xD8779AC6, 150, 'void', '', this, function () {
            _this.context.currentInstructionCache.invalidateAll();
        });
        this.sceKernelFindModuleByUID = createNativeFunction(0xCCE4A157, 150, 'int', 'int', this, function (moduleID) {
            console.warn('Not implemented sceKernelFindModuleByUID(' + moduleID + ')');
            return 0;
        });
    }
    return LoadCoreForKernel;
})();
exports.LoadCoreForKernel = LoadCoreForKernel;

},
"src/hle/module/LoadExecForUser": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var console = logger.named('module.LoadExecForUser');
var LoadExecForUser = (function () {
    function LoadExecForUser(context) {
        var _this = this;
        this.context = context;
        this.sceKernelExitGame = createNativeFunction(0xBD2F1094, 150, 'uint', 'Thread', this, function (thread) {
            console.info('sceKernelExitGame');
            thread.stop('sceKernelExitGame');
            _this.context.threadManager.exitGame();
            throw new Error('CpuBreakException');
            return 0;
        });
        this.sceKernelExitGame2 = createNativeFunction(0x05572A5F, 150, 'uint', 'Thread', this, function (thread) {
            console.info("Call stack:");
            thread.state.printCallstack(_this.context.symbolLookup);
            console.info('sceKernelExitGame2');
            _this.context.threadManager.exitGame();
            thread.stop('sceKernelExitGame2');
            throw new Error('CpuBreakException');
        });
        this.sceKernelRegisterExitCallback = createNativeFunction(0x4AC57943, 150, 'uint', 'int', this, function (callbackId) {
            return 0;
        });
    }
    return LoadExecForUser;
})();
exports.LoadExecForUser = LoadExecForUser;

},
"src/hle/module/ModuleMgrForUser": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var ModuleMgrForUser = (function () {
    function ModuleMgrForUser(context) {
        var _this = this;
        this.context = context;
        this.sceKernelStopModule = createNativeFunction(0xD1FF982A, 150, 'uint', '', this, function () {
            return 0;
        });
        this.sceKernelUnloadModule = createNativeFunction(0x2E0911AA, 150, 'uint', 'int', this, function (id) {
            return 0;
        });
        this.sceKernelSelfStopUnloadModule = createNativeFunction(0xD675EBB8, 150, 'uint', 'int/int/int/Thread', this, function (unknown, argsize, argp, thread) {
            console.info("Call stack:");
            thread.state.printCallstack(_this.context.symbolLookup);
            console.warn(sprintf('Not implemented ModuleMgrForUser.sceKernelSelfStopUnloadModule(%d, %d, %d)', unknown, argsize, argp));
            throw (new Error("sceKernelSelfStopUnloadModule"));
            return 0;
        });
        this.sceKernelStopUnloadSelfModule = createNativeFunction(0xCC1D3699, 150, 'uint', 'int/int/int/Thread', this, function (argsize, argp, optionsAddress, thread) {
            throw (new Error("sceKernelStopUnloadSelfModule"));
            return 0;
        });
        this.sceKernelLoadModule = createNativeFunction(0x977DE386, 150, 'uint', 'string/uint/void*', this, function (path, flags, sceKernelLMOption) {
            console.warn(sprintf('Not implemented ModuleMgrForUser.sceKernelLoadModule("%s", %d)', path, flags));
            return 0x08900000;
        });
        this.sceKernelStartModule = createNativeFunction(0x50F0C1EC, 150, 'uint', 'int/int/uint/void*/void*', this, function (moduleId, argumentSize, argumentPointer, status, sceKernelSMOption) {
            console.warn(sprintf('Not implemented ModuleMgrForUser.sceKernelStartModule(%d, %d, %d)', moduleId, argumentSize, argumentPointer));
            return 0;
        });
        this.sceKernelGetModuleIdByAddress = createNativeFunction(0xD8B73127, 150, 'uint', 'uint', this, function (address) {
            console.warn(sprintf('Not implemented ModuleMgrForUser.sceKernelGetModuleIdByAddress(%08X)', address));
            return 3;
        });
        this.sceKernelGetModuleId = createNativeFunction(0xF0A26395, 150, 'uint', '', this, function () {
            console.warn(sprintf('Not implemented ModuleMgrForUser.sceKernelGetModuleId()'));
            return 4;
        });
        this.sceKernelLoadModuleByID = createNativeFunction(0xB7F46618, 150, 'uint', 'uint/uint/void*', this, function (fileId, flags, sceKernelLMOption) {
            console.warn(sprintf('Not implemented ModuleMgrForUser.sceKernelLoadModuleByID(%d, %08X)', fileId, flags));
            return 0;
        });
    }
    return ModuleMgrForUser;
})();
exports.ModuleMgrForUser = ModuleMgrForUser;

},
"src/hle/module/StdioForUser": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var StdioForUser = (function () {
    function StdioForUser(context) {
        this.context = context;
        this.sceKernelStdin = createNativeFunction(0x172D316E, 150, 'int', '', this, function () { return 0; });
        this.sceKernelStdout = createNativeFunction(0xA6BAB2E9, 150, 'int', '', this, function () { return 1; });
        this.sceKernelStderr = createNativeFunction(0xF78BA90A, 150, 'int', '', this, function () { return 2; });
    }
    return StdioForUser;
})();
exports.StdioForUser = StdioForUser;

},
"src/hle/module/SysMemUserForUser": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var SceKernelErrors = require('../SceKernelErrors');
var console = logger.named('module.SysMemUserForUser');
var SysMemUserForUser = (function () {
    function SysMemUserForUser(context) {
        var _this = this;
        this.context = context;
        this.partitionUids = new UidCollection(1);
        this.blockUids = new UidCollection(1);
        this.sceKernelAllocPartitionMemory = createNativeFunction(0x237DBD4F, 150, 'int', 'int/string/int/int/int', this, function (partitionId, name, anchor, size, address) {
            if (name == null)
                return SceKernelErrors.ERROR_ERROR;
            try {
                var parentPartition = _this.context.memoryManager.memoryPartitionsUid[partitionId];
                var allocatedPartition = parentPartition.allocate(size, anchor, address, name);
                console.info(sprintf("SysMemUserForUser.sceKernelAllocPartitionMemory (partitionId:%d, name:'%s', type:%d, size:%d, address:%08X) : %08X-%08X", partitionId, name, anchor, size, address, allocatedPartition.low, allocatedPartition.high));
                return _this.partitionUids.allocate(allocatedPartition);
            }
            catch (e) {
                console.error(e);
                return SceKernelErrors.ERROR_KERNEL_FAILED_ALLOC_MEMBLOCK;
            }
        });
        this.AllocMemoryBlock = createNativeFunction(0xFE707FDF, 150, 'int', 'string/uint/uint/void*', this, function (name, type, size, paramsAddrPtr) {
            if (name == null)
                return SceKernelErrors.ERROR_ERROR;
            if (type < 0 || type > 1)
                return SceKernelErrors.ERROR_KERNEL_ILLEGAL_MEMBLOCK_ALLOC_TYPE;
            if (size == 0)
                return SceKernelErrors.ERROR_KERNEL_FAILED_ALLOC_MEMBLOCK;
            if (paramsAddrPtr) {
                var size = paramsAddrPtr.readInt32();
                var unk = paramsAddrPtr.readInt32();
                if (size != 4)
                    return SceKernelErrors.ERROR_KERNEL_ILLEGAL_ARGUMENT;
            }
            var parentPartition = _this.context.memoryManager.userPartition;
            try {
                var block = parentPartition.allocate(size, type, 0, name);
                return _this.blockUids.allocate(block);
            }
            catch (e) {
                console.error(e);
                return SceKernelErrors.ERROR_KERNEL_FAILED_ALLOC_MEMBLOCK;
            }
        });
        this.GetMemoryBlockAddr = createNativeFunction(0xDB83A952, 150, 'int', 'int', this, function (blockId) {
            if (!_this.blockUids.has(blockId))
                return 0;
            var block = _this.blockUids.get(blockId);
            return block.low;
        });
        this.FreeMemoryBlock = createNativeFunction(0x50F61D8A, 150, 'int', 'int', this, function (blockId) {
            if (!_this.blockUids.has(blockId))
                return SceKernelErrors.ERROR_KERNEL_UNKNOWN_UID;
            _this.blockUids.remove(blockId);
            return 0;
        });
        this.sceKernelFreePartitionMemory = createNativeFunction(0xB6D61D02, 150, 'int', 'int', this, function (partitionId) {
            if (!_this.partitionUids.has(partitionId))
                return SceKernelErrors.ERROR_KERNEL_ILLEGAL_MEMBLOCK;
            var partition = _this.partitionUids.get(partitionId);
            partition.deallocate();
            _this.partitionUids.remove(partitionId);
            return 0;
        });
        this.sceKernelTotalFreeMemSize = createNativeFunction(0xF919F628, 150, 'int', '', this, function () {
            return _this.context.memoryManager.userPartition.getTotalFreeMemory() - 0x8000;
        });
        this.sceKernelGetBlockHeadAddr = createNativeFunction(0x9D9A5BA1, 150, 'uint', 'int', this, function (partitionId) {
            if (!_this.partitionUids.has(partitionId))
                return SceKernelErrors.ERROR_KERNEL_ILLEGAL_MEMBLOCK;
            var block = _this.partitionUids.get(partitionId);
            return block.low;
        });
        this.sceKernelMaxFreeMemSize = createNativeFunction(0xA291F107, 150, 'int', '', this, function () {
            return _this.context.memoryManager.userPartition.nonAllocatedPartitions.max(function (partition) { return partition.size; }).size;
        });
        this.sceKernelSetCompiledSdkVersion = createNativeFunction(0x7591C7DB, 150, 'int', 'uint', this, function (sdkVersion) {
            console.info(sprintf('sceKernelSetCompiledSdkVersion: %08X', sdkVersion));
        });
        this.sceKernelSetCompilerVersion = createNativeFunction(0xF77D77CB, 150, 'int', 'uint', this, function (version) {
            console.info(sprintf('sceKernelSetCompilerVersion: %08X', version));
        });
        this.sceKernelSetCompiledSdkVersion395 = createNativeFunction(0xEBD5C3E6, 150, 'int', 'uint', this, function (param) {
            console.info(sprintf('sceKernelSetCompiledSdkVersion395: %08X', param));
        });
        this.sceKernelDevkitVersion = createNativeFunction(0x3FC9AE6A, 150, 'int', 'uint', this, function (version) {
            return 0x02070110;
        });
        this.sceKernelPrintf = createNativeFunction(0x13A5ABEF, 150, 'void', 'Thread/string', this, function (thread, format) {
            var gprIndex = 5;
            var memory = _this.context.memory;
            var gpr = thread.state.gpr;
            var readParam = function (type) {
                switch (type) {
                    case '%s': return memory.readStringz(gpr[gprIndex++]);
                    case '%d': return String(gpr[gprIndex++]);
                }
                return '??[' + type + ']??';
            };
            console.info('sceKernelPrintf: ' + format.replace(/%[dsux]/g, function (data) {
                return readParam(data);
            }));
        });
    }
    return SysMemUserForUser;
})();
exports.SysMemUserForUser = SysMemUserForUser;

},
"src/hle/module/UtilsForKernel": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var UtilsForKernel = (function () {
    function UtilsForKernel(context) {
        var _this = this;
        this.context = context;
        this.sceKernelIcacheInvalidateRange = createNativeFunction(0xC2DF770E, 150, 'void', 'uint/uint', this, function (address, size) {
            _this.context.currentInstructionCache.invalidateRange(address, address + size);
        });
    }
    return UtilsForKernel;
})();
exports.UtilsForKernel = UtilsForKernel;

},
"src/hle/module/UtilsForUser": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var SceKernelErrors = require('../SceKernelErrors');
var UtilsForUser = (function () {
    function UtilsForUser(context) {
        var _this = this;
        this.context = context;
        this.sceKernelLibcClock = createNativeFunction(0x91E4F6A7, 150, 'uint', '', this, function () {
            return _this.context.rtc.getClockMicroseconds();
        });
        this.sceKernelLibcTime = createNativeFunction(0x27CC57F0, 150, 'uint', 'void*', this, function (pointer) {
            if (pointer == Stream.INVALID)
                return 0;
            var result = (_this.context.rtc.getCurrentUnixSeconds()) | 0;
            if (pointer)
                pointer.writeInt32(result);
            return result;
        });
        this.sceKernelGetGPI = createNativeFunction(0x37FB5C42, 150, 'uint', '', this, function () {
            return 0;
        });
        this.sceKernelUtilsMt19937Init = createNativeFunction(0xE860E75E, 150, 'uint', 'Memory/uint/uint', this, function (memory, contextPtr, seed) {
            console.warn('Not implemented UtilsForUser.sceKernelUtilsMt19937Init');
            return 0;
        });
        this.sceKernelUtilsMt19937UInt = createNativeFunction(0x06FB8A63, 150, 'uint', 'Memory/uint', this, function (memory, contextPtr) {
            return Math.round(Math.random() * 0xFFFFFFFF);
        });
        this.sceKernelLibcGettimeofday = createNativeFunction(0x71EC4271, 150, 'uint', 'void*/void*', this, function (timevalPtr, timezonePtr) {
            if (timevalPtr) {
                var totalMilliseconds = Date.now();
                var totalSeconds = Math.floor(totalMilliseconds / 1000);
                var milliseconds = Math.floor(totalMilliseconds % 1000);
                var microseconds = milliseconds * 1000;
                timevalPtr.writeInt32(totalSeconds);
                timevalPtr.writeInt32(microseconds);
            }
            if (timezonePtr) {
                var minutesWest = 0;
                var dstTime = 0;
                timevalPtr.writeInt32(minutesWest);
                timevalPtr.writeInt32(dstTime);
            }
            return 0;
        });
        this.sceKernelDcacheWritebackInvalidateRange = createNativeFunction(0x34B9FA9E, 150, 'uint', 'uint/uint', this, function (pointer, size) {
            if (size > 0x7FFFFFFF)
                return SceKernelErrors.ERROR_INVALID_SIZE;
            if (pointer >= 0x80000000)
                return SceKernelErrors.ERROR_INVALID_POINTER;
            _this.context.memory.invalidateDataRange.dispatch({ start: pointer, end: pointer + size });
            return 0;
        });
        this.sceKernelDcacheWritebackRange = createNativeFunction(0x3EE30821, 150, 'uint', 'uint/uint', this, function (pointer, size) {
            if (size > 0x7FFFFFFF)
                return SceKernelErrors.ERROR_INVALID_SIZE;
            if (pointer >= 0x80000000)
                return SceKernelErrors.ERROR_INVALID_POINTER;
            _this.context.memory.invalidateDataRange.dispatch({ start: pointer, end: pointer + size });
            return 0;
        });
        this.sceKernelDcacheWritebackAll = createNativeFunction(0x79D1C3FA, 150, 'uint', '', this, function () {
            _this.context.memory.invalidateDataAll.dispatch();
            return 0;
        });
        this.sceKernelDcacheInvalidateRange = createNativeFunction(0xBFA98062, 150, 'uint', 'uint/uint', this, function (pointer, size) {
            if (!MathUtils.isAlignedTo(size, 4))
                return SceKernelErrors.ERROR_KERNEL_NOT_CACHE_ALIGNED;
            if (size > 0x7FFFFFFF)
                return SceKernelErrors.ERROR_INVALID_SIZE;
            if (pointer >= 0x80000000)
                return SceKernelErrors.ERROR_KERNEL_ILLEGAL_ADDR;
            if (!MathUtils.isAlignedTo(pointer, 4))
                return SceKernelErrors.ERROR_KERNEL_NOT_CACHE_ALIGNED;
            _this.context.memory.invalidateDataRange.dispatch({ start: pointer, end: pointer + size });
            return 0;
        });
        this.sceKernelDcacheWritebackInvalidateAll = createNativeFunction(0xB435DEC5, 150, 'uint', '', this, function () {
            _this.context.memory.invalidateDataAll.dispatch();
            return 0;
        });
        this.sceKernelSetGPO = createNativeFunction(0x6AD345D7, 150, 'uint', 'int', this, function (value) {
            return 0;
        });
    }
    return UtilsForUser;
})();
exports.UtilsForUser = UtilsForUser;

},
"src/hle/module/iofilemgr/IoFileMgrForUser": function(module, exports, require) {
///<reference path="../../../global.d.ts" />
var _utils = require('../../utils');
var createNativeFunction = _utils.createNativeFunction;
var _vfs = require('../../vfs');
var _structs = require('../../structs');
var SceKernelErrors = require('../../SceKernelErrors');
var _manager = require('../../manager');
_manager.Thread;
var FileOpenFlags = _vfs.FileOpenFlags;
var log = logger.named('module.IoFileMgrForUser');
var IoFileMgrForUser = (function () {
    function IoFileMgrForUser(context) {
        var _this = this;
        this.context = context;
        this.sceIoDevctl = createNativeFunction(0x54F5FB11, 150, 'uint', 'string/uint/uint/int/uint/int', this, function (deviceName, command, inputPointer, inputLength, outputPointer, outputLength) {
            var input = _this.context.memory.getPointerStream(inputPointer, inputLength);
            var output = _this.context.memory.getPointerStream(outputPointer, outputLength);
            return _this.context.fileManager.devctlAsync(deviceName, command, input, output);
        }, { tryCatch: false });
        this.fileUids = new UidCollection(3);
        this.directoryUids = new UidCollection(1);
        this.sceIoOpen = createNativeFunction(0x109F50BC, 150, 'int', 'string/int/int', this, function (filename, flags, mode) {
            return _this._sceIoOpenAsync(filename, flags, mode).then(function (result) {
                var str = sprintf('IoFileMgrForUser.sceIoOpen("%s", %d(%s), 0%o)', filename, flags, setToString(FileOpenFlags, flags), mode);
                if (result == SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND) {
                    log.error(str, result);
                }
                else {
                    log.info(str, result);
                }
                return result;
            });
        });
        this.sceIoOpenAsync = createNativeFunction(0x89AA9906, 150, 'int', 'string/int/int', this, function (filename, flags, mode) {
            log.info(sprintf('IoFileMgrForUser.sceIoOpenAsync("%s", %d(%s), 0%o)', filename, flags, setToString(FileOpenFlags, flags), mode));
            return _this._sceIoOpenAsync(filename, flags, mode).then(function (fileId) {
                if (!_this.hasFileById(fileId))
                    return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
                var file = _this.getFileById(fileId);
                file.setAsyncOperation(Promise2.resolve(Integer64.fromNumber(fileId)));
                log.info('-->', fileId);
                return fileId;
            });
        });
        this.sceIoCloseAsync = createNativeFunction(0xFF5940B6, 150, 'int', 'int', this, function (fileId) {
            log.warn(sprintf('Not implemented IoFileMgrForUser.sceIoCloseAsync(%d)', fileId));
            if (!_this.hasFileById(fileId))
                return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
            var file = _this.getFileById(fileId);
            if (file)
                file.close();
            file.setAsyncOperation(Promise2.resolve(Integer64.fromInt(0)));
            return 0;
        });
        this.sceIoAssign = createNativeFunction(0xB2A628C1, 150, 'int', 'string/string/string/int/void*/long', this, function (device1, device2, device3, mode, unk1Ptr, unk2) {
            log.warn(sprintf("sceIoAssign not implemented! %s -> %s -> %s", device1, device2, device3));
            return 0;
        });
        this.sceIoClose = createNativeFunction(0x810C4BC3, 150, 'int', 'int', this, function (fileId) {
            if (!_this.hasFileById(fileId))
                return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
            var file = _this.getFileById(fileId);
            if (file)
                file.close();
            log.warn(sprintf('Not implemented IoFileMgrForUser.sceIoClose(%d)', fileId));
            _this.fileUids.remove(fileId);
            return 0;
        });
        this.sceIoWrite = createNativeFunction(0x42EC03AC, 150, 'int', 'int/byte[]', this, function (fileId, input) {
            if (fileId < 3) {
                var str = input.readString(input.length);
                log.log('STD[' + fileId + ']', str);
                _this.context.onStdout.dispatch(str);
                return 0;
            }
            else {
                if (!_this.hasFileById(fileId))
                    return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
                var file = _this.getFileById(fileId);
                return file.entry.writeChunkAsync(file.cursor, input.toArrayBuffer()).then(function (writtenCount) {
                    log.info('sceIoWrite', 'file.cursor', file.cursor, 'input.length:', input.length, 'writtenCount:', writtenCount);
                    file.cursor += writtenCount;
                    return writtenCount;
                }).catch(function (e) {
                    log.error(e);
                    return SceKernelErrors.ERROR_ERROR;
                });
            }
        });
        this.sceIoRead = createNativeFunction(0x6A638D83, 150, 'int', 'int/uint/int', this, function (fileId, outputPointer, outputLength) {
            if (!_this.hasFileById(fileId))
                return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
            var file = _this.getFileById(fileId);
            return file.entry.readChunkAsync(file.cursor, outputLength).then(function (readedData) {
                file.cursor += readedData.byteLength;
                _this.context.memory.writeBytes(outputPointer, readedData);
                return readedData.byteLength;
            });
        });
        this.sceIoReadAsync = createNativeFunction(0xA0B5A7C2, 150, 'int', 'Thread/int/uint/int', this, function (thread, fileId, outputPointer, outputLength) {
            if (!_this.hasFileById(fileId))
                return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
            var file = _this.getFileById(fileId);
            file.setAsyncOperation(file.entry.readChunkAsync(file.cursor, outputLength).then(function (readedData) {
                file.cursor += readedData.byteLength;
                _this.context.memory.writeBytes(outputPointer, readedData);
                return Integer64.fromNumber(readedData.byteLength);
            }));
            return 0;
        });
        this.sceIoWaitAsync = createNativeFunction(0xE23EEC33, 150, 'int', 'Thread/int/void*', this, function (thread, fileId, resultPointer) {
            return _this._sceIoWaitAsyncCB(thread, fileId, resultPointer);
        });
        this.sceIoWaitAsyncCB = createNativeFunction(0x35DBD746, 150, 'int', 'Thread/int/void*', this, function (thread, fileId, resultPointer) {
            return _this._sceIoWaitAsyncCB(thread, fileId, resultPointer);
        });
        this.sceIoPollAsync = createNativeFunction(0x3251EA56, 150, 'uint', 'Thread/int/void*', this, function (thread, fileId, resultPointer) {
            if (!_this.hasFileById(fileId))
                return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
            var file = _this.getFileById(fileId);
            if (file.asyncResult) {
                if (DebugOnce('sceIoPollAsync', 100))
                    log.log(thread.name, ':sceIoPollAsync', fileId, 'resolved -> ', file.asyncResult.number);
                resultPointer.writeInt64(file.asyncResult);
                return 0;
            }
            else {
                if (DebugOnce('sceIoPollAsync', 100))
                    log.log(thread.name, ':sceIoPollAsync', fileId, 'not resolved');
                resultPointer.writeInt64(Integer64.fromInt(0));
                return 1;
            }
        });
        this.sceIoGetstat = createNativeFunction(0xACE946E8, 150, 'int', 'string/void*', this, function (fileName, sceIoStatPointer) {
            if (sceIoStatPointer) {
                sceIoStatPointer.position = 0;
                _structs.SceIoStat.struct.write(sceIoStatPointer, new _structs.SceIoStat());
            }
            try {
                return _this.context.fileManager.getStatAsync(fileName)
                    .then(function (stat) {
                    var stat2 = _this._vfsStatToSceIoStat(stat);
                    log.info(sprintf('IoFileMgrForUser.sceIoGetstat("%s")', fileName), stat2);
                    if (sceIoStatPointer) {
                        sceIoStatPointer.position = 0;
                        _structs.SceIoStat.struct.write(sceIoStatPointer, stat2);
                    }
                    return 0;
                })
                    .catch(function (error) { return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND; });
            }
            catch (e) {
                log.error(e);
                return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
            }
        });
        this.sceIoChdir = createNativeFunction(0x55F4717D, 150, 'int', 'string', this, function (path) {
            log.info(sprintf('IoFileMgrForUser.sceIoChdir("%s")', path));
            try {
                _this.context.fileManager.chdir(path);
                return 0;
            }
            catch (e) {
                log.error(e);
                return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
            }
        });
        this.sceIoLseekAsync = createNativeFunction(0x71B19E77, 150, 'int', 'int/long/int', this, function (fileId, offset, whence) {
            if (!_this.hasFileById(fileId))
                return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
            var file = _this.getFileById(fileId);
            var result = _this._seek(fileId, offset.getNumber(), whence);
            file.setAsyncOperationNow(Integer64.fromNumber(result));
            return 0;
        });
        this.sceIoLseek = createNativeFunction(0x27EB27B8, 150, 'long', 'int/long/int', this, function (fileId, offset, whence) {
            var result = _this._seek(fileId, offset.getNumber(), whence);
            return Integer64.fromNumber(result);
        });
        this.sceIoLseek32 = createNativeFunction(0x68963324, 150, 'int', 'int/int/int', this, function (fileId, offset, whence) {
            var result = _this._seek(fileId, offset, whence);
            return result;
        });
        this.sceIoMkdir = createNativeFunction(0x06A70004, 150, 'uint', 'string/int', this, function (path, accessMode) {
            log.warn('Not implemented: sceIoMkdir("' + path + '", ' + accessMode.toString(8) + ')');
            return 0;
        });
        this.sceIoDopen = createNativeFunction(0xB29DDF9C, 150, 'uint', 'string', this, function (path) {
            log.log('sceIoDopen("' + path + '")');
            return _this.context.fileManager.openDirectoryAsync(path).then(function (directory) {
                log.log('opened directory "' + path + '"');
                return _this.directoryUids.allocate(directory);
            }).catch(function (error) {
                log.error(error);
                return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
            });
        });
        this.sceIoDclose = createNativeFunction(0xEB092469, 150, 'uint', 'int', this, function (fileId) {
            if (!_this.directoryUids.has(fileId))
                return -1;
            _this.directoryUids.get(fileId).close();
            _this.directoryUids.remove(fileId);
            return 0;
        });
        this.sceIoDread = createNativeFunction(0xE3EB004C, 150, 'int', 'int/void*', this, function (fileId, hleIoDirentPtr) {
            if (!_this.directoryUids.has(fileId))
                return -1;
            var directory = _this.directoryUids.get(fileId);
            if (directory.left > 0) {
                var stat = directory.read();
                var hleIoDirent = new _structs.HleIoDirent();
                hleIoDirent.name = stat.name;
                hleIoDirent.stat = _this._vfsStatToSceIoStat(stat);
                hleIoDirent.privateData = 0;
                _structs.HleIoDirent.struct.write(hleIoDirentPtr, hleIoDirent);
            }
            return directory.left;
        });
        this.sceIoChangeAsyncPriority = createNativeFunction(0xB293727F, 150, 'int', 'int/int', this, function (fileId, priority) {
            return 0;
        });
    }
    IoFileMgrForUser.prototype.hasFileById = function (id) { return this.fileUids.has(id); };
    IoFileMgrForUser.prototype.getFileById = function (id) { return this.fileUids.get(id); };
    IoFileMgrForUser.prototype._sceIoOpenAsync = function (filename, flags, mode) {
        var _this = this;
        return this.context.fileManager.openAsync(filename, flags, mode)
            .then(function (file) {
            return _this.fileUids.allocate(file);
        })
            .catch(function (e) {
            log.error('Not found', filename, e);
            return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
        });
    };
    IoFileMgrForUser.prototype._sceIoWaitAsyncCB = function (thread, fileId, resultPointer) {
        thread.state.LO = fileId;
        if (!this.fileUids.has(fileId)) {
            if (DebugOnce('_sceIoWaitAsyncCB', 100))
                log.info('_sceIoWaitAsyncCB', fileId, 'file not found');
            return Promise2.resolve(SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND);
        }
        if (!this.hasFileById(fileId))
            return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
        var file = this.getFileById(fileId);
        if (file.asyncOperation) {
            if (DebugOnce('_sceIoWaitAsyncCB', 100))
                log.info(thread.name, ':_sceIoWaitAsyncCB', fileId, 'completed');
            return file.asyncOperation.then(function (result) {
                if (DebugOnce('_sceIoWaitAsyncCB', 100))
                    log.info(thread.name, ':_sceIoWaitAsyncCB', fileId, 'result: ', result.getNumber());
                resultPointer.writeInt64(result);
                return 0;
            });
        }
        else {
            if (DebugOnce('_sceIoWaitAsyncCB', 100))
                log.info(thread.name, ':_sceIoWaitAsyncCB', fileId, 'incompleted');
            resultPointer.writeInt64(Integer64.fromNumber(0));
            return Promise2.resolve(1);
        }
    };
    IoFileMgrForUser.prototype._vfsStatToSceIoStat = function (stat) {
        var stat2 = new _structs.SceIoStat();
        stat2.mode = 0;
        stat2.size = stat.size;
        stat2.timeCreation = _structs.ScePspDateTime.fromDate(stat.timeCreation);
        stat2.timeLastAccess = _structs.ScePspDateTime.fromDate(stat.timeLastAccess);
        stat2.timeLastModification = _structs.ScePspDateTime.fromDate(stat.timeLastModification);
        stat2.deviceDependentData[0] = stat.dependentData0 || 0;
        stat2.deviceDependentData[1] = stat.dependentData1 || 0;
        stat2.attributes = 0;
        if (stat.isDirectory) {
            stat2.mode = 0x1000;
            stat2.attributes |= _structs.IOFileModes.Directory;
            stat2.attributes |= _structs.IOFileModes.CanRead;
        }
        else {
            stat2.mode = 0x2000;
            stat2.attributes |= _structs.IOFileModes.File;
            stat2.attributes |= _structs.IOFileModes.CanExecute;
            stat2.attributes |= _structs.IOFileModes.CanRead;
            stat2.attributes |= _structs.IOFileModes.CanWrite;
        }
        return stat2;
    };
    IoFileMgrForUser.prototype._seek = function (fileId, offset, whence) {
        if (!this.hasFileById(fileId))
            return SceKernelErrors.ERROR_ERRNO_FILE_NOT_FOUND;
        var file = this.getFileById(fileId);
        switch (whence) {
            case _structs.SeekAnchor.Set:
                file.cursor = 0 + offset;
                break;
            case _structs.SeekAnchor.Cursor:
                file.cursor = file.cursor + offset;
                break;
            case _structs.SeekAnchor.End:
                file.cursor = file.entry.size + offset;
                break;
        }
        return file.cursor;
    };
    return IoFileMgrForUser;
})();
exports.IoFileMgrForUser = IoFileMgrForUser;

},
"src/hle/module/sceAtrac3plus": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var SceKernelErrors = require('../SceKernelErrors');
var _riff = require('../../format/riff');
_riff.Riff;
var Riff = _riff.Riff;
var createNativeFunction = _utils.createNativeFunction;
var sceAtrac3plus = (function () {
    function sceAtrac3plus(context) {
        var _this = this;
        this.context = context;
        this._atrac3Ids = new UidCollection();
        this.sceAtracSetDataAndGetID = createNativeFunction(0x7A20E7AF, 150, 'uint', 'byte[]', this, function (data) {
            return _this._atrac3Ids.allocate(Atrac3.fromStream(data));
        });
        this.sceAtracSetData = createNativeFunction(0x0E2A73AB, 150, 'uint', 'int/byte[]', this, function (id, data) {
            if (!_this.hasById(id))
                return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
            var atrac3 = _this.getById(id);
            atrac3.setDataStream(data);
            return 0;
        });
        this.sceAtracGetSecondBufferInfo = createNativeFunction(0x83E85EA0, 150, 'uint', 'int/void*/void*', this, function (id, puiPosition, puiDataByte) {
            if (!_this.hasById(id))
                return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
            var atrac3 = _this.getById(id);
            puiPosition.writeInt32(0);
            puiDataByte.writeInt32(0);
            return SceKernelErrors.ERROR_ATRAC_SECOND_BUFFER_NOT_NEEDED;
        });
        this.sceAtracSetSecondBuffer = createNativeFunction(0x83BF7AFD, 150, 'uint', 'int/void*/uint', this, function (id, pucSecondBufferAddr, uiSecondBufferByte) {
            return 0;
        });
        this.sceAtracReleaseAtracID = createNativeFunction(0x61EB33F5, 150, 'uint', 'int', this, function (id) {
            _this._atrac3Ids.remove(id);
            return 0;
        });
        this.sceAtracDecodeData = createNativeFunction(0x6A8C3CD5, 150, 'uint', 'int/void*/void*/void*/void*', this, function (id, samplesOutPtr, decodedSamplesCountPtr, reachedEndPtr, remainingFramesToDecodePtr) {
            if (!_this.hasById(id))
                return Promise2.resolve(SceKernelErrors.ATRAC_ERROR_NO_ATRACID);
            var atrac3 = _this.getById(id);
            return atrac3.decodeAsync(samplesOutPtr).then(function (decodedSamples) {
                var reachedEnd = 0;
                var remainingFramesToDecode = atrac3.remainingFrames;
                function outputPointers() {
                    if (reachedEndPtr)
                        reachedEndPtr.writeInt32(reachedEnd);
                    if (decodedSamplesCountPtr)
                        decodedSamplesCountPtr.writeInt32(decodedSamples / atrac3.format.atracChannels);
                    if (remainingFramesToDecodePtr)
                        remainingFramesToDecodePtr.writeInt32(remainingFramesToDecode);
                }
                if (atrac3.decodingReachedEnd) {
                    if (atrac3.numberOfLoops == 0) {
                        decodedSamples = 0;
                        reachedEnd = 1;
                        remainingFramesToDecode = 0;
                        outputPointers();
                        return SceKernelErrors.ERROR_ATRAC_ALL_DATA_DECODED;
                    }
                    if (atrac3.numberOfLoops > 0)
                        atrac3.numberOfLoops--;
                    atrac3.currentSample = (atrac3.loopInfoList.length > 0) ? atrac3.loopInfoList[0].startSample : 0;
                }
                outputPointers();
                return 0;
            });
        });
        this.sceAtracGetRemainFrame = createNativeFunction(0x9AE849A7, 150, 'uint', 'int/void*', this, function (id, remainFramePtr) {
            if (!_this.hasById(id))
                return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
            var atrac3 = _this.getById(id);
            if (remainFramePtr)
                remainFramePtr.writeInt32(atrac3.remainingFrames);
            return 0;
        });
        this.sceAtracGetBitrate = createNativeFunction(0xA554A158, 150, 'uint', 'int/void*', this, function (id, bitratePtr) {
            if (!_this.hasById(id))
                return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
            var atrac3 = _this.getById(id);
            bitratePtr.writeInt32(atrac3.bitrate);
            return 0;
        });
        this.sceAtracGetChannel = createNativeFunction(0x31668baa, 150, 'uint', 'int/void*', this, function (id, channelsPtr) {
            if (!_this.hasById(id))
                return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
            var atrac3 = _this.getById(id);
            channelsPtr.writeInt32(atrac3.format.atracChannels);
            return 0;
        });
        this.sceAtracGetMaxSample = createNativeFunction(0xD6A5F2F7, 150, 'uint', 'int/void*', this, function (id, maxNumberOfSamplesPtr) {
            if (!_this.hasById(id))
                return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
            var atrac3 = _this.getById(id);
            maxNumberOfSamplesPtr.writeInt32(atrac3.maximumSamples);
            return 0;
        });
        this.sceAtracGetNextSample = createNativeFunction(0x36FAABFB, 150, 'uint', 'int/void*', this, function (id, numberOfSamplesInNextFramePtr) {
            if (!_this.hasById(id))
                return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
            var atrac3 = _this.getById(id);
            numberOfSamplesInNextFramePtr.writeInt32(atrac3.getNumberOfSamplesInNextFrame());
            return 0;
        });
        this.sceAtracGetAtracID = createNativeFunction(0x780F88D1, 150, 'uint', 'int', this, function (codecType) {
            if (codecType != CodecType.PSP_MODE_AT_3 && codecType != CodecType.PSP_MODE_AT_3_PLUS) {
                return SceKernelErrors.ATRAC_ERROR_INVALID_CODECTYPE;
            }
            return _this._atrac3Ids.allocate(new Atrac3(-1));
        });
        this.sceAtracAddStreamData = createNativeFunction(0x7DB31251, 150, 'uint', 'int/int', this, function (id, bytesToAdd) {
            if (!_this.hasById(id))
                return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
            var atrac3 = _this.getById(id);
            return 0;
        });
        this.sceAtracGetStreamDataInfo = createNativeFunction(0x5D268707, 150, 'uint', 'int/void*/void*/void*', this, function (id, writePointerPointer, availableBytesPtr, readOffsetPtr) {
            if (!_this.hasById(id))
                return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
            var atrac3 = _this.getById(id);
            writePointerPointer.writeInt32(0);
            availableBytesPtr.writeInt32(0);
            readOffsetPtr.writeInt32(0);
            return 0;
        });
        this.sceAtracGetNextDecodePosition = createNativeFunction(0xE23E3A35, 150, 'uint', 'int/void*', this, function (id, samplePositionPtr) {
            if (!_this.hasById(id))
                return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
            var atrac3 = _this.getById(id);
            if (atrac3.decodingReachedEnd)
                return SceKernelErrors.ERROR_ATRAC_ALL_DATA_DECODED;
            if (samplePositionPtr)
                samplePositionPtr.writeInt32(atrac3.currentSample);
            return 0;
        });
        this.sceAtracGetSoundSample = createNativeFunction(0xA2BBA8BE, 150, 'uint', 'int/void*/void*/void*', this, function (id, endSamplePtr, loopStartSamplePtr, loopEndSamplePtr) {
            if (!_this.hasById(id))
                return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
            var atrac3 = _this.getById(id);
            var hasLoops = (atrac3.loopInfoList != null) && (atrac3.loopInfoList.length > 0);
            if (endSamplePtr)
                endSamplePtr.writeInt32(atrac3.fact.endSample);
            if (loopStartSamplePtr)
                loopStartSamplePtr.writeInt32(-1);
            if (loopEndSamplePtr)
                loopEndSamplePtr.writeInt32(-1);
            return 0;
        });
        this.sceAtracSetLoopNum = createNativeFunction(0x868120B5, 150, 'uint', 'int/int', this, function (id, numberOfLoops) {
            if (!_this.hasById(id))
                return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
            var atrac3 = _this.getById(id);
            atrac3.numberOfLoops = numberOfLoops;
            return 0;
        });
        this.sceAtracGetBufferInfoForReseting = createNativeFunction(0xCA3CA3D2, 150, 'uint', 'int/uint/void*', this, function (id, uiSample, bufferInfoPtr) {
            throw (new Error("Not implemented sceAtracGetBufferInfoForReseting"));
            return 0;
        });
        this.sceAtracResetPlayPosition = createNativeFunction(0x644E5607, 150, 'uint', 'int/uint/uint/uint', this, function (id, uiSample, uiWriteByteFirstBuf, uiWriteByteSecondBuf) {
            throw (new Error("Not implemented sceAtracResetPlayPosition"));
            return 0;
        });
        this.sceAtracGetInternalErrorInfo = createNativeFunction(0xE88F759B, 150, 'uint', 'int/void*', this, function (id, errorResultPtr) {
            throw (new Error("Not implemented sceAtracGetInternalErrorInfo"));
            return 0;
        });
        this.sceAtracGetOutputChannel = createNativeFunction(0xB3B5D042, 150, 'uint', 'int/void*', this, function (id, outputChannelPtr) {
            if (!_this.hasById(id))
                return SceKernelErrors.ATRAC_ERROR_NO_ATRACID;
            var atrac3 = _this.getById(id);
            var sceAudioChReserve = _this.context.moduleManager.getByName('sceAudio').getByName('sceAudioChReserve').nativeCall;
            var channel = sceAudioChReserve(-1, atrac3.maximumSamples, 0);
            outputChannelPtr.writeInt32(channel);
            return 0;
        });
    }
    sceAtrac3plus.prototype.hasById = function (id) { return this._atrac3Ids.has(id); };
    sceAtrac3plus.prototype.getById = function (id) {
        return this._atrac3Ids.get(id);
    };
    return sceAtrac3plus;
})();
exports.sceAtrac3plus = sceAtrac3plus;
var Atrac3 = (function () {
    function Atrac3(id) {
        this.id = id;
        this.format = new At3FormatStruct();
        this.fact = new FactStruct();
        this.smpl = new SmplStruct();
        this.loopInfoList = [];
        this.dataStream = Stream.fromArray([]);
        this.numberOfLoops = 0;
        this.currentSample = 0;
        this.codecType = CodecType.PSP_MODE_AT_3_PLUS;
    }
    Atrac3.prototype.setDataStream = function (data) {
        var _this = this;
        this.atrac3Decoder = new MediaEngine.Atrac3Decoder();
        Riff.fromStreamWithHandlers(data, {
            'fmt ': function (stream) { _this.format = At3FormatStruct.struct.read(stream); },
            'fact': function (stream) { _this.fact = FactStruct.struct.read(stream); },
            'smpl': function (stream) {
                _this.smpl = SmplStruct.struct.read(stream);
                _this.loopInfoList = StructArray(LoopInfoStruct.struct, _this.smpl.loopCount).read(stream);
            },
            'data': function (stream) { _this.dataStream = stream; },
        });
        this.firstDataChunk = this.dataStream.readBytes(this.format.blockSize).subarray(0);
        return this;
    };
    Object.defineProperty(Atrac3.prototype, "bitrate", {
        get: function () {
            var _atracBitrate = Math.floor((this.format.bytesPerFrame * 352800) / 1000);
            if (this.codecType == CodecType.PSP_MODE_AT_3_PLUS) {
                return ((_atracBitrate >> 11) + 8) & 0xFFFFFFF0;
            }
            else {
                return (_atracBitrate + 511) >> 10;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Atrac3.prototype, "maximumSamples", {
        get: function () {
            this.format.compressionCode;
            switch (this.codecType) {
                case CodecType.PSP_MODE_AT_3_PLUS: return 0x800;
                case CodecType.PSP_MODE_AT_3: return 0x400;
                default: throw (new Error("Unknown codec type"));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Atrac3.prototype, "endSample", {
        get: function () {
            return this.fact.endSample;
        },
        enumerable: true,
        configurable: true
    });
    Atrac3.prototype.getNumberOfSamplesInNextFrame = function () {
        return Math.min(this.maximumSamples, this.endSample - this.currentSample);
    };
    Object.defineProperty(Atrac3.prototype, "remainingFrames", {
        get: function () {
            if (this.format.blockSize == 0)
                return -1;
            return (this.dataStream.available / this.format.blockSize);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Atrac3.prototype, "decodingReachedEnd", {
        get: function () {
            return this.remainingFrames <= 0;
        },
        enumerable: true,
        configurable: true
    });
    Atrac3.prototype.decodeAsync = function (samplesOutPtr) {
        if (this.dataStream.available < this.format.blockSize)
            return Promise2.resolve(0);
        var blockData = this.dataStream.readBytes(this.format.blockSize);
        this.currentSample++;
        var outPromise;
        if (Atrac3.useWorker) {
            outPromise = WorkerTask.executeAsync(function (id, blockData, firstDataChunk) {
                self['window'] = self;
                var _self = self;
                if (!_self['MediaEngine']) {
                    importScripts('source/polyfills/promise.js');
                    importScripts('data/MediaEngine.js');
                    _self['MediaEngine'] = MediaEngine;
                }
                var atrac3Decoder = 'atrac3Decoder_' + id;
                if (!_self[atrac3Decoder]) {
                    _self[atrac3Decoder] = new MediaEngine.Atrac3Decoder();
                    _self[atrac3Decoder].initWithHeader(firstDataChunk);
                }
                return _self[atrac3Decoder].decode(blockData);
            }, [this.id, blockData, this.firstDataChunk]);
        }
        else {
            if (this.firstDataChunk) {
                this.atrac3Decoder.initWithHeader(this.firstDataChunk);
            }
            outPromise = Promise2.resolve(this.atrac3Decoder.decode(blockData));
        }
        this.firstDataChunk = null;
        return outPromise.then(function (out) {
            for (var n = 0; n < out.length; n++)
                samplesOutPtr.writeInt16(out[n]);
            return out.length;
        });
    };
    Atrac3.fromStream = function (data) {
        return new Atrac3(Atrac3.lastId++).setDataStream(data);
    };
    Atrac3.useWorker = true;
    Atrac3.lastId = 0;
    return Atrac3;
})();
var FactStruct = (function () {
    function FactStruct() {
        this.endSample = 0;
        this.sampleOffset = 0;
    }
    FactStruct.struct = StructClass.create(FactStruct, [
        { endSample: Int32 },
        { sampleOffset: Int32 },
    ]);
    return FactStruct;
})();
var SmplStruct = (function () {
    function SmplStruct() {
        this.unknown = [0, 0, 0, 0, 0, 0, 0];
        this.loopCount = 0;
        this.unknown2 = 0;
    }
    SmplStruct.struct = StructClass.create(SmplStruct, [
        { unknown: StructArray(Int32, 7) },
        { loopCount: Int32 },
        { unknown2: Int32 },
    ]);
    return SmplStruct;
})();
var LoopInfoStruct = (function () {
    function LoopInfoStruct() {
        this.cuePointID = 0;
        this.type = 0;
        this.startSample = 0;
        this.endSample = 0;
        this.fraction = 0;
        this.playCount = 0;
    }
    LoopInfoStruct.struct = StructClass.create(LoopInfoStruct, [
        { cuePointID: Int32 },
        { type: Int32 },
        { startSample: Int32 },
        { endSample: Int32 },
        { fraction: Int32 },
        { playCount: Int32 },
    ]);
    return LoopInfoStruct;
})();
var At3FormatStruct = (function () {
    function At3FormatStruct() {
        this.compressionCode = 0;
        this.atracChannels = 0;
        this.bitrate = 0;
        this.averageBytesPerSecond = 0;
        this.blockAlignment = 0;
        this.bytesPerFrame = 0;
        this.unknown = [0, 0, 0, 0];
        this.omaInfo = 0;
        this._unk2 = 0;
        this._blockSize = 0;
    }
    Object.defineProperty(At3FormatStruct.prototype, "blockSize", {
        get: function () { return (this._blockSize & 0x3FF) * 8 + 8; },
        enumerable: true,
        configurable: true
    });
    At3FormatStruct.struct = StructClass.create(At3FormatStruct, [
        { compressionCode: UInt16 },
        { atracChannels: UInt16 },
        { bitrate: UInt32 },
        { averageBytesPerSecond: UInt16 },
        { blockAlignment: UInt16 },
        { bytesPerFrame: UInt16 },
        { _unk: UInt16 },
        { unknown: StructArray(UInt32, 6) },
        { _unk2: UInt16_b },
        { _blockSize: UInt16_b },
    ]);
    return At3FormatStruct;
})();
var CodecType;
(function (CodecType) {
    CodecType[CodecType["PSP_MODE_AT_3_PLUS"] = 4096] = "PSP_MODE_AT_3_PLUS";
    CodecType[CodecType["PSP_MODE_AT_3"] = 4097] = "PSP_MODE_AT_3";
})(CodecType || (CodecType = {}));

},
"src/hle/module/sceAudio": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var SceKernelErrors = require('../SceKernelErrors');
var _audio = require('../../core/audio');
var createNativeFunction = _utils.createNativeFunction;
var sceAudio = (function () {
    function sceAudio(context) {
        var _this = this;
        this.context = context;
        this.channels = [];
        this.sceAudioOutput2Reserve = createNativeFunction(0x01562BA3, 150, 'uint', 'int', this, function (sampleCount) {
            console.warn('sceAudioOutput2Reserve not implemented!');
            return 0;
        });
        this.sceAudioOutput2OutputBlocking = createNativeFunction(0x2D53F36E, 150, 'uint', 'int/void*', this, function (volume, buffer) {
            return waitAsync(10).then(function () { return 0; });
        });
        this.sceAudioChReserve = createNativeFunction(0x5EC81C55, 150, 'uint', 'int/int/int', this, function (channelId, sampleCount, format) {
            if (channelId >= _this.channels.length)
                return -1;
            if (channelId < 0) {
                channelId = _this.channels.first(function (channel) { return !channel.allocated; }).id;
                if (channelId === undefined) {
                    console.warn('Not implemented sceAudio.sceAudioChReserve');
                    return -2;
                }
            }
            var channel = _this.channels[channelId];
            channel.allocated = true;
            channel.sampleCount = sampleCount;
            channel.format = format;
            channel.channel = _this.context.audio.createChannel();
            channel.channel.start();
            return channelId;
        });
        this.sceAudioChRelease = createNativeFunction(0x6FC46853, 150, 'uint', 'int', this, function (channelId) {
            if (!_this.isValidChannel(channelId))
                return SceKernelErrors.ERROR_AUDIO_INVALID_CHANNEL;
            var channel = _this.getChannelById(channelId);
            channel.allocated = false;
            channel.channel.stop();
            channel.channel = null;
            return 0;
        });
        this.sceAudioChangeChannelConfig = createNativeFunction(0x95FD0C2D, 150, 'uint', 'int/int', this, function (channelId, format) {
            if (!_this.isValidChannel(channelId))
                return SceKernelErrors.ERROR_AUDIO_INVALID_CHANNEL;
            var channel = _this.getChannelById(channelId);
            channel.format = format;
            return 0;
        });
        this.sceAudioSetChannelDataLen = createNativeFunction(0xCB2E439E, 150, 'uint', 'int/int', this, function (channelId, sampleCount) {
            if (!_this.isValidChannel(channelId))
                return SceKernelErrors.ERROR_AUDIO_INVALID_CHANNEL;
            var channel = _this.getChannelById(channelId);
            channel.sampleCount = sampleCount;
            return 0;
        });
        this.sceAudioOutputPannedBlocking = createNativeFunction(0x13F592BC, 150, 'uint', 'int/int/int/void*', this, function (channelId, leftVolume, rightVolume, buffer) {
            if (!buffer)
                return -1;
            if (!_this.isValidChannel(channelId))
                return SceKernelErrors.ERROR_AUDIO_INVALID_CHANNEL;
            var channel = _this.getChannelById(channelId);
            var result = channel.channel.playAsync(_audio.PspAudio.convertS16ToF32(channel.numberOfChannels, buffer.readInt16Array(channel.totalSampleCount)));
            if (!(result instanceof Promise2))
                return result;
            return new WaitingThreadInfo('sceAudioOutputPannedBlocking', channel, result, AcceptCallbacks.NO);
        });
        this.sceAudioOutputBlocking = createNativeFunction(0x136CAF51, 150, 'uint', 'int/int/void*', this, function (channelId, volume, buffer) {
            if (!buffer)
                return -1;
            if (!_this.isValidChannel(channelId))
                return SceKernelErrors.ERROR_AUDIO_INVALID_CHANNEL;
            var channel = _this.getChannelById(channelId);
            var result = channel.channel.playAsync(_audio.PspAudio.convertS16ToF32(channel.numberOfChannels, buffer.readInt16Array(channel.totalSampleCount)));
            return result;
        });
        this.sceAudioOutput = createNativeFunction(0x8C1009B2, 150, 'uint', 'int/int/void*', this, function (channelId, volume, buffer) {
            if (!_this.isValidChannel(channelId))
                return SceKernelErrors.ERROR_AUDIO_INVALID_CHANNEL;
            var channel = _this.getChannelById(channelId);
            channel.channel.playAsync(_audio.PspAudio.convertS16ToF32(channel.numberOfChannels, buffer.readInt16Array(channel.totalSampleCount)));
            return 0;
        });
        this.sceAudioOutputPanned = createNativeFunction(0xE2D56B2D, 150, 'uint', 'int/int/int/void*', this, function (channelId, leftVolume, rightVolume, buffer) {
            if (!_this.isValidChannel(channelId))
                return SceKernelErrors.ERROR_AUDIO_INVALID_CHANNEL;
            var channel = _this.getChannelById(channelId);
            channel.channel.playAsync(_audio.PspAudio.convertS16ToF32(channel.numberOfChannels, buffer.readInt16Array(channel.totalSampleCount)));
            return 0;
        });
        this.sceAudioChangeChannelVolume = createNativeFunction(0xB7E1D8E7, 150, 'uint', 'int/int/int', this, function (channelId, volumeLeft, volumeRight) {
            console.warn("Not implemented sceAudioChangeChannelVolume");
            return 0;
        });
        this.sceAudioGetChannelRestLen = createNativeFunction(0xB7E1D8E7, 150, 'uint', 'int', this, function (channelId) {
            console.warn("Not implemented sceAudioGetChannelRestLen");
            return 0;
        });
        for (var n = 0; n < 8; n++)
            this.channels.push(new Channel(n));
    }
    sceAudio.prototype.isValidChannel = function (channelId) {
        return (channelId >= 0 && channelId < this.channels.length);
    };
    sceAudio.prototype.getChannelById = function (id) {
        return this.channels[id];
    };
    return sceAudio;
})();
exports.sceAudio = sceAudio;
var AudioFormat;
(function (AudioFormat) {
    AudioFormat[AudioFormat["Stereo"] = 0] = "Stereo";
    AudioFormat[AudioFormat["Mono"] = 16] = "Mono";
})(AudioFormat || (AudioFormat = {}));
var Channel = (function () {
    function Channel(id) {
        this.id = id;
        this.allocated = false;
        this.sampleCount = 44100;
        this.format = AudioFormat.Stereo;
    }
    Object.defineProperty(Channel.prototype, "totalSampleCount", {
        get: function () {
            return this.sampleCount * this.numberOfChannels;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Channel.prototype, "numberOfChannels", {
        get: function () {
            return (this.format == AudioFormat.Stereo) ? 2 : 1;
        },
        enumerable: true,
        configurable: true
    });
    return Channel;
})();

},
"src/hle/module/sceCtrl": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var _manager = require('../manager');
_manager.Thread;
var _controller = require('../../core/controller');
var createNativeFunction = _utils.createNativeFunction;
var SceCtrlData = _controller.SceCtrlData;
var sceCtrl = (function () {
    function sceCtrl(context) {
        var _this = this;
        this.context = context;
        this.sceCtrlPeekBufferPositive = createNativeFunction(0x3A622550, 150, 'uint', 'void*/int', this, function (sceCtrlDataPtr, count) {
            for (var n = 0; n < count; n++)
                _controller.SceCtrlData.struct.write(sceCtrlDataPtr, _this.context.controller.data);
            return count;
        });
        this.sceCtrlReadBufferPositive = createNativeFunction(0x1F803938, 150, 'uint', 'Thread/void*/int', this, function (thread, sceCtrlDataPtr, count) {
            //console.log('sceCtrlReadBufferPositive');
            for (var n = 0; n < count; n++)
                _controller.SceCtrlData.struct.write(sceCtrlDataPtr, _this.context.controller.data);
            return new WaitingThreadInfo('sceCtrlReadBufferPositive', _this.context.display, _this.context.display.waitVblankStartAsync(thread).then(function (v) { return count; }), AcceptCallbacks.NO);
        });
        this.sceCtrlSetSamplingCycle = createNativeFunction(0x6A2774F3, 150, 'uint', 'int', this, function (samplingCycle) {
            return 0;
        });
        this.sceCtrlSetSamplingMode = createNativeFunction(0x1F4011E6, 150, 'uint', 'int', this, function (samplingMode) {
            return 0;
        });
        this.lastLatchData = new SceCtrlData();
        this.sceCtrlReadLatch = createNativeFunction(0x0B588501, 150, 'uint', 'void*', this, function (currentLatchPtr) {
            try {
                return _this._peekLatch(currentLatchPtr);
            }
            finally {
                _this.lastLatchData = _this.context.controller.data;
                _this.context.controller.latchSamplingCount = 0;
            }
        });
        this.sceCtrlSetIdleCancelThreshold = createNativeFunction(0xA7144800, 150, 'uint', 'int/int', this, function (idlereset, idleback) {
            return 0;
        });
    }
    sceCtrl.prototype._peekLatch = function (currentLatchPtr) {
        var ButtonsNew = this.context.controller.data.buttons;
        var ButtonsOld = this.lastLatchData.buttons;
        var ButtonsChanged = ButtonsOld ^ ButtonsNew;
        currentLatchPtr.writeInt32(ButtonsNew & ButtonsChanged);
        currentLatchPtr.writeInt32(ButtonsOld & ButtonsChanged);
        currentLatchPtr.writeInt32(ButtonsNew);
        currentLatchPtr.writeInt32((ButtonsOld & ~ButtonsNew) & ButtonsChanged);
        return this.context.controller.latchSamplingCount;
    };
    return sceCtrl;
})();
exports.sceCtrl = sceCtrl;

},
"src/hle/module/sceDisplay": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var _manager = require('../manager');
_manager.Thread;
var _display = require('../../core/display');
var createNativeFunction = _utils.createNativeFunction;
var PspDisplay = _display.PspDisplay;
var sceDisplay = (function () {
    function sceDisplay(context) {
        var _this = this;
        this.context = context;
        this.mode = 0;
        this.width = 512;
        this.height = 272;
        this.sceDisplaySetMode = createNativeFunction(0x0E20F177, 150, 'uint', 'uint/uint/uint', this, function (mode, width, height) {
            console.info(sprintf("sceDisplay.sceDisplaySetMode(mode: %d, width: %d, height: %d)", mode, width, height));
            _this.mode = mode;
            _this.width = width;
            _this.height = height;
            return 0;
        }, { tryCatch: false });
        this.sceDisplayGetMode = createNativeFunction(0xDEA197D4, 150, 'uint', 'void*/void*/void*', this, function (modePtr, widthPtr, heightPtr) {
            if (modePtr)
                modePtr.writeInt32(_this.mode);
            if (widthPtr)
                widthPtr.writeInt32(_this.width);
            if (heightPtr)
                heightPtr.writeInt32(_this.height);
            return 0;
        }, { tryCatch: false });
        this.sceDisplayWaitVblank = createNativeFunction(0x36CDFADE, 150, 'uint', 'Thread/int', this, function (thread, cycleNum) {
            return _this._waitVblankAsync(thread, AcceptCallbacks.NO);
        }, { tryCatch: false });
        this.sceDisplayWaitVblankCB = createNativeFunction(0x8EB9EC49, 150, 'uint', 'Thread/int', this, function (thread, cycleNum) {
            return _this._waitVblankAsync(thread, AcceptCallbacks.YES);
        }, { tryCatch: false });
        this.sceDisplayWaitVblankStart = createNativeFunction(0x984C27E7, 150, 'uint', 'Thread', this, function (thread) {
            return _this._waitVblankStartAsync(thread, AcceptCallbacks.NO);
        }, { tryCatch: false });
        this.sceDisplayWaitVblankStartCB = createNativeFunction(0x46F186C3, 150, 'uint', 'Thread', this, function (thread) {
            return _this._waitVblankStartAsync(thread, AcceptCallbacks.YES);
        }, { tryCatch: false });
        this.sceDisplayGetVcount = createNativeFunction(0x9C6EAAD7, 150, 'int', '', this, function () {
            _this.context.display.updateTime();
            return _this.context.display.vblankCount;
        }, { tryCatch: false });
        this.sceDisplayGetFramePerSec = createNativeFunction(0xDBA6C4C4, 150, 'float', '', this, function () {
            return PspDisplay.PROCESSED_PIXELS_PER_SECOND * PspDisplay.CYCLES_PER_PIXEL / (PspDisplay.PIXELS_IN_A_ROW * PspDisplay.NUMBER_OF_ROWS);
        }, { tryCatch: false });
        this.sceDisplayIsVblank = createNativeFunction(0x4D4E10EC, 150, 'int', '', this, function () {
            return (_this.context.display.secondsLeftForVblank == 0);
        }, { tryCatch: false });
        this.sceDisplaySetFrameBuf = createNativeFunction(0x289D82FE, 150, 'uint', 'uint/int/uint/uint', this, function (address, bufferWidth, pixelFormat, sync) {
            _this.context.display.address = address;
            _this.context.display.bufferWidth = bufferWidth;
            _this.context.display.pixelFormat = pixelFormat;
            _this.context.display.sync = sync;
            return 0;
        }, { tryCatch: false });
        this.sceDisplayGetFrameBuf = createNativeFunction(0xEEDA2E54, 150, 'uint', 'void*/void*/void*/void*', this, function (topaddrPtr, bufferWidthPtr, pixelFormatPtr, syncPtr) {
            if (topaddrPtr)
                topaddrPtr.writeInt32(_this.context.display.address);
            if (bufferWidthPtr)
                bufferWidthPtr.writeInt32(_this.context.display.bufferWidth);
            if (pixelFormatPtr)
                pixelFormatPtr.writeInt32(_this.context.display.pixelFormat);
            if (syncPtr)
                syncPtr.writeInt32(_this.context.display.sync);
            return 0;
        }, { tryCatch: false });
        this.sceDisplayGetCurrentHcount = createNativeFunction(0x773DD3A3, 150, 'uint', '', this, function () {
            _this.context.display.updateTime();
            return _this.context.display.hcountTotal;
        }, { tryCatch: false });
    }
    sceDisplay.prototype._waitVblankAsync = function (thread, acceptCallbacks) {
        this.context.display.updateTime();
        return new WaitingThreadInfo('_waitVblankAsync', this.context.display, this.context.display.waitVblankAsync(thread), acceptCallbacks);
    };
    sceDisplay.prototype._waitVblankStartAsync = function (thread, acceptCallbacks) {
        this.context.display.updateTime();
        return new WaitingThreadInfo('_waitVblankStartAsync', this.context.display, this.context.display.waitVblankStartAsync(thread), acceptCallbacks);
    };
    return sceDisplay;
})();
exports.sceDisplay = sceDisplay;

},
"src/hle/module/sceDmac": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var SceKernelErrors = require('../SceKernelErrors');
var sceDmac = (function () {
    function sceDmac(context) {
        var _this = this;
        this.context = context;
        this.sceDmacMemcpy = createNativeFunction(0x617F3FE6, 150, 'uint', 'uint/uint/int', this, function (destination, source, size) {
            return _this._sceDmacMemcpy(destination, source, size);
        });
        this.sceDmacTryMemcpy = createNativeFunction(0xD97F94D8, 150, 'uint', 'uint/uint/int', this, function (destination, source, size) {
            return _this._sceDmacMemcpy(destination, source, size);
        });
    }
    sceDmac.prototype._sceDmacMemcpy = function (destination, source, size) {
        if (size == 0)
            return SceKernelErrors.ERROR_INVALID_SIZE;
        if (destination == 0)
            return SceKernelErrors.ERROR_INVALID_POINTER;
        if (source == 0)
            return SceKernelErrors.ERROR_INVALID_POINTER;
        this.context.memory.copy(source, destination, size);
        return Promise2.resolve(0);
    };
    return sceDmac;
})();
exports.sceDmac = sceDmac;

},
"src/hle/module/sceGe_user": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var _gpu = require('../../core/gpu');
_gpu.PspGpuCallback;
var PspGpuCallback = _gpu.PspGpuCallback;
var sceGe_user = (function () {
    function sceGe_user(context) {
        var _this = this;
        this.context = context;
        this.eDRAMMemoryWidth = 0;
        this.sceGeEdramSetAddrTranslation = createNativeFunction(0xB77905EA, 150, 'uint', 'int', this, function (size) {
            try {
                return _this.eDRAMMemoryWidth;
            }
            finally {
                _this.eDRAMMemoryWidth = size;
            }
        });
        this.sceGeSetCallback = createNativeFunction(0xA4FC06A4, 150, 'uint', 'Thread/void*', this, function (thread, callbackDataPtr) {
            var callbacks = _this.context.gpu.callbacks;
            var info = CallbackData.struct.read(callbackDataPtr);
            return callbacks.allocate(new PspGpuCallback(thread.state, info.signalFunction, info.signalArgument, info.finishFunction, info.finishArgument));
        });
        this.sceGeUnsetCallback = createNativeFunction(0x05DB22CE, 150, 'uint', 'int', this, function (callbackId) {
            _this.context.gpu.callbacks.remove(callbackId);
            return 0;
        });
        this.sceGeListEnQueue = createNativeFunction(0xAB49E76A, 150, 'uint', 'uint/uint/int/void*', this, function (start, stall, callbackId, argsPtr) {
            return _this.context.gpu.listEnqueue(start, stall, callbackId, argsPtr);
        });
        this.sceGeListSync = createNativeFunction(0x03444EB4, 150, 'uint', 'int/int', this, function (displayListId, syncType) {
            return _this.context.gpu.listSync(displayListId, syncType);
        });
        this.sceGeListUpdateStallAddr = createNativeFunction(0xE0D68148, 150, 'uint', 'int/int', this, function (displayListId, stall) {
            return _this.context.gpu.updateStallAddr(displayListId, stall);
        });
        this.sceGeDrawSync = createNativeFunction(0xB287BD61, 150, 'uint', 'int', this, function (syncType) {
            var result = _this.context.gpu.drawSync(syncType);
            if (result instanceof Promise2) {
                return new WaitingThreadInfo('sceGeDrawSync', _this.context.gpu, result.then(function () {
                }), AcceptCallbacks.NO, Compensate.YES);
            }
            else {
                return result;
            }
        });
        this.sceGeContinue = createNativeFunction(0x4C06E472, 150, 'uint', '', this, function () {
            return -1;
        });
        this.sceGeBreak = createNativeFunction(0xB448EC0D, 150, 'uint', 'int/void*', this, function (mode, breakAddress) {
            return -1;
        });
        this.sceGeEdramGetAddr = createNativeFunction(0xE47E40E4, 150, 'uint', '', this, function () {
            return 0x04000000;
        });
        this.sceGeEdramGetSize = createNativeFunction(0x1F6752AD, 150, 'uint', '', this, function () {
            return 0x00200000;
        });
    }
    return sceGe_user;
})();
exports.sceGe_user = sceGe_user;
var CallbackData = (function () {
    function CallbackData() {
    }
    CallbackData.struct = StructClass.create(CallbackData, [
        { signalFunction: UInt32 },
        { signalArgument: UInt32 },
        { finishFunction: UInt32 },
        { finishArgument: UInt32 },
    ]);
    return CallbackData;
})();

},
"src/hle/module/sceHprm": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var sceHprm = (function () {
    function sceHprm(context) {
        this.context = context;
        this.sceHprmPeekCurrentKey = createNativeFunction(0x1910B327, 150, 'uint', 'void*', this, function (PspHprmKeysEnumKeyPtr) {
            PspHprmKeysEnumKeyPtr.writeInt32(0);
            return 0;
        });
    }
    return sceHprm;
})();
exports.sceHprm = sceHprm;

},
"src/hle/module/sceHttp": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var sceHttp = (function () {
    function sceHttp(context) {
        this.context = context;
    }
    return sceHttp;
})();
exports.sceHttp = sceHttp;

},
"src/hle/module/sceImpose": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var sceImpose = (function () {
    function sceImpose(context) {
        var _this = this;
        this.context = context;
        this.sceImposeGetBatteryIconStatus = createNativeFunction(0x8C943191, 150, 'uint', 'void*/void*', this, function (isChargingPointer, iconStatusPointer) {
            isChargingPointer.writeInt32(ChargingEnum.NotCharging);
            iconStatusPointer.writeInt32(BatteryStatusEnum.FullyFilled);
            return 0;
        });
        this.sceImposeSetLanguageMode = createNativeFunction(0x36AA6E91, 150, 'uint', 'uint/uint', this, function (language, buttonPreference) {
            _this.context.config.language = language;
            _this.context.config.buttonPreference = buttonPreference;
            return 0;
        });
        this.sceImposeGetLanguageMode = createNativeFunction(0x24FD7BCF, 150, 'uint', 'void*/void*', this, function (languagePtr, buttonPreferencePtr) {
            languagePtr.writeUInt32(_this.context.config.language);
            buttonPreferencePtr.writeUInt32(_this.context.config.buttonPreference);
            return 0;
        });
    }
    return sceImpose;
})();
exports.sceImpose = sceImpose;
var ChargingEnum;
(function (ChargingEnum) {
    ChargingEnum[ChargingEnum["NotCharging"] = 0] = "NotCharging";
    ChargingEnum[ChargingEnum["Charging"] = 1] = "Charging";
})(ChargingEnum || (ChargingEnum = {}));
var BatteryStatusEnum;
(function (BatteryStatusEnum) {
    BatteryStatusEnum[BatteryStatusEnum["VeryLow"] = 0] = "VeryLow";
    BatteryStatusEnum[BatteryStatusEnum["Low"] = 1] = "Low";
    BatteryStatusEnum[BatteryStatusEnum["PartiallyFilled"] = 2] = "PartiallyFilled";
    BatteryStatusEnum[BatteryStatusEnum["FullyFilled"] = 3] = "FullyFilled";
})(BatteryStatusEnum || (BatteryStatusEnum = {}));

},
"src/hle/module/sceLibFont": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var sceLibFont = (function () {
    function sceLibFont(context) {
        var _this = this;
        this.context = context;
        this.fontLibUid = new UidCollection(1);
        this.fontUid = new UidCollection(1);
        this.sceFontNewLib = createNativeFunction(0x67F17ED7, 150, 'uint', 'void*/void*', this, function (paramsPtr, errorCodePtr) {
            var fontLib = new FontLib();
            return _this.fontLibUid.allocate(fontLib);
        });
        this.sceFontFindOptimumFont = createNativeFunction(0x099EF33C, 150, 'uint', 'int/void*/void*', this, function (fontLibId, fontStylePointer, errorCodePointer) {
            var fontLib = _this.fontLibUid.get(fontLibId);
            return 0;
        });
        this.sceFontOpen = createNativeFunction(0xA834319D, 150, 'uint', 'int/int/int/void*', this, function (fontLibId, index, mode, errorCodePointer) {
            var fontLib = _this.fontLibUid.get(fontLibId);
            return _this.fontUid.allocate(new Font());
        });
        this.sceFontGetFontInfo = createNativeFunction(0x0DA7535E, 150, 'uint', 'int/void*', this, function (fontId, fontInfoPointer) {
            var font = _this.fontUid.get(fontId);
            return 0;
        });
        this.sceFontSetResolution = createNativeFunction(0x48293280, 150, 'uint', 'int/float/float', this, function (fontLibId, horizontalResolution, verticalResolution) {
            return 0;
        });
    }
    return sceLibFont;
})();
exports.sceLibFont = sceLibFont;
var FontLib = (function () {
    function FontLib() {
    }
    return FontLib;
})();
var Font = (function () {
    function Font() {
    }
    return Font;
})();

},
"src/hle/module/sceMp3": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var sceMp3 = (function () {
    function sceMp3(context) {
        this.context = context;
    }
    return sceMp3;
})();
exports.sceMp3 = sceMp3;

},
"src/hle/module/sceMpeg": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var SceKernelErrors = require('../SceKernelErrors');
var sceMpeg = (function () {
    function sceMpeg(context) {
        var _this = this;
        this.context = context;
        this.sceMpegInit = createNativeFunction(0x682A619B, 150, 'uint', '', this, function () {
            return -1;
        });
        this.sceMpegRingbufferQueryMemSize = createNativeFunction(0xD7A29F46, 150, 'uint', 'int', this, function (numberOfPackets) {
            return (sceMpeg.RING_BUFFER_PACKET_SIZE + 0x68) * numberOfPackets;
        });
        this.sceMpegQueryMemSize = createNativeFunction(0xC132E22F, 150, 'uint', 'int', this, function (mode) {
            return sceMpeg.MPEG_MEMSIZE;
        });
        this.sceMpegRingbufferConstruct = createNativeFunction(0x37295ED8, 150, 'uint', 'void*/int/int/int/int/int', this, function (ringbufferAddr, numPackets, data, size, callbackAddr, callbackArg) {
            if (ringbufferAddr == Stream.INVALID)
                return SceKernelErrors.ERROR_KERNEL_ILLEGAL_ADDR;
            if (size < 0)
                return SceKernelErrors.ERROR_MPEG_NO_MEMORY;
            if (_this.__mpegRingbufferQueryMemSize(numPackets) > size) {
                if (numPackets < 0x00100000) {
                    return SceKernelErrors.ERROR_MPEG_NO_MEMORY;
                }
                else {
                }
            }
            var buf = new RingBuffer();
            buf.packets = numPackets;
            buf.packetsRead = 0;
            buf.packetsWritten = 0;
            buf.packetsFree = 0;
            buf.packetSize = 2048;
            buf.data = data;
            buf.callback_addr = callbackAddr;
            buf.callback_args = callbackArg;
            buf.dataUpperBound = data + numPackets * 2048;
            buf.semaID = 0;
            buf.mpeg = 0;
            RingBuffer.struct.write(ringbufferAddr, buf);
        });
        this.sceMpegCreate = createNativeFunction(0xd8c5f121, 150, 'uint', 'uint/uint/uint/void*/uint/uint', this, function (mpegAddr, dataPtr, size, ringbufferAddr, mode, ddrTop) {
            if (!_this.context.memory.isValidAddress(mpegAddr))
                return -1;
            if (size < sceMpeg.MPEG_MEMSIZE)
                return SceKernelErrors.ERROR_MPEG_NO_MEMORY;
            if (ringbufferAddr == Stream.INVALID) {
                var ringBuffer = RingBuffer.struct.read(ringbufferAddr.clone());
                if (ringBuffer.packetSize == 0) {
                    ringBuffer.packetsFree = 0;
                }
                else {
                    ringBuffer.packetsFree = (ringBuffer.dataUpperBound - ringBuffer.data) / ringBuffer.packetSize;
                }
                ringBuffer.mpeg = mpegAddr;
            }
            var mpeg = _this.context.memory.getPointerStream(mpegAddr);
            mpeg.writeInt32(dataPtr + 0x30);
            var mpegHandle = _this.context.memory.getPointerStream(dataPtr + 0x30);
            mpegHandle.writeString("LIBMPEG\0" + "001\0");
            mpegHandle.writeInt32(-1);
        });
        this.sceMpegDelete = createNativeFunction(0x606A4649, 150, 'uint', 'int', this, function (sceMpegPointer) {
            //this.getMpeg(sceMpegPointer).delete();
            return 0;
        });
        this.sceMpegFinish = createNativeFunction(0x874624D6, 150, 'uint', '', this, function () {
            return 0;
        });
        this.sceMpegRingbufferDestruct = createNativeFunction(0x13407F13, 150, 'uint', 'int', this, function (ringBufferPointer) {
            return 0;
        });
    }
    sceMpeg.prototype.__mpegRingbufferQueryMemSize = function (packets) {
        return packets * (104 + 2048);
    };
    sceMpeg.RING_BUFFER_PACKET_SIZE = 0x800;
    sceMpeg.MPEG_MEMSIZE = 64 * 1024;
    return sceMpeg;
})();
exports.sceMpeg = sceMpeg;
var RingBuffer = (function () {
    function RingBuffer() {
    }
    RingBuffer.struct = StructClass.create(RingBuffer, [
        { packets: Int32 },
        { packetsRead: Int32 },
        { packetsWritten: Int32 },
        { packetsFree: Int32 },
        { packetSize: Int32 },
        { data: UInt32 },
        { callback_addr: UInt32 },
        { callback_args: Int32 },
        { dataUpperBound: Int32 },
        { semaID: Int32 },
        { mpeg: UInt32 },
        { gp: UInt32 },
    ]);
    return RingBuffer;
})();

},
"src/hle/module/sceNet": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var sceNet = (function () {
    function sceNet(context) {
        var _this = this;
        this.context = context;
        this.sceNetInit = createNativeFunction(0x39AF39A6, 150, 'int', 'int/int/int/int/int', this, function (memoryPoolSize, calloutprio, calloutstack, netintrprio, netintrstack) {
            _this.context.container['mac'] = new Uint8Array(xrange(0, 6).map(function (index) { return Math.random() * 255; }));
            return 0;
        });
        this.sceNetTerm = createNativeFunction(0x281928A9, 150, 'int', '', this, function () {
            return 0;
        });
        this.sceNetFreeThreadinfo = createNativeFunction(0x50647530, 150, 'int', 'int', this, function (threadId) {
            throw (new Error("Not implemented"));
            return -1;
        });
        this.sceNetThreadAbort = createNativeFunction(0xAD6844c6, 150, 'int', 'int', this, function (threadId) {
            throw (new Error("Not implemented"));
            return -1;
        });
        this.sceNetEtherStrton = createNativeFunction(0xD27961C9, 150, 'int', 'string/byte[6]', this, function (string, mac) {
            mac.set(string2mac(string));
            return 0;
        });
        this.sceNetEtherNtostr = createNativeFunction(0x89360950, 150, 'int', 'byte[6]/void*', this, function (mac, outputAddress) {
            outputAddress.writeStringz(mac2string(mac));
            return 0;
        });
        this.sceNetGetLocalEtherAddr = createNativeFunction(0x0BF0A3AE, 150, 'int', 'byte[6]', this, function (macOut) {
            console.info("sceNetGetLocalEtherAddr: ", mac2string(_this.context.netManager.mac));
            macOut.set(_this.context.netManager.mac);
            return 0;
        });
        this.sceNetGetMallocStat = createNativeFunction(0xCC393E48, 150, 'int', 'void*', this, function (statPtr) {
            throw (new Error("Not implemented"));
            return -1;
        });
    }
    return sceNet;
})();
exports.sceNet = sceNet;

},
"src/hle/module/sceNetAdhoc": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var sceNetAdhoc = (function () {
    function sceNetAdhoc(context) {
        var _this = this;
        this.context = context;
        this.sceNetAdhocInit = createNativeFunction(0xE1D621D7, 150, 'int', '', this, function () {
            _this.partition = _this.context.memoryManager.kernelPartition.allocateLow(0x4000);
            return 0;
        });
        this.sceNetAdhocTerm = createNativeFunction(0xA62C6F57, 150, 'int', '', this, function () {
            _this.partition.deallocate();
            return 0;
        });
        this.sceNetAdhocPollSocket = createNativeFunction(0x7A662D6B, 150, 'int', 'int/int/int/int', this, function (socketAddress, int, timeout, nonblock) {
            throw (new Error("Not implemented sceNetAdhocPollSocket"));
            return -1;
        });
        this.pdps = new UidCollection(1);
        this.sceNetAdhocPdpCreate = createNativeFunction(0x6F92741B, 150, 'int', 'byte[6]/int/uint/int', this, function (mac, port, bufsize, unk1) {
            var pdp = new Pdp(_this.context, mac, port, bufsize);
            pdp.id = _this.pdps.allocate(pdp);
            return pdp.id;
        });
        this.sceNetAdhocPdpDelete = createNativeFunction(0x7F27BB5E, 150, 'int', 'int/int', this, function (pdpId, unk1) {
            var pdp = _this.pdps.get(pdpId);
            pdp.dispose();
            _this.pdps.remove(pdpId);
            return 0;
        });
        this.sceNetAdhocPdpSend = createNativeFunction(0xABED3790, 150, 'int', 'int/byte[6]/int/byte[]/int/int', this, function (pdpId, destMac, port, dataStream, timeout, nonblock) {
            var pdp = _this.pdps.get(pdpId);
            var data = dataStream.readBytes(dataStream.length);
            pdp.send(port, destMac, data);
            return 0;
        });
        this.sceNetAdhocPdpRecv = createNativeFunction(0xDFE53E03, 150, 'int', 'int/byte[6]/void*/void*/void*/void*/int', this, function (pdpId, srcMac, portPtr, data, dataLengthPtr, timeout, nonblock) {
            var block = !nonblock;
            var pdp = _this.pdps.get(pdpId);
            var recvOne = function (chunk) {
                srcMac.set(chunk.mac);
                data.writeBytes(chunk.payload);
                portPtr.writeInt16(pdp.port);
                dataLengthPtr.writeInt32(chunk.payload.length);
                return 0;
            };
            if (block) {
                return pdp.recvOneAsync().then(recvOne);
            }
            else {
                if (pdp.chunks.length <= 0)
                    return 0x80410709;
                return recvOne(pdp.chunks.shift());
            }
        });
        this.sceNetAdhocGetPdpStat = createNativeFunction(0xC7C1FC57, 150, 'int', 'void*/void*', this, function (sizeStream, pdpStatStruct) {
            var maxSize = sizeStream.sliceWithLength(0).readInt32();
            var pdps = _this.pdps.list();
            var totalSize = pdps.length * PdpStatStruct.struct.length;
            sizeStream.sliceWithLength(0).writeInt32(totalSize);
            var pos = 0;
            pdps.forEach(function (pdp) {
                var stat = new PdpStatStruct();
                stat.nextPointer = 0;
                stat.pdpId = pdp.id;
                stat.port = pdp.port;
                stat.mac = xrange(0, 6).map(function (index) { return pdp.mac[index]; });
                stat.rcvdData = pdp.getDataLength();
                PdpStatStruct.struct.write(pdpStatStruct, stat);
            });
            return 0;
        });
        this.sceNetAdhocGameModeCreateMaster = createNativeFunction(0x7F75C338, 150, 'int', 'byte[]', this, function (data) {
            throw (new Error("Not implemented sceNetAdhocGameModeCreateMaster"));
            return -1;
        });
        this.sceNetAdhocGameModeCreateReplica = createNativeFunction(0x3278AB0C, 150, 'int', 'byte[6]/byte[]', this, function (mac, data) {
            throw (new Error("Not implemented sceNetAdhocGameModeCreateReplica"));
            return -1;
        });
        this.sceNetAdhocGameModeUpdateMaster = createNativeFunction(0x98C204C8, 150, 'int', '', this, function () {
            throw (new Error("Not implemented sceNetAdhocGameModeUpdateMaster"));
            return -1;
        });
        this.sceNetAdhocGameModeUpdateReplica = createNativeFunction(0xFA324B4E, 150, 'int', 'int/int', this, function (id, unk1) {
            throw (new Error("Not implemented sceNetAdhocGameModeUpdateReplica"));
            return -1;
        });
        this.sceNetAdhocGameModeDeleteMaster = createNativeFunction(0xA0229362, 150, 'int', '', this, function () {
            throw (new Error("Not implemented sceNetAdhocGameModeDeleteMaster"));
            return -1;
        });
        this.sceNetAdhocGameModeDeleteReplica = createNativeFunction(0x0B2228E9, 150, 'int', 'int', this, function (id) {
            throw (new Error("Not implemented sceNetAdhocGameModeDeleteReplica"));
            return -1;
        });
        this.sceNetAdhocPtpOpen = createNativeFunction(0x877F6D66, 150, 'int', 'byte[6]/int/void*/int/int/int/int/int', this, function (srcmac, srcport, destmac, destport, bufsize, delay, count, unk1) {
            throw (new Error("Not implemented sceNetAdhocPtpOpen"));
            return -1;
        });
        this.sceNetAdhocPtpListen = createNativeFunction(0xE08BDAC1, 150, 'int', 'byte[6]/int/int/int/int/int/int', this, function (srcmac, srcport, bufsize, delay, count, queue, unk1) {
            throw (new Error("Not implemented sceNetAdhocPtpListen"));
            return -1;
        });
        this.sceNetAdhocPtpConnect = createNativeFunction(0xFC6FC07B, 150, 'int', 'int/int/int', this, function (id, timeout, nonblock) {
            throw (new Error("Not implemented sceNetAdhocPtpConnect"));
            return -1;
        });
        this.sceNetAdhocPtpAccept = createNativeFunction(0x9DF81198, 150, 'int', 'int/void*/void*/int/int', this, function (id, data, datasize, timeout, nonblock) {
            throw (new Error("Not implemented sceNetAdhocPtpAccept"));
            return -1;
        });
        this.sceNetAdhocPtpSend = createNativeFunction(0x4DA4C788, 150, 'int', 'int/void*/void*/int/int', this, function (id, data, datasize, timeout, nonblock) {
            throw (new Error("Not implemented sceNetAdhocPtpSend"));
            return -1;
        });
        this.sceNetAdhocPtpRecv = createNativeFunction(0x8BEA2B3E, 150, 'int', 'int/void*/void*/int/int', this, function (id, data, datasize, timeout, nonblock) {
            throw (new Error("Not implemented sceNetAdhocPtpRecv"));
            return -1;
        });
        this.sceNetAdhocPtpFlush = createNativeFunction(0x9AC2EEAC, 150, 'int', 'int/int/int', this, function (id, timeout, nonblock) {
            throw (new Error("Not implemented sceNetAdhocPtpFlush"));
            return -1;
        });
        this.sceNetAdhocPtpClose = createNativeFunction(0x157E6225, 150, 'int', 'int/int', this, function (id, unk1) {
            throw (new Error("Not implemented sceNetAdhocPtpClose"));
            return -1;
        });
        this.sceNetAdhocGetPtpStat = createNativeFunction(0xB9685118, 150, 'int', 'void*/void*', this, function (size, stat) {
            throw (new Error("Not implemented sceNetAdhocGetPtpStat"));
            return -1;
        });
    }
    return sceNetAdhoc;
})();
exports.sceNetAdhoc = sceNetAdhoc;
var PdpRecv = (function () {
    function PdpRecv() {
        this.port = 0;
        this.mac = new Uint8Array(6);
        this.data = new Uint8Array(0);
    }
    return PdpRecv;
})();
var Pdp = (function () {
    function Pdp(context, mac, port, bufsize) {
        var _this = this;
        this.context = context;
        this.mac = mac;
        this.port = port;
        this.bufsize = bufsize;
        this.chunks = [];
        this.onChunkRecv = new Signal();
        this.onMessageCancel = this.context.netManager.onmessage(port).add(function (packet) {
            _this.chunks.push(packet);
            _this.onChunkRecv.dispatch();
        });
    }
    Pdp.prototype.recvOneAsync = function () {
        var _this = this;
        return new Promise2(function (resolve, reject) {
            _this.onChunkRecv.once(function () {
                resolve(_this.chunks.shift());
            });
        });
    };
    Pdp.prototype.send = function (port, destMac, data) {
        this.context.netManager.send(port, 'sceNetAdhocPdpSend', destMac, data);
    };
    Pdp.prototype.getDataLength = function () {
        return this.chunks.sum(function (chunk) { return chunk.payload.length; });
    };
    Pdp.prototype.dispose = function () {
        if (this.onMessageCancel) {
            this.onMessageCancel.cancel();
            this.onMessageCancel = null;
        }
    };
    return Pdp;
})();
exports.Pdp = Pdp;
var PdpStatStruct = (function () {
    function PdpStatStruct() {
        this.nextPointer = 0;
        this.pdpId = 0;
        this.mac = [0, 0, 0, 0, 0, 0];
        this.port = 0;
        this.rcvdData = 0;
    }
    PdpStatStruct.struct = StructClass.create(PdpStatStruct, [
        { nextPointer: UInt32 },
        { pdpId: Int32 },
        { mac: StructArray(Int8, 6) },
        { port: Int16 },
        { rcvdData: UInt32 },
    ]);
    return PdpStatStruct;
})();

},
"src/hle/module/sceNetAdhocMatching": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var _manager = require('../manager');
_manager.Thread;
var createNativeFunction = _utils.createNativeFunction;
var sceNetAdhocMatching = (function () {
    function sceNetAdhocMatching(context) {
        var _this = this;
        this.context = context;
        this.poolStat = { size: 0, maxsize: 0, freesize: 0 };
        this.sceNetAdhocMatchingInit = createNativeFunction(0x2A2A1E07, 150, 'int', 'int', this, function (memSize) {
            _this.poolStat.size = memSize;
            _this.poolStat.maxsize = memSize;
            _this.poolStat.freesize = memSize;
            return 0;
        });
        this.sceNetAdhocMatchingTerm = createNativeFunction(0x7945ECDA, 150, 'int', '', this, function () {
            return 0;
        });
        this.matchings = new UidCollection(1);
        this.sceNetAdhocMatchingCreate = createNativeFunction(0xCA5EDA6F, 150, 'int', 'Thread/int/int/int/int/int/int/int/int/uint', this, function (thread, mode, maxPeers, port, bufSize, helloDelay, pingDelay, initCount, msgDelay, callback) {
            var matching = new Matching(_this.context, thread, mode, maxPeers, port, bufSize, helloDelay, pingDelay, initCount, msgDelay, callback);
            matching.id = _this.matchings.allocate(matching);
            return matching.id;
        });
        this.sceNetAdhocMatchingSelectTarget = createNativeFunction(0x5E3D4B79, 150, 'int', 'int/void*/int/void*', this, function (matchingId, macStream, dataLength, dataPointer) {
            var matching = _this.matchings.get(matchingId);
            var mac = macStream.readBytes(6);
            matching.selectTarget(mac, (dataPointer && dataLength) ? dataPointer.readBytes(dataLength) : null);
            return 0;
        });
        this.sceNetAdhocMatchingCancelTarget = createNativeFunction(0xEA3C6108, 150, 'int', 'int/void*', this, function (matchingId, mac) {
            var matching = _this.matchings.get(matchingId);
            matching.cancelTarget(mac.readBytes(6));
            return 0;
        });
        this.sceNetAdhocMatchingDelete = createNativeFunction(0xF16EAF4F, 150, 'int', 'int', this, function (matchingId) {
            _this.matchings.remove(matchingId);
            return 0;
        });
        this.sceNetAdhocMatchingStart = createNativeFunction(0x93EF3843, 150, 'int', 'int/int/int/int/int/int/void*', this, function (matchingId, evthPri, evthStack, inthPri, inthStack, optLen, optData) {
            var matching = _this.matchings.get(matchingId);
            matching.hello = optData.readBytes(optLen);
            matching.start();
            return 0;
        });
        this.sceNetAdhocMatchingStop = createNativeFunction(0x32B156B3, 150, 'int', 'int', this, function (matchingId) {
            var matching = _this.matchings.get(matchingId);
            matching.stop();
            return 0;
        });
    }
    return sceNetAdhocMatching;
})();
exports.sceNetAdhocMatching = sceNetAdhocMatching;
(function (State) {
    State[State["START"] = 0] = "START";
    State[State["JOIN_WAIT_RESPONSE"] = 1] = "JOIN_WAIT_RESPONSE";
    State[State["JOIN_WAIT_COMPLETE"] = 2] = "JOIN_WAIT_COMPLETE";
    State[State["COMPLETED"] = 3] = "COMPLETED";
})(exports.State || (exports.State = {}));
var State = exports.State;
var Matching = (function () {
    function Matching(context, thread, mode, maxPeers, port, bufSize, helloDelay, pingDelay, initCount, msgDelay, callback) {
        this.context = context;
        this.thread = thread;
        this.mode = mode;
        this.maxPeers = maxPeers;
        this.port = port;
        this.bufSize = bufSize;
        this.helloDelay = helloDelay;
        this.pingDelay = pingDelay;
        this.initCount = initCount;
        this.msgDelay = msgDelay;
        this.callback = callback;
        this.id = 0;
        this.joinMac = '00:00:00:00:00:00';
        this.mac = new Uint8Array([1, 2, 3, 4, 5, 6]);
        this.hello = new Uint8Array(0);
        this.helloTimer = -1;
        this.dataTimer = -1;
        this.onMessageCancelable = null;
        this.state = State.START;
    }
    Matching.prototype.sendHello = function () {
        if (this.state != State.START)
            return;
        this.sendMessage(Event.Hello, Matching.MAC_ALL, this.hello);
    };
    Matching.prototype.start = function () {
        var _this = this;
        this.onMessageCancelable = this.context.netManager.onmessage(this.port).add(function (packet) {
            _this.notify(Event[packet.type], packet.mac, packet.payload);
        });
        this.helloTimer = setInterval(function () { _this.sendHello(); }, this.helloDelay / 1000);
        this.sendHello();
        this.dataTimer = setInterval(function () {
        }, this.msgDelay / 1000);
    };
    Matching.prototype.stop = function () {
        clearInterval(this.helloTimer);
        clearInterval(this.dataTimer);
        if (this.onMessageCancelable) {
            this.onMessageCancelable.cancel();
            this.onMessageCancelable = null;
        }
    };
    Matching.prototype.selectTarget = function (mac, data) {
        var macstr = mac2string(mac);
        console.info("net.adhoc: selectTarget", macstr);
        if ((this.state == State.JOIN_WAIT_RESPONSE) && (macstr == this.joinMac)) {
            this.state = State.JOIN_WAIT_COMPLETE;
            this.sendMessage(Event.Accept, mac, data);
        }
        else {
            this.state = State.JOIN_WAIT_RESPONSE;
            this.sendMessage(Event.Join, mac, data);
        }
    };
    Matching.prototype.cancelTarget = function (mac) {
        var macstr = mac2string(mac);
        console.info("net.adhoc: cancelTarget", macstr);
        this.state = State.START;
        this.sendMessage(Event.Cancel, mac, null);
    };
    Matching.prototype.sendMessage = function (event, tomac, data) {
        if (!data)
            data = new Uint8Array(0);
        if (event != Event.Hello) {
            console.info("net.adhoc: send ->", Event[event], event, ':', mac2string(tomac), ':', Stream.fromUint8Array(data).readString(data.length));
        }
        this.context.netManager.send(this.port, Event[event], tomac, data);
    };
    Matching.prototype.notify = function (event, frommac, data) {
        if (!data)
            data = new Uint8Array(0);
        if (event != Event.Hello) {
            console.info("net.adhoc: received <-", Event[event], event, ':', mac2string(frommac), ':', Stream.fromUint8Array(data).readString(data.length));
        }
        switch (event) {
            case Event.Join:
                this.state = State.JOIN_WAIT_RESPONSE;
                this.joinMac = mac2string(frommac);
                break;
        }
        var macPartition = this.context.memoryManager.kernelPartition.allocateLow(8, 'Matching.mac');
        this.context.memory.memset(macPartition.low, 0, macPartition.size);
        this.context.memory.writeUint8Array(macPartition.low, frommac);
        var dataPartition = this.context.memoryManager.kernelPartition.allocateLow(Math.max(8, MathUtils.nextAligned(data.length, 8)), 'Matching.data');
        this.context.memory.memset(dataPartition.low, 0, dataPartition.size);
        this.context.memory.writeUint8Array(dataPartition.low, data);
        this.context.callbackManager.executeLater(this.callback, [
            this.id, event, macPartition.low, data.length, data.length ? dataPartition.low : 0
        ]);
        dataPartition.deallocate();
        macPartition.deallocate();
        switch (event) {
            case Event.Accept:
                this.sendMessage(Event.Complete, frommac, data);
                this.state = State.JOIN_WAIT_COMPLETE;
                break;
            case Event.Complete:
                if (this.state == State.JOIN_WAIT_COMPLETE) {
                    this.sendMessage(Event.Complete, frommac, data);
                    this.state = State.COMPLETED;
                }
                break;
            case Event.Data:
                this.sendMessage(Event.DataConfirm, frommac, null);
                break;
            case Event.Disconnect:
            case Event.Left:
                this.state = State.START;
                break;
        }
    };
    Matching.MAC_ALL = new Uint8Array([0, 0, 0, 0, 0, 0]);
    return Matching;
})();
exports.Matching = Matching;
(function (Event) {
    Event[Event["Hello"] = 1] = "Hello";
    Event[Event["Join"] = 2] = "Join";
    Event[Event["Left"] = 3] = "Left";
    Event[Event["Reject"] = 4] = "Reject";
    Event[Event["Cancel"] = 5] = "Cancel";
    Event[Event["Accept"] = 6] = "Accept";
    Event[Event["Complete"] = 7] = "Complete";
    Event[Event["Timeout"] = 8] = "Timeout";
    Event[Event["Error"] = 9] = "Error";
    Event[Event["Disconnect"] = 10] = "Disconnect";
    Event[Event["Data"] = 11] = "Data";
    Event[Event["DataConfirm"] = 12] = "DataConfirm";
    Event[Event["DataTimeout"] = 13] = "DataTimeout";
})(exports.Event || (exports.Event = {}));
var Event = exports.Event;
(function (Mode) {
    Mode[Mode["Host"] = 1] = "Host";
    Mode[Mode["Client"] = 2] = "Client";
    Mode[Mode["Ptp"] = 3] = "Ptp";
})(exports.Mode || (exports.Mode = {}));
var Mode = exports.Mode;

},
"src/hle/module/sceNetAdhocctl": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var sceNetAdhocctl = (function () {
    function sceNetAdhocctl(context) {
        var _this = this;
        this.context = context;
        this.currentState = State.Disconnected;
        this.currentName = "noname";
        this.sceNetAdhocctlInit = createNativeFunction(0xE26F226E, 150, 'int', 'int/int/void*', this, function (stacksize, priority, product) {
            _this.currentState = State.Disconnected;
            return 0;
        });
        this.sceNetAdhocctlTerm = createNativeFunction(0x9D689E13, 150, 'int', '', this, function () {
            return 0;
        });
        this.connectHandlers = [];
        this.sceNetAdhocctlConnect = createNativeFunction(0x0AD043ED, 150, 'int', 'string', this, function (name) {
            _this.currentName = name;
            _this.connectHandlers.push(_this.context.netManager.onopen.add(function () {
                _this.currentState = State.Connected;
                _this._notifyAdhocctlHandler(Event.Connected);
            }));
            _this.connectHandlers.push(_this.context.netManager.onclose.add(function () {
                _this.currentState = State.Disconnected;
                _this._notifyAdhocctlHandler(Event.Disconnected);
            }));
            if (_this.context.netManager.connected) {
                _this.currentState = State.Connected;
                _this._notifyAdhocctlHandler(Event.Connected);
            }
            _this.context.netManager.connectOnce();
            return 0;
        });
        this.sceNetAdhocctlDisconnect = createNativeFunction(0x34401D65, 150, 'int', '', this, function () {
            while (_this.connectHandlers.length)
                _this.connectHandlers.shift().cancel();
            return 0;
        });
        this.handlers = new UidCollection(1);
        this.sceNetAdhocctlAddHandler = createNativeFunction(0x20B317A0, 150, 'int', 'int/int', this, function (callback, parameter) {
            return _this.handlers.allocate(new HandlerCallback(callback, parameter));
        });
        this.sceNetAdhocctlDelHandler = createNativeFunction(0x6402490B, 150, 'int', 'int', this, function (handler) {
            _this.handlers.remove(handler);
            return 0;
        });
        this.sceNetAdhocctlGetState = createNativeFunction(0x75ECD386, 150, 'int', 'void*', this, function (stateOut) {
            stateOut.writeInt32(_this.currentState);
            return 0;
        });
    }
    sceNetAdhocctl.prototype._notifyAdhocctlHandler = function (event, error) {
        var _this = this;
        if (error === void 0) { error = 0; }
        this.handlers.list().forEach(function (callback) {
            _this.context.callbackManager.executeLater(callback.callback, [event, error, callback.argument]);
        });
    };
    return sceNetAdhocctl;
})();
exports.sceNetAdhocctl = sceNetAdhocctl;
var HandlerCallback = (function () {
    function HandlerCallback(callback, argument) {
        this.callback = callback;
        this.argument = argument;
    }
    return HandlerCallback;
})();
var State;
(function (State) {
    State[State["Disconnected"] = 0] = "Disconnected";
    State[State["Connected"] = 1] = "Connected";
    State[State["Scan"] = 2] = "Scan";
    State[State["Game"] = 3] = "Game";
    State[State["Discover"] = 4] = "Discover";
    State[State["Wol"] = 5] = "Wol";
})(State || (State = {}));
var Mode;
(function (Mode) {
    Mode[Mode["Normal"] = 0] = "Normal";
    Mode[Mode["GameMode"] = 1] = "GameMode";
    Mode[Mode["None"] = -1] = "None";
})(Mode || (Mode = {}));
var Event;
(function (Event) {
    Event[Event["Error"] = 0] = "Error";
    Event[Event["Connected"] = 1] = "Connected";
    Event[Event["Disconnected"] = 2] = "Disconnected";
    Event[Event["Scan"] = 3] = "Scan";
    Event[Event["Game"] = 4] = "Game";
    Event[Event["Discover"] = 5] = "Discover";
    Event[Event["Wol"] = 6] = "Wol";
    Event[Event["WolInterrupted"] = 7] = "WolInterrupted";
})(Event || (Event = {}));
var NICK_NAME_LENGTH = 128;
var GROUP_NAME_LENGTH = 8;
var IBSS_NAME_LENGTH = 6;
var ADHOC_ID_LENGTH = 9;
var MAX_GAME_MODE_MACS = 16;

},
"src/hle/module/sceNetApctl": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var sceNetApctl = (function () {
    function sceNetApctl(context) {
        this.context = context;
    }
    return sceNetApctl;
})();
exports.sceNetApctl = sceNetApctl;

},
"src/hle/module/sceNetInet": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var sceNetInet = (function () {
    function sceNetInet(context) {
        this.context = context;
    }
    return sceNetInet;
})();
exports.sceNetInet = sceNetInet;

},
"src/hle/module/sceNetResolver": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var sceNetResolver = (function () {
    function sceNetResolver(context) {
        this.context = context;
    }
    return sceNetResolver;
})();
exports.sceNetResolver = sceNetResolver;

},
"src/hle/module/sceNp": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var sceNp = (function () {
    function sceNp(context) {
        this.context = context;
    }
    return sceNp;
})();
exports.sceNp = sceNp;

},
"src/hle/module/sceNpAuth": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var sceNpAuth = (function () {
    function sceNpAuth(context) {
        this.context = context;
    }
    return sceNpAuth;
})();
exports.sceNpAuth = sceNpAuth;

},
"src/hle/module/sceNpService": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var sceNpService = (function () {
    function sceNpService(context) {
        this.context = context;
    }
    return sceNpService;
})();
exports.sceNpService = sceNpService;

},
"src/hle/module/sceOpenPSID": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var sceOpenPSID = (function () {
    function sceOpenPSID(context) {
        this.context = context;
    }
    return sceOpenPSID;
})();
exports.sceOpenPSID = sceOpenPSID;

},
"src/hle/module/sceParseHttp": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var sceParseHttp = (function () {
    function sceParseHttp(context) {
        this.context = context;
    }
    return sceParseHttp;
})();
exports.sceParseHttp = sceParseHttp;

},
"src/hle/module/sceParseUri": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var sceParseUri = (function () {
    function sceParseUri(context) {
        this.context = context;
    }
    return sceParseUri;
})();
exports.sceParseUri = sceParseUri;

},
"src/hle/module/scePower": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var SceKernelErrors = require('../SceKernelErrors');
var scePower = (function () {
    function scePower(context) {
        var _this = this;
        this.context = context;
        this.cpuMult = 511;
        this.pllFreq = 222;
        this.busFreq = 111;
        this.scePowerRegisterCallback = createNativeFunction(0x04B7766E, 150, 'int', 'int/int', this, function (slotIndex, callbackId) {
            _this.context.callbackManager.notify(callbackId, CallbackStatus.BATTERY_EXIST);
            return 0;
        });
        this.scePowerUnregitserCallback = createNativeFunction(0xDB9D28DD, 150, 'int', 'int', this, function (slotIndex) {
            return 0;
        });
        this.scePowerUnregisterCallback = createNativeFunction(0xDFA8BAF8, 150, 'int', 'int', this, function (slotIndex) {
            return 0;
        });
        this.scePowerSetClockFrequency = createNativeFunction(0x737486F2, 150, 'int', 'int/int/int', this, function (pllFreq, cpuFreq, busFreq) {
            return _this._scePowerSetClockFrequency(pllFreq, cpuFreq, busFreq);
        });
        this.scePowerSetClockFrequency2 = createNativeFunction(0xEBD177D6, 150, 'int', 'int/int/int', this, function (pllFreq, cpuFreq, busFreq) {
            return _this._scePowerSetClockFrequency(pllFreq, cpuFreq, busFreq);
        });
        this.scePowerSetClockFrequency3 = createNativeFunction(0x469989AD, 150, 'int', 'int/int/int', this, function (pllFreq, cpuFreq, busFreq) {
            return _this._scePowerSetClockFrequency(pllFreq, cpuFreq, busFreq);
        });
        this.scePowerGetCpuClockFrequency = createNativeFunction(0xFEE03A2F, 150, 'int', '', this, function () { return _this._getCpuFreq(); });
        this.scePowerGetCpuClockFrequencyInt = createNativeFunction(0xFDB5BFE9, 150, 'int', '', this, function () { return _this._getCpuFreq(); });
        this.scePowerGetCpuClockFrequencyFloat = createNativeFunction(0xB1A52C83, 150, 'float', '', this, function () { return _this._getCpuFreq(); });
        this.scePowerGetBusClockFrequency = createNativeFunction(0x478FE6F5, 150, 'int', '', this, function () { return _this.busFreq; });
        this.scePowerGetBusClockFrequencyInt = createNativeFunction(0xBD681969, 150, 'int', '', this, function () { return _this.busFreq; });
        this.scePowerGetBusClockFrequencyFloat = createNativeFunction(0x9BADB3EB, 150, 'float', '', this, function () { return _this.busFreq; });
        this.scePowerGetPllClockFrequencyInt = createNativeFunction(0x34F9C463, 150, 'int', '', this, function () { return _this.pllFreq; });
        this.scePowerGetPllClockFrequencyFloat = createNativeFunction(0xEA382A27, 150, 'float', '', this, function () { return _this.pllFreq; });
        this.scePowerSetBusClockFrequency = createNativeFunction(0xB8D7B3FB, 150, 'int', 'int', this, function (busFreq) {
            if (!_this._isValidBusFreq(busFreq))
                return SceKernelErrors.ERROR_INVALID_VALUE;
            _this.busFreq = 111;
            return 0;
        });
        this.scePowerSetCpuClockFrequency = createNativeFunction(0x843FBF43, 150, 'int', 'int', this, function (cpuFreq) {
            if (!_this._isValidCpuFreq(cpuFreq))
                return SceKernelErrors.ERROR_INVALID_VALUE;
            _this._setCpuFreq(cpuFreq);
            return 0;
        });
        this.scePowerGetBatteryLifePercent = createNativeFunction(0x2085D15D, 150, 'int', '', this, function () { return 100; });
        this.scePowerIsPowerOnline = createNativeFunction(0x87440F5E, 150, 'int', '', this, function () { return 1; });
        this.scePowerIsBatteryExist = createNativeFunction(0x0AFD0D8B, 150, 'int', '', this, function () { return 1; });
        this.scePowerIsLowBattery = createNativeFunction(0xD3075926, 150, 'int', '', this, function () { return 0; });
        this.scePowerIsBatteryCharging = createNativeFunction(0x1E490401, 150, 'int', '', this, function () { return 1; });
        this.scePowerGetBatteryLifeTime = createNativeFunction(0x8EFB3FA2, 150, 'int', '', this, function () { return 3 * 60; });
        this.scePowerGetBatteryVolt = createNativeFunction(0x483CE86B, 150, 'int', '', this, function () { return 4135; });
        this.scePowerGetBatteryTemp = createNativeFunction(0x28E12023, 150, 'int', '', this, function () { return 28; });
        this.scePowerLock = createNativeFunction(0xD6D016EF, 150, 'int', 'int', this, function (unknown) { return 0; });
        this.scePowerUnlock = createNativeFunction(0xCA3D34C1, 150, 'int', 'int', this, function (unknown) { return 0; });
        this.scePowerTick = createNativeFunction(0xEFD3C963, 150, 'int', 'int', this, function (type) { return 0; });
        this.scePowerGetBatteryChargingStatus = createNativeFunction(0xB4432BC8, 150, 'int', '', this, function () {
            return PowerFlagsSet.BatteryExists | PowerFlagsSet.AcPower | PowerFlagsSet.BatteryPower;
        });
    }
    scePower.prototype._getCpuMult = function () {
        return 0.43444227005871 * (this.busFreq / 111);
    };
    scePower.prototype._getCpuFreq = function () {
        return this.cpuMult * this._getCpuMult();
    };
    scePower.prototype._setCpuFreq = function (cpuFreq) {
        if (cpuFreq > 222) {
        }
        else if (cpuFreq == 222) {
            this.cpuMult = 511;
        }
        else {
            this.cpuMult = Math.floor(cpuFreq / this._getCpuMult());
        }
    };
    scePower.prototype._isValidCpuFreq = function (freq) {
        return (freq >= 1 && freq <= 222);
    };
    scePower.prototype._isValidBusFreq = function (freq) {
        return (freq >= 1 && freq <= 111);
    };
    scePower.prototype._isValidPllFreq = function (freq) {
        return (freq >= 19 && freq <= 111);
    };
    scePower.prototype._scePowerSetClockFrequency = function (pllFreq, cpuFreq, busFreq) {
        if (!this._isValidCpuFreq(cpuFreq))
            return SceKernelErrors.ERROR_INVALID_VALUE;
        if (!this._isValidBusFreq(busFreq))
            return SceKernelErrors.ERROR_INVALID_VALUE;
        if (!this._isValidPllFreq(pllFreq))
            return SceKernelErrors.ERROR_INVALID_VALUE;
        this.pllFreq = pllFreq;
        this._setCpuFreq(cpuFreq);
        this.busFreq = busFreq;
        return 0;
    };
    return scePower;
})();
exports.scePower = scePower;
var CallbackStatus;
(function (CallbackStatus) {
    CallbackStatus[CallbackStatus["AC_POWER"] = 4096] = "AC_POWER";
    CallbackStatus[CallbackStatus["BATTERY_EXIST"] = 128] = "BATTERY_EXIST";
    CallbackStatus[CallbackStatus["BATTERY_FULL"] = 100] = "BATTERY_FULL";
})(CallbackStatus || (CallbackStatus = {}));
var PowerFlagsSet;
(function (PowerFlagsSet) {
    PowerFlagsSet[PowerFlagsSet["PowerSwitch"] = 2147483648] = "PowerSwitch";
    PowerFlagsSet[PowerFlagsSet["HoldSwitch"] = 1073741824] = "HoldSwitch";
    PowerFlagsSet[PowerFlagsSet["StandBy"] = 524288] = "StandBy";
    PowerFlagsSet[PowerFlagsSet["ResumeComplete"] = 262144] = "ResumeComplete";
    PowerFlagsSet[PowerFlagsSet["Resuming"] = 131072] = "Resuming";
    PowerFlagsSet[PowerFlagsSet["Suspending"] = 65536] = "Suspending";
    PowerFlagsSet[PowerFlagsSet["AcPower"] = 4096] = "AcPower";
    PowerFlagsSet[PowerFlagsSet["BatteryLow"] = 256] = "BatteryLow";
    PowerFlagsSet[PowerFlagsSet["BatteryExists"] = 128] = "BatteryExists";
    PowerFlagsSet[PowerFlagsSet["BatteryPower"] = 127] = "BatteryPower";
})(PowerFlagsSet || (PowerFlagsSet = {}));

},
"src/hle/module/scePspNpDrm_user": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var scePspNpDrm_user = (function () {
    function scePspNpDrm_user(context) {
        this.context = context;
    }
    return scePspNpDrm_user;
})();
exports.scePspNpDrm_user = scePspNpDrm_user;

},
"src/hle/module/sceReg": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var sceReg = (function () {
    function sceReg(context) {
        this.context = context;
        this.sceRegOpenRegistry = createNativeFunction(0x92E41280, 150, 'int', 'void*/int/void*', this, function (regParamPtr, mode, regHandlePtr) {
            var regParam = RegParam.struct.read(regParamPtr);
            console.warn('sceRegOpenRegistry: ' + regParam.name);
            regHandlePtr.writeInt32(0);
            return 0;
        });
        this.sceRegOpenCategory = createNativeFunction(0x1D8A762E, 150, 'int', 'int/string/int/void*', this, function (regHandle, name, mode, regCategoryHandlePtr) {
            console.warn('sceRegOpenCategory: ' + name);
            return 0;
        });
        this.sceRegGetKeyInfo = createNativeFunction(0xD4475AA8, 150, 'int', 'int/string/void*/void*/void*', this, function (categoryHandle, name, regKeyHandlePtr, regKeyTypesPtr, sizePtr) {
            console.warn('sceRegGetKeyInfo: ' + name);
            return 0;
        });
        this.sceRegGetKeyValue = createNativeFunction(0x28A8E98A, 150, 'int', 'int/int/void*/int', this, function (categoryHandle, regKeyHandle, bufferPtr, size) {
            console.warn('sceRegGetKeyValue');
            return 0;
        });
        this.sceRegFlushCategory = createNativeFunction(0x0D69BF40, 150, 'int', 'int', this, function (categoryHandle) {
            console.warn('sceRegFlushCategory');
            return 0;
        });
        this.sceRegCloseCategory = createNativeFunction(0x0CAE832B, 150, 'int', 'int', this, function (categoryHandle) {
            console.warn('sceRegCloseCategory');
            return 0;
        });
        this.sceRegFlushRegistry = createNativeFunction(0x39461B4D, 150, 'int', 'int', this, function (regHandle) {
            console.warn('sceRegFlushRegistry');
            return 0;
        });
        this.sceRegCloseRegistry = createNativeFunction(0xFA8A5739, 150, 'int', 'int', this, function (regHandle) {
            console.warn('sceRegCloseRegistry');
            return 0;
        });
    }
    return sceReg;
})();
exports.sceReg = sceReg;
var RegParam = (function () {
    function RegParam() {
    }
    RegParam.struct = StructClass.create(RegParam, [
        { regType: UInt32 },
        { name: Stringz(256) },
        { nameLength: Int32 },
        { unknown2: Int32 },
        { unknown3: Int32 },
    ]);
    return RegParam;
})();

},
"src/hle/module/sceRtc": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var SceKernelErrors = require('../SceKernelErrors');
var _structs = require('../structs');
var ScePspDateTime = _structs.ScePspDateTime;
var sceRtc = (function () {
    function sceRtc(context) {
        var _this = this;
        this.context = context;
        this.sceRtcGetCurrentTick = createNativeFunction(0x3F7AD767, 150, 'int', 'void*', this, function (tickPtr) {
            tickPtr.writeUInt64(_structs.ScePspDateTime.fromDate(new Date()).getTotalMicroseconds());
            return 0;
        });
        this.sceRtcGetDayOfWeek = createNativeFunction(0x57726BC1, 150, 'int', 'int/int/int', this, function (year, month, day) {
            return _this.context.rtc.getDayOfWeek(year, month, day);
        });
        this.sceRtcGetDaysInMonth = createNativeFunction(0x05EF322C, 150, 'int', 'int/int', this, function (year, month) {
            return _this.context.rtc.getDaysInMonth(year, month);
        });
        this.sceRtcGetTickResolution = createNativeFunction(0xC41C2853, 150, 'uint', 'void*', this, function (tickPtr) {
            return 1000000;
        });
        this.sceRtcSetTick = createNativeFunction(0x7ED29E40, 150, 'int', 'void*/void*', this, function (datePtr, ticksPtr) {
            var ticks = ticksPtr.readInt64();
            datePtr.writeStruct(_structs.ScePspDateTime.struct, _structs.ScePspDateTime.fromTicks(ticks));
            return 0;
        });
        this.sceRtcGetTick = createNativeFunction(0x6FF40ACC, 150, 'int', 'void*/void*', this, function (datePtr, ticksPtr) {
            try {
                var date = _structs.ScePspDateTime.struct.read(datePtr);
                ticksPtr.writeUInt64(date.getTotalMicroseconds());
                return 0;
            }
            catch (e) {
                return SceKernelErrors.ERROR_INVALID_VALUE;
            }
        });
        this.sceRtcGetCurrentClock = createNativeFunction(0x4CFA57B0, 150, 'int', 'uint/int', this, function (dateAddress, timezone) {
            //var currentDate = this.context.rtc.getCurrentUnixMicroseconds();
            var date = new Date();
            var pointer = _this.context.memory.getPointerPointer(ScePspDateTime.struct, dateAddress);
            pointer.write(ScePspDateTime.fromDate(new Date()));
            return 0;
        });
    }
    return sceRtc;
})();
exports.sceRtc = sceRtc;

},
"src/hle/module/sceSasCore": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var _audio = require('../../core/audio');
var _vag = require('../../format/vag');
var createNativeFunction = _utils.createNativeFunction;
var SceKernelErrors = require('../SceKernelErrors');
var Sample = _audio.Sample;
var VagSoundSource = _vag.VagSoundSource;
var PSP_SAS_VOL_MAX = 0x1000;
var PSP_SAS_PITCH_MIN = 0x1;
var PSP_SAS_PITCH_BASE = 0x1000;
var PSP_SAS_PITCH_MAX = 0x4000;
var sceSasCore = (function () {
    function sceSasCore(context) {
        var _this = this;
        this.context = context;
        this.core = new SasCore();
        this.__sceSasInit = createNativeFunction(0x42778A9F, 150, 'uint', 'int/int/int/int/int', this, function (sasCorePointer, grainSamples, maxVoices, outputMode, sampleRate) {
            if (sampleRate != 44100) {
                return SceKernelErrors.ERROR_SAS_INVALID_SAMPLE_RATE;
            }
            if (maxVoices < 1 || maxVoices > sceSasCore.PSP_SAS_VOICES_MAX) {
                return SceKernelErrors.ERROR_SAS_INVALID_MAX_VOICES;
            }
            if (outputMode != OutputMode.STEREO && outputMode != OutputMode.MULTICHANNEL) {
                return SceKernelErrors.ERROR_SAS_INVALID_OUTPUT_MODE;
            }
            _this.core.grainSamples = grainSamples;
            _this.core.maxVoices = maxVoices;
            _this.core.outputMode = outputMode;
            _this.core.sampleRate = sampleRate;
            _this.core.initialized = true;
            return 0;
        });
        this.__sceSasSetGrain = createNativeFunction(0xD1E0A01E, 150, 'uint', 'int/int', this, function (sasCorePointer, grainSamples) {
            _this.core.grainSamples = grainSamples;
            return 0;
        });
        this.__sceSasSetOutputmode = createNativeFunction(0xE855BF76, 150, 'uint', 'int/int', this, function (sasCorePointer, outputMode) {
            _this.core.outputMode = outputMode;
            return 0;
        });
        this.__sceSasSetVoice = createNativeFunction(0x99944089, 150, 'uint', 'int/int/byte[]/int', this, function (sasCorePointer, voiceId, data, loop) {
            if (!_this.hasSasCoreVoice(sasCorePointer, voiceId))
                return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
            var voice = _this.getSasCoreVoice(sasCorePointer, voiceId);
            if (data == null) {
                voice.unsetSource();
                return 0;
            }
            if (data.length == 0)
                return SceKernelErrors.ERROR_SAS_INVALID_ADPCM_SIZE;
            if (data.length < 0x10)
                return SceKernelErrors.ERROR_SAS_INVALID_ADPCM_SIZE;
            if (data.length % 0x10)
                return SceKernelErrors.ERROR_SAS_INVALID_ADPCM_SIZE;
            if (data == Stream.INVALID)
                return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
            if (loop != 0 && loop != 1)
                return SceKernelErrors.ERROR_SAS_INVALID_LOOP_POS;
            if (data == null) {
                voice.unsetSource();
            }
            else {
                voice.setAdpcm(data, loop);
            }
            return 0;
        });
        this.__sceSasSetVoicePCM = createNativeFunction(0xE1CD9561, 150, 'uint', 'int/int/byte[]/int', this, function (sasCorePointer, voiceId, data, loop) {
            if (!_this.hasSasCoreVoice(sasCorePointer, voiceId))
                return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
            var voice = _this.getSasCoreVoice(sasCorePointer, voiceId);
            if (data == null) {
                voice.unsetSource();
            }
            else {
                voice.setPCM(data, loop);
            }
            return 0;
        });
        this.__sceSasCoreWithMix = createNativeFunction(0x50A14DFC, 150, 'uint', 'int/void*/int/int', this, function (sasCorePointer, sasOut, leftVolume, rightVolume) {
            return _this.core.mix(sasCorePointer, sasOut, leftVolume, rightVolume);
        });
        this.__sceSasCore = createNativeFunction(0xA3589D81, 150, 'uint', 'int/void*', this, function (sasCorePointer, sasOut) {
            return _this.core.mix(sasCorePointer, sasOut, PSP_SAS_VOL_MAX, PSP_SAS_VOL_MAX);
        });
        this.__sceSasGetEndFlag = createNativeFunction(0x68A46B95, 150, 'uint', 'int', this, function (sasCorePointer) {
            return _this.core.endFlags;
        });
        this.__sceSasRevType = createNativeFunction(0x33D4AB37, 150, 'uint', 'int/int', this, function (sasCorePointer, waveformEffectType) {
            _this.core.waveformEffectType = waveformEffectType;
            return 0;
        });
        this.__sceSasRevVON = createNativeFunction(0xF983B186, 150, 'uint', 'int/int/int', this, function (sasCorePointer, waveformEffectIsDry, waveformEffectIsWet) {
            _this.core.waveformEffectIsDry = waveformEffectIsDry;
            _this.core.waveformEffectIsWet = waveformEffectIsWet;
            return 0;
        });
        this.__sceSasRevEVOL = createNativeFunction(0xD5A229C9, 150, 'uint', 'int/int/int', this, function (sasCorePointer, leftVolume, rightVolume) {
            _this.core.leftVolume = leftVolume;
            _this.core.rightVolume = rightVolume;
            return 0;
        });
        this.__sceSasSetADSR = createNativeFunction(0x019B25EB, 150, 'uint', 'int/int/int/int/int/int/int', this, function (sasCorePointer, voiceId, flags, attackRate, decayRate, sustainRate, releaseRate) {
            if (!_this.hasSasCoreVoice(sasCorePointer, voiceId))
                return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
            var voice = _this.getSasCoreVoice(sasCorePointer, voiceId);
            if (flags & AdsrFlags.HasAttack)
                voice.envelope.attackRate = attackRate;
            if (flags & AdsrFlags.HasDecay)
                voice.envelope.decayRate = decayRate;
            if (flags & AdsrFlags.HasSustain)
                voice.envelope.sustainRate = sustainRate;
            if (flags & AdsrFlags.HasRelease)
                voice.envelope.releaseRate = releaseRate;
            return 0;
        });
        this.__sceSasSetADSRmode = createNativeFunction(0x9EC3676A, 150, 'uint', 'int/int/int/int/int/int/int', this, function (sasCorePointer, voiceId, flags, attackCurveMode, decayCurveMode, sustainCurveMode, releaseCurveMode) {
            console.warn('__sceSasSetADSRmode not implemented!');
            return 0;
        });
        this.__sceSasSetKeyOff = createNativeFunction(0xA0CF2FA4, 150, 'uint', 'int/int', this, function (sasCorePointer, voiceId) {
            if (!_this.hasSasCoreVoice(sasCorePointer, voiceId))
                return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
            var voice = _this.getSasCoreVoice(sasCorePointer, voiceId);
            if (!voice.paused)
                return SceKernelErrors.ERROR_SAS_VOICE_PAUSED;
            voice.setOn(false);
            return 0;
        });
        this.__sceSasSetKeyOn = createNativeFunction(0x76F01ACA, 150, 'uint', 'int/int', this, function (sasCorePointer, voiceId) {
            if (!_this.hasSasCoreVoice(sasCorePointer, voiceId))
                return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
            var voice = _this.getSasCoreVoice(sasCorePointer, voiceId);
            voice.setOn(true);
            return 0;
        });
        this.__sceSasGetEnvelopeHeight = createNativeFunction(0x74AE582A, 150, 'uint', 'int/int', this, function (sasCorePointer, voiceId) {
            if (!_this.hasSasCoreVoice(sasCorePointer, voiceId))
                return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
            var voice = _this.getSasCoreVoice(sasCorePointer, voiceId);
            return voice.envelope.height;
        });
        this.__sceSasSetSL = createNativeFunction(0x5F9529F6, 150, 'uint', 'int/int/int', this, function (sasCorePointer, voiceId, sustainLevel) {
            if (!_this.hasSasCoreVoice(sasCorePointer, voiceId))
                return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
            var voice = _this.getSasCoreVoice(sasCorePointer, voiceId);
            voice.sustainLevel = sustainLevel;
            return 0;
        });
        this.__sceSasSetPause = createNativeFunction(0x787D04D5, 150, 'uint', 'int/int/int', this, function (sasCorePointer, voiceBits, pause) {
            _this.core.voices.forEach(function (voice) {
                if (voiceBits & (1 << voice.index)) {
                    voice.paused = pause;
                }
            });
            return 0;
        });
        this.__sceSasGetPauseFlag = createNativeFunction(0x2C8E6AB3, 150, 'uint', 'int', this, function (sasCorePointer) {
            var voiceBits = 0;
            _this.core.voices.forEach(function (voice) {
                voiceBits |= (voice.paused ? 1 : 0) << voice.index;
            });
            return voiceBits;
        });
        this.__sceSasGetAllEnvelopeHeights = createNativeFunction(0x07F58C24, 150, 'uint', 'int/void*', this, function (sasCorePointer, heightPtr) {
            _this.core.voices.forEach(function (voice) {
                heightPtr.writeInt32(voice.envelope.height);
            });
            return 0;
        });
        this.__sceSasSetNoise = createNativeFunction(0xB7660A23, 150, 'uint', 'int/int/int', this, function (sasCorePointer, voiceId, noiseFrequency) {
            if (noiseFrequency < 0 || noiseFrequency >= 64)
                return SceKernelErrors.ERROR_SAS_INVALID_NOISE_CLOCK;
            if (!_this.hasSasCoreVoice(sasCorePointer, voiceId))
                return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
            var voice = _this.getSasCoreVoice(sasCorePointer, voiceId);
            return 0;
        });
        this.__sceSasSetVolume = createNativeFunction(0x440CA7D8, 150, 'uint', 'int/int/int/int/int/int', this, function (sasCorePointer, voiceId, leftVolume, rightVolume, effectLeftVol, effectRightVol) {
            if (!_this.hasSasCoreVoice(sasCorePointer, voiceId))
                return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
            var voice = _this.getSasCoreVoice(sasCorePointer, voiceId);
            leftVolume = Math.abs(leftVolume);
            rightVolume = Math.abs(rightVolume);
            effectLeftVol = Math.abs(effectLeftVol);
            effectRightVol = Math.abs(effectRightVol);
            if (leftVolume > PSP_SAS_VOL_MAX || rightVolume > PSP_SAS_VOL_MAX || effectLeftVol > PSP_SAS_VOL_MAX || effectRightVol > PSP_SAS_VOL_MAX) {
                return SceKernelErrors.ERROR_SAS_INVALID_VOLUME_VAL;
            }
            voice.leftVolume = leftVolume;
            voice.rightVolume = rightVolume;
            voice.effectLeftVolume = effectLeftVol;
            voice.effectRightVolume = effectRightVol;
            return 0;
        });
        this.__sceSasSetPitch = createNativeFunction(0xAD84D37F, 150, 'uint', 'int/int/int', this, function (sasCorePointer, voiceId, pitch) {
            if (!_this.hasSasCoreVoice(sasCorePointer, voiceId))
                return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
            var voice = _this.getSasCoreVoice(sasCorePointer, voiceId);
            if (pitch < PSP_SAS_PITCH_MIN || pitch > PSP_SAS_PITCH_MAX)
                return -1;
            voice.pitch = pitch;
            return 0;
        });
        this.__sceSasRevParam = createNativeFunction(0x267A6DD2, 150, 'uint', 'int/int/int', this, function (sasCorePointer, delay, feedback) {
            _this.core.delay = delay;
            _this.core.feedback = feedback;
            return 0;
        });
        this.__sceSasSetSimpleADSR = createNativeFunction(0xCBCD4F79, 150, 'uint', 'int/int/int/int', this, function (sasCorePointer, voiceId, env1Bitfield, env2Bitfield) {
            if (!_this.hasSasCoreVoice(sasCorePointer, voiceId))
                return SceKernelErrors.ERROR_SAS_INVALID_VOICE;
            var voice = _this.getSasCoreVoice(sasCorePointer, voiceId);
            return 0;
        });
    }
    sceSasCore.prototype.hasSasCoreVoice = function (sasCorePointer, voiceId) {
        return this.core.voices[voiceId] != null;
    };
    sceSasCore.prototype.getSasCoreVoice = function (sasCorePointer, voiceId) {
        return this.core.voices[voiceId];
    };
    sceSasCore.PSP_SAS_VOICES_MAX = 32;
    sceSasCore.PSP_SAS_GRAIN_SAMPLES = 256;
    sceSasCore.PSP_SAS_LOOP_MODE_OFF = 0;
    sceSasCore.PSP_SAS_LOOP_MODE_ON = 1;
    sceSasCore.PSP_SAS_NOISE_FREQ_MAX = 0x3F;
    sceSasCore.PSP_SAS_ENVELOPE_HEIGHT_MAX = 0x40000000;
    sceSasCore.PSP_SAS_ENVELOPE_FREQ_MAX = 0x7FFFFFFF;
    sceSasCore.PSP_SAS_ADSR_ATTACK = 1;
    sceSasCore.PSP_SAS_ADSR_DECAY = 2;
    sceSasCore.PSP_SAS_ADSR_SUSTAIN = 4;
    sceSasCore.PSP_SAS_ADSR_RELEASE = 8;
    return sceSasCore;
})();
exports.sceSasCore = sceSasCore;
var SasCore = (function () {
    function SasCore() {
        this.initialized = false;
        this.grainSamples = 0;
        this.maxVoices = 32;
        this.outputMode = OutputMode.STEREO;
        this.sampleRate = 44100;
        this.delay = 0;
        this.feedback = 0;
        this.endFlags = 0;
        this.waveformEffectType = WaveformEffectType.OFF;
        this.waveformEffectIsDry = false;
        this.waveformEffectIsWet = false;
        this.leftVolume = PSP_SAS_VOL_MAX;
        this.rightVolume = PSP_SAS_VOL_MAX;
        this.voices = [];
        this.bufferTempArray = [];
        while (this.voices.length < 32)
            this.voices.push(new Voice(this.voices.length));
    }
    SasCore.prototype.mix = function (sasCorePointer, sasOut, leftVolume, rightVolume) {
        while (this.bufferTempArray.length < this.grainSamples)
            this.bufferTempArray.push(new Sample(0, 0));
        var numberOfChannels = (this.outputMode == OutputMode.STEREO) ? 2 : 1;
        var numberOfSamples = this.grainSamples;
        var numberOfVoicesPlaying = Math.max(1, this.voices.count(function (Voice) { return Voice.onAndPlaying; }));
        for (var n = 0; n < numberOfSamples; n++)
            this.bufferTempArray[n].set(0, 0);
        var prevPosDiv = -1;
        for (var n = 0; n < this.voices.length; n++) {
            var voice = this.voices[n];
            if (!voice.onAndPlaying)
                continue;
            var pos = 0;
            while (true) {
                if ((voice.source != null) && (voice.source.hasMore)) {
                    var posDiv = Math.floor(pos / voice.pitch);
                    if (posDiv >= numberOfSamples)
                        break;
                    var sample = voice.source.getNextSample();
                    for (var m = prevPosDiv + 1; m <= posDiv; m++) {
                        this.bufferTempArray[m].addScaled(sample, voice.leftVolume / PSP_SAS_VOL_MAX, voice.rightVolume / PSP_SAS_VOL_MAX);
                    }
                    prevPosDiv = posDiv;
                    pos += PSP_SAS_PITCH_BASE;
                }
                else {
                    voice.setPlaying(false);
                    break;
                }
            }
        }
        for (var n = 0; n < numberOfSamples; n++) {
            var sample = this.bufferTempArray[n];
            sample.scale(leftVolume / PSP_SAS_VOL_MAX, rightVolume / PSP_SAS_VOL_MAX);
            if (numberOfChannels >= 1)
                sasOut.writeInt16(MathUtils.clamp(sample.left, -32768, 32767));
            if (numberOfChannels >= 2)
                sasOut.writeInt16(MathUtils.clamp(sample.right, -32768, 32767));
        }
        return 0;
    };
    return SasCore;
})();
var Voice = (function () {
    function Voice(index) {
        this.index = index;
        this.envelope = new Envelope();
        this.sustainLevel = 0;
        this.on = false;
        this.playing = false;
        this.paused = false;
        this.leftVolume = PSP_SAS_VOL_MAX;
        this.rightVolume = PSP_SAS_VOL_MAX;
        this.effectLeftVolume = PSP_SAS_VOL_MAX;
        this.effectRightVolume = PSP_SAS_VOL_MAX;
        this.pitch = PSP_SAS_PITCH_BASE;
        this.source = null;
    }
    Object.defineProperty(Voice.prototype, "onAndPlaying", {
        get: function () {
            return this.on && this.playing;
        },
        enumerable: true,
        configurable: true
    });
    Voice.prototype.setOn = function (set) {
        this.on = set;
        this.setPlaying(set);
    };
    Voice.prototype.setPlaying = function (set) {
        this.playing = set;
        if (this.source)
            this.source.reset();
    };
    Object.defineProperty(Voice.prototype, "ended", {
        get: function () {
            return !this.playing;
        },
        enumerable: true,
        configurable: true
    });
    Voice.prototype.unsetSource = function () {
        this.source = null;
    };
    Voice.prototype.setAdpcm = function (stream, loopCount) {
        this.source = new VagSoundSource(stream, loopCount);
        this.source.reset();
    };
    Voice.prototype.setPCM = function (stream, loopCount) {
        this.source = new PcmSoundSource(stream, loopCount);
        this.source.reset();
    };
    return Voice;
})();
var PcmSoundSource = (function () {
    function PcmSoundSource(stream, loopCount) {
    }
    PcmSoundSource.prototype.reset = function () {
    };
    Object.defineProperty(PcmSoundSource.prototype, "hasMore", {
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    PcmSoundSource.prototype.getNextSample = function () {
        return null;
    };
    return PcmSoundSource;
})();
var Envelope = (function () {
    function Envelope() {
        this.attackRate = 0;
        this.decayRate = 0;
        this.sustainRate = 0;
        this.releaseRate = 0;
        this.height = 0;
    }
    return Envelope;
})();
var OutputMode;
(function (OutputMode) {
    OutputMode[OutputMode["STEREO"] = 0] = "STEREO";
    OutputMode[OutputMode["MULTICHANNEL"] = 1] = "MULTICHANNEL";
})(OutputMode || (OutputMode = {}));
var WaveformEffectType;
(function (WaveformEffectType) {
    WaveformEffectType[WaveformEffectType["OFF"] = -1] = "OFF";
    WaveformEffectType[WaveformEffectType["ROOM"] = 0] = "ROOM";
    WaveformEffectType[WaveformEffectType["UNK1"] = 1] = "UNK1";
    WaveformEffectType[WaveformEffectType["UNK2"] = 2] = "UNK2";
    WaveformEffectType[WaveformEffectType["UNK3"] = 3] = "UNK3";
    WaveformEffectType[WaveformEffectType["HALL"] = 4] = "HALL";
    WaveformEffectType[WaveformEffectType["SPACE"] = 5] = "SPACE";
    WaveformEffectType[WaveformEffectType["ECHO"] = 6] = "ECHO";
    WaveformEffectType[WaveformEffectType["DELAY"] = 7] = "DELAY";
    WaveformEffectType[WaveformEffectType["PIPE"] = 8] = "PIPE";
})(WaveformEffectType || (WaveformEffectType = {}));
var AdsrCurveMode;
(function (AdsrCurveMode) {
    AdsrCurveMode[AdsrCurveMode["LINEAR_INCREASE"] = 0] = "LINEAR_INCREASE";
    AdsrCurveMode[AdsrCurveMode["LINEAR_DECREASE"] = 1] = "LINEAR_DECREASE";
    AdsrCurveMode[AdsrCurveMode["LINEAR_BENT"] = 2] = "LINEAR_BENT";
    AdsrCurveMode[AdsrCurveMode["EXPONENT_REV"] = 3] = "EXPONENT_REV";
    AdsrCurveMode[AdsrCurveMode["EXPONENT"] = 4] = "EXPONENT";
    AdsrCurveMode[AdsrCurveMode["DIRECT"] = 5] = "DIRECT";
})(AdsrCurveMode || (AdsrCurveMode = {}));
var AdsrFlags;
(function (AdsrFlags) {
    AdsrFlags[AdsrFlags["HasAttack"] = 1] = "HasAttack";
    AdsrFlags[AdsrFlags["HasDecay"] = 2] = "HasDecay";
    AdsrFlags[AdsrFlags["HasSustain"] = 4] = "HasSustain";
    AdsrFlags[AdsrFlags["HasRelease"] = 8] = "HasRelease";
})(AdsrFlags || (AdsrFlags = {}));

},
"src/hle/module/sceSsl": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var sceSsl = (function () {
    function sceSsl(context) {
        this.context = context;
    }
    return sceSsl;
})();
exports.sceSsl = sceSsl;

},
"src/hle/module/sceSuspendForUser": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var SceKernelErrors = require('../SceKernelErrors');
var sceSuspendForUser = (function () {
    function sceSuspendForUser(context) {
        this.context = context;
        this.sceKernelPowerLock = createNativeFunction(0xEADB1BD7, 150, 'uint', 'uint', this, function (lockType) {
            if (lockType != 0)
                return SceKernelErrors.ERROR_INVALID_MODE;
            return 0;
        });
        this.sceKernelPowerUnlock = createNativeFunction(0x3AEE7261, 150, 'uint', 'uint', this, function (lockType) {
            if (lockType != 0)
                return SceKernelErrors.ERROR_INVALID_MODE;
            return 0;
        });
        this.sceKernelPowerTick = createNativeFunction(0x090CCB3F, 150, 'uint', 'uint', this, function (value) {
            return 0;
        });
    }
    return sceSuspendForUser;
})();
exports.sceSuspendForUser = sceSuspendForUser;

},
"src/hle/module/sceUmdUser": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var SceKernelErrors = require('../SceKernelErrors');
var sceUmdUser = (function () {
    function sceUmdUser(context) {
        var _this = this;
        this.context = context;
        this.callbackIds = [];
        this.signal = new Signal();
        this.sceUmdRegisterUMDCallBack = createNativeFunction(0xAEE7404D, 150, 'uint', 'int', this, function (callbackId) {
            _this.callbackIds.push(callbackId);
            return 0;
        });
        this.sceUmdUnRegisterUMDCallBack = createNativeFunction(0xBD2BDE07, 150, 'uint', 'int', this, function (callbackId) {
            if (!_this.callbackIds.contains(callbackId))
                return SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;
            _this.callbackIds.remove(callbackId);
            return 0;
        });
        this.sceUmdCheckMedium = createNativeFunction(0x46EBB729, 150, 'uint', '', this, function () {
            return UmdCheckMedium.Inserted;
        });
        this.sceUmdWaitDriveStat = createNativeFunction(0x8EF08FCE, 150, 'uint', 'uint', this, function (pspUmdState) {
            return _this._sceUmdWaitDriveStat(pspUmdState, AcceptCallbacks.NO);
        });
        this.sceUmdWaitDriveStatCB = createNativeFunction(0x4A9E5E29, 150, 'uint', 'uint/uint', this, function (pspUmdState, timeout) {
            return _this._sceUmdWaitDriveStat(pspUmdState, AcceptCallbacks.YES);
        });
        this.sceUmdActivate = createNativeFunction(0xC6183D47, 150, 'uint', 'int/string', this, function (mode, drive) {
            _this._notify(PspUmdState.PSP_UMD_READABLE | PspUmdState.PSP_UMD_READY | PspUmdState.PSP_UMD_PRESENT);
            return 0;
        });
        this.sceUmdDeactivate = createNativeFunction(0xE83742BA, 150, 'uint', 'int/string', this, function (mode, drive) {
            _this._notify(PspUmdState.PSP_UMD_READABLE | PspUmdState.PSP_UMD_READY | PspUmdState.PSP_UMD_PRESENT);
            return 0;
        });
        this.sceUmdGetDriveStat = createNativeFunction(0x6B4A146C, 150, 'uint', '', this, function () {
            return PspUmdState.PSP_UMD_PRESENT | PspUmdState.PSP_UMD_READY | PspUmdState.PSP_UMD_READABLE;
        });
        this.sceUmdWaitDriveStatWithTimer = createNativeFunction(0x56202973, 150, 'uint', 'uint/uint', this, function (state, timeout) {
            return Promise2.resolve(0);
        });
        this.sceUmdGetErrorStat = createNativeFunction(0x20628E6F, 150, 'uint', '', this, function () {
            console.warn('called sceUmdGetErrorStat!');
            return Promise2.resolve(0);
        });
    }
    sceUmdUser.prototype._sceUmdWaitDriveStat = function (pspUmdState, acceptCallbacks) {
        this.context.callbackManager.executePendingWithinThread(this.context.threadManager.current);
        return 0;
    };
    sceUmdUser.prototype._notify = function (data) {
        var _this = this;
        this.signal.dispatch(data);
        this.callbackIds.forEach(function (callbackId) {
            _this.context.callbackManager.notify(callbackId, data);
        });
    };
    return sceUmdUser;
})();
exports.sceUmdUser = sceUmdUser;
var UmdCheckMedium;
(function (UmdCheckMedium) {
    UmdCheckMedium[UmdCheckMedium["NoDisc"] = 0] = "NoDisc";
    UmdCheckMedium[UmdCheckMedium["Inserted"] = 1] = "Inserted";
})(UmdCheckMedium || (UmdCheckMedium = {}));
var PspUmdState;
(function (PspUmdState) {
    PspUmdState[PspUmdState["PSP_UMD_INIT"] = 0] = "PSP_UMD_INIT";
    PspUmdState[PspUmdState["PSP_UMD_NOT_PRESENT"] = 1] = "PSP_UMD_NOT_PRESENT";
    PspUmdState[PspUmdState["PSP_UMD_PRESENT"] = 2] = "PSP_UMD_PRESENT";
    PspUmdState[PspUmdState["PSP_UMD_CHANGED"] = 4] = "PSP_UMD_CHANGED";
    PspUmdState[PspUmdState["PSP_UMD_NOT_READY"] = 8] = "PSP_UMD_NOT_READY";
    PspUmdState[PspUmdState["PSP_UMD_READY"] = 16] = "PSP_UMD_READY";
    PspUmdState[PspUmdState["PSP_UMD_READABLE"] = 32] = "PSP_UMD_READABLE";
})(PspUmdState || (PspUmdState = {}));

},
"src/hle/module/sceUtility": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var _vfs = require('../vfs');
var _structs = require('../structs');
var createNativeFunction = _utils.createNativeFunction;
var SceKernelErrors = require('../SceKernelErrors');
var PspLanguages = _structs.PspLanguages;
var FileOpenFlags = _vfs.FileOpenFlags;
var sceUtility = (function () {
    function sceUtility(context) {
        var _this = this;
        this.context = context;
        this.currentStep = DialogStepEnum.NONE;
        this.sceUtilityLoadModule = createNativeFunction(0x2A2B3DE0, 150, 'uint', 'int', this, function (pspModule) {
            console.warn("Not implemented sceUtilityLoadModule '" + pspModule + "'");
            return Promise2.resolve(0);
        });
        this.sceUtilitySavedataInitStart = createNativeFunction(0x50C4CD57, 150, 'uint', 'void*', this, function (paramsPtr) {
            return Promise2.resolve(_this._sceUtilitySavedataInitStart(paramsPtr.clone())).then(function (result) {
                var params = SceUtilitySavedataParam.struct.read(paramsPtr.clone());
                params.base.result = result;
                return 0;
            });
        });
        this.sceUtilitySavedataShutdownStart = createNativeFunction(0x9790B33C, 150, 'uint', '', this, function () {
            _this.currentStep = DialogStepEnum.SHUTDOWN;
            return 0;
        });
        this.sceUtilitySavedataGetStatus = createNativeFunction(0x8874DBE0, 150, 'uint', '', this, function () {
            try {
                return _this.currentStep;
            }
            finally {
                if (_this.currentStep == DialogStepEnum.SHUTDOWN)
                    _this.currentStep = DialogStepEnum.NONE;
            }
        });
        this.sceUtilityMsgDialogInitStart = createNativeFunction(0x2AD8E239, 150, 'uint', 'void*', this, function (paramsPtr) {
            console.warn("Not implemented sceUtilityMsgDialogInitStart()");
            _this.currentStep = DialogStepEnum.PROCESSING;
            return 0;
        });
        this.sceUtilityMsgDialogGetStatus = createNativeFunction(0x9A1C91D7, 150, 'uint', '', this, function () {
            try {
                return _this.currentStep;
            }
            finally {
                if (_this.currentStep == DialogStepEnum.SHUTDOWN)
                    _this.currentStep = DialogStepEnum.NONE;
            }
        });
        this.sceUtilityMsgDialogUpdate = createNativeFunction(0x9A1C91D7, 150, 'uint', 'int', this, function (value) {
        });
        this.sceUtilityLoadNetModule = createNativeFunction(0x1579A159, 150, 'uint', '', this, function () {
            console.warn('Not implemented sceUtilityLoadNetModule');
            return 0;
        });
        this.sceUtilityGetSystemParamInt = createNativeFunction(0xA5DA2406, 150, 'uint', 'int/void*', this, function (id, valuePtr) {
            var value = parseInt(_this._getKey(id));
            if (valuePtr)
                valuePtr.writeInt32(value);
            return 0;
        });
        this.sceUtilityGetSystemParamString = createNativeFunction(0x34B78343, 150, 'uint', 'int/void*/int', this, function (id, strPtr, len) {
            var value = String(_this._getKey(id));
            value = value.substr(0, Math.min(value.length, len - 1));
            if (strPtr)
                strPtr.writeStringz(value);
            return 0;
        });
        this.sceUtilityLoadAvModule = createNativeFunction(0xC629AF26, 150, 'uint', 'int', this, function (id) {
            return 0;
        });
    }
    sceUtility.prototype._sceUtilitySavedataInitStart = function (paramsPtr) {
        var _this = this;
        console.log('sceUtilitySavedataInitStart');
        var params = SceUtilitySavedataParam.struct.read(paramsPtr);
        var fileManager = this.context.fileManager;
        var savePathFolder = "ms0:/PSP/SAVEDATA/" + params.gameName + params.saveName;
        var saveDataBin = savePathFolder + "/DATA.BIN";
        var saveIcon0 = savePathFolder + "/ICON0.PNG";
        var savePic1 = savePathFolder + "/PIC1.PNG";
        this.currentStep = DialogStepEnum.SUCCESS;
        params.base.result = 0;
        switch (params.mode) {
            case PspUtilitySavedataMode.Autoload:
            case PspUtilitySavedataMode.Load:
            case PspUtilitySavedataMode.ListLoad:
                return fileManager
                    .openAsync(saveDataBin, FileOpenFlags.Read, parseIntFormat('0777'))
                    .then(function (file) { return file.entry.readAllAsync(); })
                    .then(function (data) {
                    _this.context.memory.writeBytes(params.dataBufPointer, data);
                    return 0;
                })
                    .catch(function (error) {
                    return SceKernelErrors.ERROR_SAVEDATA_LOAD_NO_DATA;
                });
            case PspUtilitySavedataMode.Autosave:
            case PspUtilitySavedataMode.Save:
            case PspUtilitySavedataMode.ListSave:
                var data = this.context.memory.readArrayBuffer(params.dataBufPointer, params.dataSize);
                return fileManager
                    .openAsync(saveDataBin, FileOpenFlags.Create | FileOpenFlags.Truncate | FileOpenFlags.Write, parseIntFormat('0777'))
                    .then(function (file) { return file.entry.writeAllAsync(data); })
                    .then(function (written) {
                    return 0;
                })
                    .catch(function (error) {
                    return SceKernelErrors.ERROR_SAVEDATA_SAVE_ACCESS_ERROR;
                });
            case PspUtilitySavedataMode.Read:
            case PspUtilitySavedataMode.ReadSecure:
                {
                    console.error("Not Implemented: sceUtilitySavedataInitStart.Read");
                    return Promise2.resolve(0);
                }
                break;
            case PspUtilitySavedataMode.Sizes:
                {
                    var SceKernelError = SceKernelErrors.ERROR_OK;
                    var SectorSize = 1024;
                    var FreeSize = 32 * 1024 * 1024;
                    var UsedSize = 0;
                    {
                        var sizeFreeInfoPtr = this.context.memory.getPointerPointer(SizeFreeInfo.struct, params.msFreeAddr);
                        sizeFreeInfoPtr.readWrite(function (sizeFreeInfo) {
                            sizeFreeInfo.sectorSize = SectorSize;
                            sizeFreeInfo.freeSectors = FreeSize / SectorSize;
                            sizeFreeInfo.freeKb = FreeSize / 1024;
                            sizeFreeInfo.freeKbString = sizeFreeInfo.freeKb + 'KB';
                        });
                    }
                    {
                        var sizeUsedInfoPtr = this.context.memory.getPointerPointer(SizeUsedInfo.struct, params.msDataAddr);
                    }
                    {
                        var sizeRequiredSpaceInfoPtr = this.context.memory.getPointerPointer(SizeRequiredSpaceInfo.struct, params.utilityDataAddr);
                        if (sizeRequiredSpaceInfoPtr != null) {
                            var RequiredSize = 0;
                            RequiredSize += params.icon0FileData.size;
                            RequiredSize += params.icon1FileData.size;
                            RequiredSize += params.pic1FileData.size;
                            RequiredSize += params.snd0FileData.size;
                            RequiredSize += params.dataSize;
                            sizeRequiredSpaceInfoPtr.readWrite(function (sizeRequiredSpaceInfo) {
                                sizeRequiredSpaceInfo.requiredSpaceSectors = MathUtils.requiredBlocks(RequiredSize, SectorSize);
                                sizeRequiredSpaceInfo.requiredSpaceKb = MathUtils.requiredBlocks(RequiredSize, 1024);
                                sizeRequiredSpaceInfo.requiredSpace32KB = MathUtils.requiredBlocks(RequiredSize, 32 * 1024);
                                sizeRequiredSpaceInfo.requiredSpaceString = (sizeRequiredSpaceInfo.requiredSpaceKb) + "KB";
                                sizeRequiredSpaceInfo.requiredSpace32KBString = (sizeRequiredSpaceInfo.requiredSpace32KB) + "KB";
                            });
                        }
                    }
                    if (SceKernelError != SceKernelErrors.ERROR_OK)
                        return Promise2.resolve(SceKernelError);
                }
                break;
            default:
                throw (new Error("Not implemented " + params.mode + ': ' + PspUtilitySavedataMode[params.mode]));
        }
        return Promise2.resolve(0);
    };
    sceUtility.prototype._getKey = function (id) {
        switch (id) {
            case PSP_SYSTEMPARAM_ID.INT_ADHOC_CHANNEL: return PSP_SYSTEMPARAM_ADHOC_CHANNEL.AUTOMATIC;
            case PSP_SYSTEMPARAM_ID.INT_WLAN_POWERSAVE: return PSP_SYSTEMPARAM_WLAN_POWERSAVE.ON;
            case PSP_SYSTEMPARAM_ID.INT_DATE_FORMAT: return PSP_SYSTEMPARAM_DATE_FORMAT.YYYYMMDD;
            case PSP_SYSTEMPARAM_ID.INT_TIME_FORMAT: return PSP_SYSTEMPARAM_TIME_FORMAT._24HR;
            case PSP_SYSTEMPARAM_ID.INT_TIMEZONE: return -5 * 60;
            case PSP_SYSTEMPARAM_ID.INT_DAYLIGHTSAVINGS: return PSP_SYSTEMPARAM_DAYLIGHTSAVINGS.STD;
            case PSP_SYSTEMPARAM_ID.INT_LANGUAGE: return this.context.config.language;
            case PSP_SYSTEMPARAM_ID.INT_BUTTON_PREFERENCE: return PSP_SYSTEMPARAM_BUTTON_PREFERENCE.NA;
            case PSP_SYSTEMPARAM_ID.STRING_NICKNAME: return "USERNAME";
        }
        throw (new Error("Invalid key " + id));
    };
    return sceUtility;
})();
exports.sceUtility = sceUtility;
var PSP_SYSTEMPARAM_ID;
(function (PSP_SYSTEMPARAM_ID) {
    PSP_SYSTEMPARAM_ID[PSP_SYSTEMPARAM_ID["STRING_NICKNAME"] = 1] = "STRING_NICKNAME";
    PSP_SYSTEMPARAM_ID[PSP_SYSTEMPARAM_ID["INT_ADHOC_CHANNEL"] = 2] = "INT_ADHOC_CHANNEL";
    PSP_SYSTEMPARAM_ID[PSP_SYSTEMPARAM_ID["INT_WLAN_POWERSAVE"] = 3] = "INT_WLAN_POWERSAVE";
    PSP_SYSTEMPARAM_ID[PSP_SYSTEMPARAM_ID["INT_DATE_FORMAT"] = 4] = "INT_DATE_FORMAT";
    PSP_SYSTEMPARAM_ID[PSP_SYSTEMPARAM_ID["INT_TIME_FORMAT"] = 5] = "INT_TIME_FORMAT";
    PSP_SYSTEMPARAM_ID[PSP_SYSTEMPARAM_ID["INT_TIMEZONE"] = 6] = "INT_TIMEZONE";
    PSP_SYSTEMPARAM_ID[PSP_SYSTEMPARAM_ID["INT_DAYLIGHTSAVINGS"] = 7] = "INT_DAYLIGHTSAVINGS";
    PSP_SYSTEMPARAM_ID[PSP_SYSTEMPARAM_ID["INT_LANGUAGE"] = 8] = "INT_LANGUAGE";
    PSP_SYSTEMPARAM_ID[PSP_SYSTEMPARAM_ID["INT_BUTTON_PREFERENCE"] = 9] = "INT_BUTTON_PREFERENCE";
})(PSP_SYSTEMPARAM_ID || (PSP_SYSTEMPARAM_ID = {}));
var DialogStepEnum;
(function (DialogStepEnum) {
    DialogStepEnum[DialogStepEnum["NONE"] = 0] = "NONE";
    DialogStepEnum[DialogStepEnum["INIT"] = 1] = "INIT";
    DialogStepEnum[DialogStepEnum["PROCESSING"] = 2] = "PROCESSING";
    DialogStepEnum[DialogStepEnum["SUCCESS"] = 3] = "SUCCESS";
    DialogStepEnum[DialogStepEnum["SHUTDOWN"] = 4] = "SHUTDOWN";
})(DialogStepEnum || (DialogStepEnum = {}));
var PSP_SYSTEMPARAM_ADHOC_CHANNEL;
(function (PSP_SYSTEMPARAM_ADHOC_CHANNEL) {
    PSP_SYSTEMPARAM_ADHOC_CHANNEL[PSP_SYSTEMPARAM_ADHOC_CHANNEL["AUTOMATIC"] = 0] = "AUTOMATIC";
    PSP_SYSTEMPARAM_ADHOC_CHANNEL[PSP_SYSTEMPARAM_ADHOC_CHANNEL["C1"] = 1] = "C1";
    PSP_SYSTEMPARAM_ADHOC_CHANNEL[PSP_SYSTEMPARAM_ADHOC_CHANNEL["C6"] = 6] = "C6";
    PSP_SYSTEMPARAM_ADHOC_CHANNEL[PSP_SYSTEMPARAM_ADHOC_CHANNEL["C11"] = 11] = "C11";
})(PSP_SYSTEMPARAM_ADHOC_CHANNEL || (PSP_SYSTEMPARAM_ADHOC_CHANNEL = {}));
var PSP_SYSTEMPARAM_WLAN_POWERSAVE;
(function (PSP_SYSTEMPARAM_WLAN_POWERSAVE) {
    PSP_SYSTEMPARAM_WLAN_POWERSAVE[PSP_SYSTEMPARAM_WLAN_POWERSAVE["OFF"] = 0] = "OFF";
    PSP_SYSTEMPARAM_WLAN_POWERSAVE[PSP_SYSTEMPARAM_WLAN_POWERSAVE["ON"] = 1] = "ON";
})(PSP_SYSTEMPARAM_WLAN_POWERSAVE || (PSP_SYSTEMPARAM_WLAN_POWERSAVE = {}));
var PSP_SYSTEMPARAM_DATE_FORMAT;
(function (PSP_SYSTEMPARAM_DATE_FORMAT) {
    PSP_SYSTEMPARAM_DATE_FORMAT[PSP_SYSTEMPARAM_DATE_FORMAT["YYYYMMDD"] = 0] = "YYYYMMDD";
    PSP_SYSTEMPARAM_DATE_FORMAT[PSP_SYSTEMPARAM_DATE_FORMAT["MMDDYYYY"] = 1] = "MMDDYYYY";
    PSP_SYSTEMPARAM_DATE_FORMAT[PSP_SYSTEMPARAM_DATE_FORMAT["DDMMYYYY"] = 2] = "DDMMYYYY";
})(PSP_SYSTEMPARAM_DATE_FORMAT || (PSP_SYSTEMPARAM_DATE_FORMAT = {}));
var PSP_SYSTEMPARAM_TIME_FORMAT;
(function (PSP_SYSTEMPARAM_TIME_FORMAT) {
    PSP_SYSTEMPARAM_TIME_FORMAT[PSP_SYSTEMPARAM_TIME_FORMAT["_24HR"] = 0] = "_24HR";
    PSP_SYSTEMPARAM_TIME_FORMAT[PSP_SYSTEMPARAM_TIME_FORMAT["_12HR"] = 1] = "_12HR";
})(PSP_SYSTEMPARAM_TIME_FORMAT || (PSP_SYSTEMPARAM_TIME_FORMAT = {}));
var PSP_SYSTEMPARAM_DAYLIGHTSAVINGS;
(function (PSP_SYSTEMPARAM_DAYLIGHTSAVINGS) {
    PSP_SYSTEMPARAM_DAYLIGHTSAVINGS[PSP_SYSTEMPARAM_DAYLIGHTSAVINGS["STD"] = 0] = "STD";
    PSP_SYSTEMPARAM_DAYLIGHTSAVINGS[PSP_SYSTEMPARAM_DAYLIGHTSAVINGS["SAVING"] = 1] = "SAVING";
})(PSP_SYSTEMPARAM_DAYLIGHTSAVINGS || (PSP_SYSTEMPARAM_DAYLIGHTSAVINGS = {}));
var PSP_SYSTEMPARAM_LANGUAGE;
(function (PSP_SYSTEMPARAM_LANGUAGE) {
    PSP_SYSTEMPARAM_LANGUAGE[PSP_SYSTEMPARAM_LANGUAGE["JAPANESE"] = 0] = "JAPANESE";
    PSP_SYSTEMPARAM_LANGUAGE[PSP_SYSTEMPARAM_LANGUAGE["ENGLISH"] = 1] = "ENGLISH";
    PSP_SYSTEMPARAM_LANGUAGE[PSP_SYSTEMPARAM_LANGUAGE["FRENCH"] = 2] = "FRENCH";
    PSP_SYSTEMPARAM_LANGUAGE[PSP_SYSTEMPARAM_LANGUAGE["SPANISH"] = 3] = "SPANISH";
    PSP_SYSTEMPARAM_LANGUAGE[PSP_SYSTEMPARAM_LANGUAGE["GERMAN"] = 4] = "GERMAN";
    PSP_SYSTEMPARAM_LANGUAGE[PSP_SYSTEMPARAM_LANGUAGE["ITALIAN"] = 5] = "ITALIAN";
    PSP_SYSTEMPARAM_LANGUAGE[PSP_SYSTEMPARAM_LANGUAGE["DUTCH"] = 6] = "DUTCH";
    PSP_SYSTEMPARAM_LANGUAGE[PSP_SYSTEMPARAM_LANGUAGE["PORTUGUESE"] = 7] = "PORTUGUESE";
    PSP_SYSTEMPARAM_LANGUAGE[PSP_SYSTEMPARAM_LANGUAGE["RUSSIAN"] = 8] = "RUSSIAN";
    PSP_SYSTEMPARAM_LANGUAGE[PSP_SYSTEMPARAM_LANGUAGE["KOREAN"] = 9] = "KOREAN";
    PSP_SYSTEMPARAM_LANGUAGE[PSP_SYSTEMPARAM_LANGUAGE["CHINESE_TRADITIONAL"] = 10] = "CHINESE_TRADITIONAL";
    PSP_SYSTEMPARAM_LANGUAGE[PSP_SYSTEMPARAM_LANGUAGE["CHINESE_SIMPLIFIED"] = 11] = "CHINESE_SIMPLIFIED";
})(PSP_SYSTEMPARAM_LANGUAGE || (PSP_SYSTEMPARAM_LANGUAGE = {}));
var PSP_SYSTEMPARAM_BUTTON_PREFERENCE;
(function (PSP_SYSTEMPARAM_BUTTON_PREFERENCE) {
    PSP_SYSTEMPARAM_BUTTON_PREFERENCE[PSP_SYSTEMPARAM_BUTTON_PREFERENCE["JAP"] = 0] = "JAP";
    PSP_SYSTEMPARAM_BUTTON_PREFERENCE[PSP_SYSTEMPARAM_BUTTON_PREFERENCE["NA"] = 1] = "NA";
})(PSP_SYSTEMPARAM_BUTTON_PREFERENCE || (PSP_SYSTEMPARAM_BUTTON_PREFERENCE = {}));
var PspModule;
(function (PspModule) {
    PspModule[PspModule["PSP_MODULE_NET_COMMON"] = 256] = "PSP_MODULE_NET_COMMON";
    PspModule[PspModule["PSP_MODULE_NET_ADHOC"] = 257] = "PSP_MODULE_NET_ADHOC";
    PspModule[PspModule["PSP_MODULE_NET_INET"] = 258] = "PSP_MODULE_NET_INET";
    PspModule[PspModule["PSP_MODULE_NET_PARSEURI"] = 259] = "PSP_MODULE_NET_PARSEURI";
    PspModule[PspModule["PSP_MODULE_NET_PARSEHTTP"] = 260] = "PSP_MODULE_NET_PARSEHTTP";
    PspModule[PspModule["PSP_MODULE_NET_HTTP"] = 261] = "PSP_MODULE_NET_HTTP";
    PspModule[PspModule["PSP_MODULE_NET_SSL"] = 262] = "PSP_MODULE_NET_SSL";
    PspModule[PspModule["PSP_MODULE_USB_PSPCM"] = 512] = "PSP_MODULE_USB_PSPCM";
    PspModule[PspModule["PSP_MODULE_USB_MIC"] = 513] = "PSP_MODULE_USB_MIC";
    PspModule[PspModule["PSP_MODULE_USB_CAM"] = 514] = "PSP_MODULE_USB_CAM";
    PspModule[PspModule["PSP_MODULE_USB_GPS"] = 515] = "PSP_MODULE_USB_GPS";
    PspModule[PspModule["PSP_MODULE_AV_AVCODEC"] = 768] = "PSP_MODULE_AV_AVCODEC";
    PspModule[PspModule["PSP_MODULE_AV_SASCORE"] = 769] = "PSP_MODULE_AV_SASCORE";
    PspModule[PspModule["PSP_MODULE_AV_ATRAC3PLUS"] = 770] = "PSP_MODULE_AV_ATRAC3PLUS";
    PspModule[PspModule["PSP_MODULE_AV_MPEGBASE"] = 771] = "PSP_MODULE_AV_MPEGBASE";
    PspModule[PspModule["PSP_MODULE_AV_MP3"] = 772] = "PSP_MODULE_AV_MP3";
    PspModule[PspModule["PSP_MODULE_AV_VAUDIO"] = 773] = "PSP_MODULE_AV_VAUDIO";
    PspModule[PspModule["PSP_MODULE_AV_AAC"] = 774] = "PSP_MODULE_AV_AAC";
    PspModule[PspModule["PSP_MODULE_AV_G729"] = 775] = "PSP_MODULE_AV_G729";
    PspModule[PspModule["PSP_MODULE_NP_COMMON"] = 1024] = "PSP_MODULE_NP_COMMON";
    PspModule[PspModule["PSP_MODULE_NP_SERVICE"] = 1025] = "PSP_MODULE_NP_SERVICE";
    PspModule[PspModule["PSP_MODULE_NP_MATCHING2"] = 1026] = "PSP_MODULE_NP_MATCHING2";
    PspModule[PspModule["PSP_MODULE_NP_DRM"] = 1280] = "PSP_MODULE_NP_DRM";
    PspModule[PspModule["PSP_MODULE_IRDA"] = 1536] = "PSP_MODULE_IRDA";
})(PspModule || (PspModule = {}));
var PspUtilityDialogCommon = (function () {
    function PspUtilityDialogCommon() {
        this.size = 0;
        this.language = PspLanguages.SPANISH;
        this.buttonSwap = 0;
        this.graphicsThread = 0;
        this.accessThread = 0;
        this.fontThread = 0;
        this.soundThread = 0;
        this.result = SceKernelErrors.ERROR_OK;
        this.reserved = [0, 0, 0, 0];
    }
    PspUtilityDialogCommon.struct = StructClass.create(PspUtilityDialogCommon, [
        { size: Int32 },
        { language: Int32 },
        { buttonSwap: Int32 },
        { graphicsThread: Int32 },
        { accessThread: Int32 },
        { fontThread: Int32 },
        { soundThread: Int32 },
        { result: Int32 },
        { reserved: StructArray(Int32, 4) },
    ]);
    return PspUtilityDialogCommon;
})();
var PspUtilitySavedataMode;
(function (PspUtilitySavedataMode) {
    PspUtilitySavedataMode[PspUtilitySavedataMode["Autoload"] = 0] = "Autoload";
    PspUtilitySavedataMode[PspUtilitySavedataMode["Autosave"] = 1] = "Autosave";
    PspUtilitySavedataMode[PspUtilitySavedataMode["Load"] = 2] = "Load";
    PspUtilitySavedataMode[PspUtilitySavedataMode["Save"] = 3] = "Save";
    PspUtilitySavedataMode[PspUtilitySavedataMode["ListLoad"] = 4] = "ListLoad";
    PspUtilitySavedataMode[PspUtilitySavedataMode["ListSave"] = 5] = "ListSave";
    PspUtilitySavedataMode[PspUtilitySavedataMode["ListDelete"] = 6] = "ListDelete";
    PspUtilitySavedataMode[PspUtilitySavedataMode["Delete"] = 7] = "Delete";
    PspUtilitySavedataMode[PspUtilitySavedataMode["Sizes"] = 8] = "Sizes";
    PspUtilitySavedataMode[PspUtilitySavedataMode["AutoDelete"] = 9] = "AutoDelete";
    PspUtilitySavedataMode[PspUtilitySavedataMode["SingleDelete"] = 10] = "SingleDelete";
    PspUtilitySavedataMode[PspUtilitySavedataMode["List"] = 11] = "List";
    PspUtilitySavedataMode[PspUtilitySavedataMode["Files"] = 12] = "Files";
    PspUtilitySavedataMode[PspUtilitySavedataMode["MakeDataSecure"] = 13] = "MakeDataSecure";
    PspUtilitySavedataMode[PspUtilitySavedataMode["MakeData"] = 14] = "MakeData";
    PspUtilitySavedataMode[PspUtilitySavedataMode["ReadSecure"] = 15] = "ReadSecure";
    PspUtilitySavedataMode[PspUtilitySavedataMode["Read"] = 16] = "Read";
    PspUtilitySavedataMode[PspUtilitySavedataMode["WriteSecure"] = 17] = "WriteSecure";
    PspUtilitySavedataMode[PspUtilitySavedataMode["Write"] = 18] = "Write";
    PspUtilitySavedataMode[PspUtilitySavedataMode["EraseSecure"] = 19] = "EraseSecure";
    PspUtilitySavedataMode[PspUtilitySavedataMode["Erase"] = 20] = "Erase";
    PspUtilitySavedataMode[PspUtilitySavedataMode["DeleteData"] = 21] = "DeleteData";
    PspUtilitySavedataMode[PspUtilitySavedataMode["GetSize"] = 22] = "GetSize";
})(PspUtilitySavedataMode || (PspUtilitySavedataMode = {}));
var PspUtilitySavedataFocus;
(function (PspUtilitySavedataFocus) {
    PspUtilitySavedataFocus[PspUtilitySavedataFocus["PSP_UTILITY_SAVEDATA_FOCUS_UNKNOWN"] = 0] = "PSP_UTILITY_SAVEDATA_FOCUS_UNKNOWN";
    PspUtilitySavedataFocus[PspUtilitySavedataFocus["PSP_UTILITY_SAVEDATA_FOCUS_FIRSTLIST"] = 1] = "PSP_UTILITY_SAVEDATA_FOCUS_FIRSTLIST";
    PspUtilitySavedataFocus[PspUtilitySavedataFocus["PSP_UTILITY_SAVEDATA_FOCUS_LASTLIST"] = 2] = "PSP_UTILITY_SAVEDATA_FOCUS_LASTLIST";
    PspUtilitySavedataFocus[PspUtilitySavedataFocus["PSP_UTILITY_SAVEDATA_FOCUS_LATEST"] = 3] = "PSP_UTILITY_SAVEDATA_FOCUS_LATEST";
    PspUtilitySavedataFocus[PspUtilitySavedataFocus["PSP_UTILITY_SAVEDATA_FOCUS_OLDEST"] = 4] = "PSP_UTILITY_SAVEDATA_FOCUS_OLDEST";
    PspUtilitySavedataFocus[PspUtilitySavedataFocus["PSP_UTILITY_SAVEDATA_FOCUS_UNKNOWN2"] = 5] = "PSP_UTILITY_SAVEDATA_FOCUS_UNKNOWN2";
    PspUtilitySavedataFocus[PspUtilitySavedataFocus["PSP_UTILITY_SAVEDATA_FOCUS_UNKNOWN3"] = 6] = "PSP_UTILITY_SAVEDATA_FOCUS_UNKNOWN3";
    PspUtilitySavedataFocus[PspUtilitySavedataFocus["PSP_UTILITY_SAVEDATA_FOCUS_FIRSTEMPTY"] = 7] = "PSP_UTILITY_SAVEDATA_FOCUS_FIRSTEMPTY";
    PspUtilitySavedataFocus[PspUtilitySavedataFocus["PSP_UTILITY_SAVEDATA_FOCUS_LASTEMPTY"] = 8] = "PSP_UTILITY_SAVEDATA_FOCUS_LASTEMPTY";
})(PspUtilitySavedataFocus || (PspUtilitySavedataFocus = {}));
var PspUtilitySavedataFileData = (function () {
    function PspUtilitySavedataFileData() {
        this.bufferPointer = 0;
        this.bufferSize = 0;
        this.size = 0;
        this.unknown = 0;
    }
    Object.defineProperty(PspUtilitySavedataFileData.prototype, "used", {
        get: function () {
            if (this.bufferPointer == 0)
                return false;
            if (this.size == 0)
                return false;
            return true;
        },
        enumerable: true,
        configurable: true
    });
    PspUtilitySavedataFileData.struct = StructClass.create(PspUtilitySavedataFileData, [
        { bufferPointer: Int32 },
        { bufferSize: Int32 },
        { size: Int32 },
        { unknown: Int32 },
    ]);
    return PspUtilitySavedataFileData;
})();
var PspUtilitySavedataSFOParam = (function () {
    function PspUtilitySavedataSFOParam() {
        this.title = '';
        this.savedataTitle = '';
        this.detail = '';
        this.parentalLevel = 0;
        this.unknown = [0, 0, 0];
    }
    PspUtilitySavedataSFOParam.struct = StructClass.create(PspUtilitySavedataSFOParam, [
        { title: Stringz(0x80) },
        { savedataTitle: Stringz(0x80) },
        { detail: Stringz(0x400) },
        { parentalLevel: UInt8 },
        { unknown: StructArray(UInt8, 3) },
    ]);
    return PspUtilitySavedataSFOParam;
})();
var SceUtilitySavedataParam = (function () {
    function SceUtilitySavedataParam() {
        this.base = new PspUtilityDialogCommon();
        this.mode = 0;
        this.unknown1 = 0;
        this.overwrite = 0;
        this.gameName = '';
        this.saveName = '';
        this.saveNameListPointer = 0;
        this.fileName = '';
        this.dataBufPointer = 0;
        this.dataBufSize = 0;
        this.dataSize = 0;
        this.sfoParam = new PspUtilitySavedataSFOParam();
        this.icon0FileData = new PspUtilitySavedataFileData();
        this.icon1FileData = new PspUtilitySavedataFileData();
        this.pic1FileData = new PspUtilitySavedataFileData();
        this.snd0FileData = new PspUtilitySavedataFileData();
        this.newDataPointer = 0;
        this.focus = PspUtilitySavedataFocus.PSP_UTILITY_SAVEDATA_FOCUS_UNKNOWN;
        this.abortStatus = 0;
        this.msFreeAddr = 0;
        this.msDataAddr = 0;
        this.utilityDataAddr = 0;
        this.key = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        this.secureVersion = 0;
        this.multiStatus = 0;
        this.idListAddr = 0;
        this.fileListAddr = 0;
        this.sizeAddr = 0;
        this.unknown3 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    }
    SceUtilitySavedataParam.struct = StructClass.create(SceUtilitySavedataParam, [
        { base: PspUtilityDialogCommon.struct },
        { mode: Int32 },
        { unknown1: Int32 },
        { overwrite: Int32 },
        { gameName: Stringz(16) },
        { saveName: Stringz(20) },
        { saveNameListPointer: UInt32 },
        { fileName: Stringz(16) },
        { dataBufPointer: UInt32 },
        { dataBufSize: UInt32 },
        { dataSize: UInt32 },
        { sfoParam: PspUtilitySavedataSFOParam.struct },
        { icon0FileData: PspUtilitySavedataFileData.struct },
        { icon1FileData: PspUtilitySavedataFileData.struct },
        { pic1FileData: PspUtilitySavedataFileData.struct },
        { snd0FileData: PspUtilitySavedataFileData.struct },
        { newDataPointer: UInt32 },
        { focus: UInt32 },
        { abortStatus: UInt32 },
        { msFreeAddr: UInt32 },
        { msDataAddr: UInt32 },
        { utilityDataAddr: UInt32 },
        { key: StructArray(UInt8, 16) },
        { secureVersion: UInt32 },
        { multiStatus: UInt32 },
        { idListAddr: UInt32 },
        { fileListAddr: UInt32 },
        { sizeAddr: UInt32 },
        { unknown3: StructArray(UInt8, 20 - 5) },
    ]);
    return SceUtilitySavedataParam;
})();
var SizeFreeInfo = (function () {
    function SizeFreeInfo() {
    }
    SizeFreeInfo.struct = StructClass.create(SizeFreeInfo, [
        { sectorSize: UInt32 },
        { freeSectors: UInt32 },
        { freeKb: UInt32 },
        { freeKbString: Stringz(8) },
    ]);
    return SizeFreeInfo;
})();
var SizeUsedInfo = (function () {
    function SizeUsedInfo() {
    }
    SizeUsedInfo.struct = StructClass.create(SizeUsedInfo, [
        { gameName: Stringz(16) },
        { saveName: Stringz(24) },
        { usedSectors: UInt32 },
        { usedKb: UInt32 },
        { usedKbString: Stringz(8) },
        { usedKb32: UInt32 },
        { usedKb32String: Stringz(8) },
    ]);
    return SizeUsedInfo;
})();
var SizeRequiredSpaceInfo = (function () {
    function SizeRequiredSpaceInfo() {
    }
    SizeRequiredSpaceInfo.struct = StructClass.create(SizeRequiredSpaceInfo, [
        { requiredSpaceSectors: UInt32 },
        { requiredSpaceKb: UInt32 },
        { requiredSpaceString: Stringz(8) },
        { requiredSpace32KB: UInt32 },
        { requiredSpace32KBString: Stringz(8) },
    ]);
    return SizeRequiredSpaceInfo;
})();

},
"src/hle/module/sceVaudio": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var sceVaudio = (function () {
    function sceVaudio(context) {
        this.context = context;
    }
    return sceVaudio;
})();
exports.sceVaudio = sceVaudio;

},
"src/hle/module/sceWlanDrv": function(module, exports, require) {
///<reference path="../../global.d.ts" />
var _utils = require('../utils');
var createNativeFunction = _utils.createNativeFunction;
var sceWlanDrv = (function () {
    function sceWlanDrv(context) {
        this.context = context;
        this.sceWlanGetSwitchState = createNativeFunction(0xD7763699, 150, 'bool', '', this, function () {
            return true;
        });
    }
    return sceWlanDrv;
})();
exports.sceWlanDrv = sceWlanDrv;

},
"src/hle/module/threadman/ThreadManForUser": function(module, exports, require) {
///<reference path="../../../global.d.ts" />
var _utils = require('../../utils');
var _cpu = require('../../../core/cpu');
var createNativeFunction = _utils.createNativeFunction;
var SceKernelErrors = require('../../SceKernelErrors');
var _manager = require('../../manager');
_manager.Thread;
var CpuSpecialAddresses = _cpu.CpuSpecialAddresses;
var ThreadStatus = _manager.ThreadStatus;
var PspThreadAttributes = _manager.PspThreadAttributes;
var OutOfMemoryError = _manager.OutOfMemoryError;
var console = logger.named('module.ThreadManForUser');
var ThreadManForUser = (function () {
    function ThreadManForUser(context) {
        var _this = this;
        this.context = context;
        this.threadUids = new UidCollection(1);
        this.sceKernelCreateThread = createNativeFunction(0x446D8DE6, 150, 'int', 'string/uint/int/int/int/int/Thread', this, function (name, entryPoint, initPriority, stackSize, attributes, optionPtr, currentThread) {
            if (name == null)
                return SceKernelErrors.ERROR_ERROR;
            if (stackSize < 0x200)
                return SceKernelErrors.ERROR_KERNEL_ILLEGAL_STACK_SIZE;
            if (initPriority < 0x08 || initPriority > 0x77)
                return SceKernelErrors.ERROR_KERNEL_ILLEGAL_PRIORITY;
            if (!_this.context.memory.isValidAddress(entryPoint) || entryPoint == 0)
                return SceKernelErrors.ERROR_KERNEL_ILLEGAL_THREAD_ENTRY_ADDR;
            if (name.length > 31)
                name = name.substr(0, 31);
            if (stackSize > 2 * 1024 * 1024)
                return -3;
            if ((attributes & (~PspThreadAttributes.ValidMask)) != 0) {
                return SceKernelErrors.ERROR_KERNEL_ILLEGAL_ATTR;
            }
            attributes |= PspThreadAttributes.User;
            attributes |= PspThreadAttributes.LowFF;
            try {
                stackSize = Math.max(stackSize, 0x200);
                stackSize = MathUtils.nextAligned(stackSize, 0x100);
                var newThread = _this.context.threadManager.create(name, entryPoint, initPriority, stackSize, attributes);
                newThread.id = _this.threadUids.allocate(newThread);
                newThread.status = ThreadStatus.DORMANT;
                newThread.state.GP = currentThread.state.GP;
                console.info(sprintf('sceKernelCreateThread: %d:"%s":priority=%d, currentPriority=%d, entryPC=%08X', newThread.id, newThread.name, newThread.priority, currentThread.priority, entryPoint));
                return newThread.id;
            }
            catch (e) {
                if (e instanceof OutOfMemoryError)
                    return SceKernelErrors.ERROR_KERNEL_NO_MEMORY;
                throw (e);
            }
        });
        this.sceKernelDelayThread = createNativeFunction(0xCEADEB47, 150, 'uint', 'Thread/uint', this, function (thread, delayInMicroseconds) {
            return _this._sceKernelDelayThreadCB(thread, delayInMicroseconds, AcceptCallbacks.NO);
        });
        this.sceKernelDelayThreadCB = createNativeFunction(0x68DA9E36, 150, 'uint', 'Thread/uint', this, function (thread, delayInMicroseconds) {
            return _this._sceKernelDelayThreadCB(thread, delayInMicroseconds, AcceptCallbacks.YES);
        });
        this.sceKernelWaitThreadEndCB = createNativeFunction(0x840E8133, 150, 'uint', 'uint/void*', this, function (threadId, timeoutPtr) {
            if (!_this.hasThreadById(threadId))
                return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
            return _this._sceKernelWaitThreadEndCB(_this.getThreadById(threadId), AcceptCallbacks.YES);
        });
        this.sceKernelWaitThreadEnd = createNativeFunction(0x278C0DF5, 150, 'uint', 'uint/void*', this, function (threadId, timeoutPtr) {
            if (!_this.hasThreadById(threadId))
                return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
            return _this._sceKernelWaitThreadEndCB(_this.getThreadById(threadId), AcceptCallbacks.NO);
        });
        this.sceKernelGetThreadCurrentPriority = createNativeFunction(0x94AA61EE, 150, 'int', 'Thread', this, function (currentThread) { return currentThread.priority; });
        this.sceKernelStartThread = createNativeFunction(0xF475845D, 150, 'uint', 'Thread/int/int/int', this, function (currentThread, threadId, userDataLength, userDataPointer) {
            console.log('threadId: ', threadId);
            if (!_this.hasThreadById(threadId))
                return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
            console.log('2');
            var newThread = _this.getThreadById(threadId);
            newThread.exitStatus = SceKernelErrors.ERROR_KERNEL_THREAD_IS_NOT_DORMANT;
            var newState = newThread.state;
            newState.setRA(CpuSpecialAddresses.EXIT_THREAD);
            var copiedDataAddress = ((newThread.stackPartition.high - 0x100) - ((userDataLength + 0xF) & ~0xF));
            if (userDataPointer != null) {
                newState.memory.copy(userDataPointer, copiedDataAddress, userDataLength);
                newState.gpr[4] = userDataLength;
                newState.gpr[5] = copiedDataAddress;
            }
            newState.SP = copiedDataAddress - 0x40;
            console.log('3');
            console.info(sprintf('sceKernelStartThread: %d:"%s":priority=%d, currentPriority=%d, SP=%08X, GP=%08X, FP=%08X', threadId, newThread.name, newThread.priority, currentThread.priority, newState.SP, newState.GP, newState.FP));
            console.log('4');
            newThread.start();
            return Promise2.resolve(0);
        });
        this.sceKernelChangeThreadPriority = createNativeFunction(0x71BC9871, 150, 'uint', 'Thread/int/int', this, function (currentThread, threadId, priority) {
            if (!_this.hasThreadById(threadId))
                return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
            var thread = _this.getThreadById(threadId);
            thread.priority = priority;
            return Promise2.resolve(0);
        });
        this.sceKernelExitThread = createNativeFunction(0xAA73C935, 150, 'int', 'Thread/int', this, function (currentThread, exitStatus) {
            console.info(sprintf('sceKernelExitThread: %d', exitStatus));
            currentThread.exitStatus = (exitStatus < 0) ? SceKernelErrors.ERROR_KERNEL_ILLEGAL_ARGUMENT : exitStatus;
            currentThread.stop('sceKernelExitThread');
            throw new Error('CpuBreakException');
        });
        this.sceKernelGetThreadExitStatus = createNativeFunction(0x3B183E26, 150, 'int', 'int', this, function (threadId) {
            if (!_this.hasThreadById(threadId))
                return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
            var thread = _this.getThreadById(threadId);
            return thread.exitStatus;
        });
        this.sceKernelDeleteThread = createNativeFunction(0x9FA03CD3, 150, 'int', 'int', this, function (threadId) {
            return _this._sceKernelDeleteThread(threadId);
        });
        this.sceKernelTerminateThread = createNativeFunction(0x616403BA, 150, 'int', 'int', this, function (threadId) {
            console.info(sprintf('sceKernelTerminateThread: %d', threadId));
            return _this._sceKernelTerminateThread(threadId);
        });
        this.sceKernelExitDeleteThread = createNativeFunction(0x809CE29B, 150, 'uint', 'Thread/int', this, function (currentThread, exitStatus) {
            currentThread.exitStatus = exitStatus;
            currentThread.stop('sceKernelExitDeleteThread');
            throw new Error('CpuBreakException');
        });
        this.sceKernelTerminateDeleteThread = createNativeFunction(0x383F7BCC, 150, 'int', 'int', this, function (threadId) {
            _this._sceKernelTerminateThread(threadId);
            _this._sceKernelDeleteThread(threadId);
            return 0;
        });
        this.sceKernelSleepThreadCB = createNativeFunction(0x82826F70, 150, 'uint', 'Thread', this, function (currentThread) {
            return currentThread.wakeupSleepAsync(AcceptCallbacks.YES);
        });
        this.sceKernelSleepThread = createNativeFunction(0x9ACE131E, 150, 'uint', 'Thread', this, function (currentThread) {
            return currentThread.wakeupSleepAsync(AcceptCallbacks.NO);
        });
        this.sceKernelWakeupThread = createNativeFunction(0xD59EAD2F, 150, 'uint', 'int', this, function (threadId) {
            if (!_this.hasThreadById(threadId))
                return Promise2.resolve(SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD);
            var thread = _this.getThreadById(threadId);
            return thread.wakeupWakeupAsync();
        });
        this.sceKernelUSec2SysClock = createNativeFunction(0x110DEC9A, 150, 'uint', 'uint/void*', this, function (microseconds, clockPtr) {
            if (clockPtr != null)
                clockPtr.writeInt64(Integer64.fromUnsignedInt(microseconds));
            return 0;
        });
        this.sceKernelGetSystemTimeLow = createNativeFunction(0x369ED59D, 150, 'uint', '', this, function () {
            return _this._getCurrentMicroseconds();
        });
        this.sceKernelGetSystemTime = createNativeFunction(0xDB738F35, 150, 'uint', 'void*', this, function (timePtr) {
            if (timePtr == null)
                return SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;
            timePtr.writeInt64(Integer64.fromNumber(_this._getCurrentMicroseconds()));
            return 0;
        });
        this.sceKernelGetSystemTimeWide = createNativeFunction(0x82BC5777, 150, 'long', '', this, function () {
            return Integer64.fromNumber(_this._getCurrentMicroseconds());
        }, { tryCatch: false });
        this.sceKernelGetThreadId = createNativeFunction(0x293B45B8, 150, 'int', 'Thread', this, function (currentThread) {
            return currentThread.id;
        });
        this.sceKernelSuspendThread = createNativeFunction(0x9944F31F, 150, 'int', 'int', this, function (threadId) {
            if (!_this.hasThreadById(threadId))
                return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
            _this.getThreadById(threadId).suspend();
            return 0;
        });
        this.sceKernelResumeThread = createNativeFunction(0x75156E8F, 150, 'int', 'int', this, function (threadId) {
            if (!_this.hasThreadById(threadId))
                return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
            _this.getThreadById(threadId).resume();
            return 0;
        });
        this.sceKernelReferThreadStatus = createNativeFunction(0x17C1684E, 150, 'int', 'int/void*', this, function (threadId, sceKernelThreadInfoPtr) {
            if (!_this.hasThreadById(threadId))
                return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
            var thread = _this.getThreadById(threadId);
            var info = new SceKernelThreadInfo();
            info.size = SceKernelThreadInfo.struct.length;
            info.name = thread.name;
            info.attributes = thread.attributes;
            info.status = thread.status;
            info.threadPreemptionCount = thread.preemptionCount;
            info.entryPoint = thread.entryPoint;
            info.stackPointer = thread.stackPartition.high;
            info.stackSize = thread.stackPartition.size;
            info.GP = thread.state.GP;
            info.priorityInit = thread.initialPriority;
            info.priority = thread.priority;
            info.waitType = 0;
            info.waitId = 0;
            info.wakeupCount = 0;
            info.exitStatus = thread.exitStatus;
            info.runClocksLow = 0;
            info.runClocksHigh = 0;
            info.interruptPreemptionCount = 0;
            info.threadPreemptionCount = 0;
            info.releaseCount = 0;
            SceKernelThreadInfo.struct.write(sceKernelThreadInfoPtr, info);
            return 0;
        });
        this.sceKernelChangeCurrentThreadAttr = createNativeFunction(0xEA748E31, 150, 'int', 'uint/uint/uint', this, function (currentThread, removeAttributes, addAttributes) {
            currentThread.attributes &= ~removeAttributes;
            currentThread.attributes |= addAttributes;
            return 0;
        });
        this.sceKernelUSec2SysClockWide = createNativeFunction(0xC8CD158C, 150, 'int', 'uint', this, function (microseconds) {
            return microseconds;
        });
    }
    ThreadManForUser.prototype.hasThreadById = function (id) { return this.threadUids.has(id); };
    ThreadManForUser.prototype.getThreadById = function (id) {
        if (id == 0)
            return this.context.threadManager.current;
        return this.threadUids.get(id);
    };
    ThreadManForUser.prototype._sceKernelDelayThreadCB = function (thread, delayInMicroseconds, acceptCallbacks) {
        return new WaitingThreadInfo('_sceKernelDelayThreadCB', 'microseconds:' + delayInMicroseconds, thread.delayMicrosecondsAsync(delayInMicroseconds, false), acceptCallbacks);
    };
    ThreadManForUser.prototype._sceKernelWaitThreadEndCB = function (thread, acceptCallbacks) {
        return new WaitingThreadInfo('_sceKernelWaitThreadEndCB', thread, thread.waitEndAsync().then(function () { return thread.exitStatus; }), acceptCallbacks);
    };
    ThreadManForUser.prototype._sceKernelTerminateThread = function (threadId) {
        if (!this.hasThreadById(threadId))
            return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
        var newThread = this.getThreadById(threadId);
        newThread.stop('_sceKernelTerminateThread');
        newThread.exitStatus = 0x800201ac;
        return 0;
    };
    ThreadManForUser.prototype._sceKernelDeleteThread = function (threadId) {
        if (!this.hasThreadById(threadId))
            return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_THREAD;
        var newThread = this.getThreadById(threadId);
        newThread.delete();
        this.threadUids.remove(threadId);
        return 0;
    };
    ThreadManForUser.prototype._getCurrentMicroseconds = function () {
        return this.context.rtc.getCurrentUnixMicroseconds();
    };
    return ThreadManForUser;
})();
exports.ThreadManForUser = ThreadManForUser;
var SceKernelThreadInfo = (function () {
    function SceKernelThreadInfo() {
    }
    SceKernelThreadInfo.struct = StructClass.create(SceKernelThreadInfo, [
        { size: Int32 },
        { name: Stringz(32) },
        { attributes: UInt32 },
        { status: UInt32 },
        { entryPoint: UInt32 },
        { stackPointer: UInt32 },
        { stackSize: Int32 },
        { GP: UInt32 },
        { priorityInit: Int32 },
        { priority: Int32 },
        { waitType: UInt32 },
        { waitId: Int32 },
        { wakeupCount: Int32 },
        { exitStatus: Int32 },
        { runClocksLow: Int32 },
        { runClocksHigh: Int32 },
        { interruptPreemptionCount: Int32 },
        { threadPreemptionCount: Int32 },
        { releaseCount: Int32 },
    ]);
    return SceKernelThreadInfo;
})();

},
"src/hle/module/threadman/ThreadManForUser_callbacks": function(module, exports, require) {
///<reference path="../../../global.d.ts" />
var _utils = require('../../utils');
var createNativeFunction = _utils.createNativeFunction;
var _manager = require('../../manager');
_manager.Thread;
var Callback = _manager.Callback;
var ThreadManForUser = (function () {
    function ThreadManForUser(context) {
        var _this = this;
        this.context = context;
        this.sceKernelCreateCallback = createNativeFunction(0xE81CAF8F, 150, 'uint', 'string/int/uint', this, function (name, functionCallbackAddr, argument) {
            return _this.context.callbackManager.register(new Callback(name, functionCallbackAddr, argument));
        });
        this.sceKernelDeleteCallback = createNativeFunction(0xEDBA5844, 150, 'uint', 'int', this, function (callbackId) {
            _this.context.callbackManager.remove(callbackId);
        });
        this.sceKernelCheckCallback = createNativeFunction(0x349D6D6C, 150, 'uint', 'Thread', this, function (thread) {
            return _this.context.callbackManager.executePendingWithinThread(thread) ? 1 : 0;
        });
        this.sceKernelNotifyCallback = createNativeFunction(0xC11BA8C4, 150, 'uint', 'Thread/int/int', this, function (thread, callbackId, argument2) {
            return _this.context.callbackManager.notify(callbackId, argument2);
        });
    }
    return ThreadManForUser;
})();
exports.ThreadManForUser = ThreadManForUser;

},
"src/hle/module/threadman/ThreadManForUser_eventflag": function(module, exports, require) {
///<reference path="../../../global.d.ts" />
var _utils = require('../../utils');
var createNativeFunction = _utils.createNativeFunction;
var SceKernelErrors = require('../../SceKernelErrors');
var ThreadManForUser = (function () {
    function ThreadManForUser(context) {
        var _this = this;
        this.context = context;
        this.eventFlagUids = new UidCollection(1);
        this.sceKernelCreateEventFlag = createNativeFunction(0x55C20A00, 150, 'uint', 'string/int/int/void*', this, function (name, attributes, bitPattern, optionsPtr) {
            if (name === null)
                return SceKernelErrors.ERROR_ERROR;
            if ((attributes & 0x100) != 0 || attributes >= 0x300)
                return SceKernelErrors.ERROR_KERNEL_ILLEGAL_ATTR;
            var eventFlag = new EventFlag();
            eventFlag.name = name;
            eventFlag.attributes = attributes;
            eventFlag.initialPattern = bitPattern;
            eventFlag.currentPattern = bitPattern;
            return _this.eventFlagUids.allocate(eventFlag);
        });
        this.sceKernelSetEventFlag = createNativeFunction(0x1FB15A32, 150, 'uint', 'int/uint', this, function (id, bitPattern) {
            if (!_this.eventFlagUids.has(id))
                return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_EVENT_FLAG;
            _this.eventFlagUids.get(id).setBits(bitPattern);
            return 0;
        });
        this.sceKernelWaitEventFlag = createNativeFunction(0x402FCF22, 150, 'uint', 'int/uint/int/void*/void*', this, function (id, bits, waitType, outBits, timeout) {
            return _this._sceKernelWaitEventFlagCB(id, bits, waitType, outBits, timeout, AcceptCallbacks.NO);
        });
        this.sceKernelWaitEventFlagCB = createNativeFunction(0x328C546A, 150, 'uint', 'int/uint/int/void*/void*', this, function (id, bits, waitType, outBits, timeout) {
            return _this._sceKernelWaitEventFlagCB(id, bits, waitType, outBits, timeout, AcceptCallbacks.YES);
        });
        this.sceKernelPollEventFlag = createNativeFunction(0x30FD48F0, 150, 'uint', 'int/uint/int/void*', this, function (id, bits, waitType, outBits) {
            if (!_this.eventFlagUids.has(id))
                return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_EVENT_FLAG;
            if ((waitType & ~EventFlagWaitTypeSet.MaskValidBits) != 0)
                return SceKernelErrors.ERROR_KERNEL_ILLEGAL_MODE;
            if ((waitType & (EventFlagWaitTypeSet.Clear | EventFlagWaitTypeSet.ClearAll)) == (EventFlagWaitTypeSet.Clear | EventFlagWaitTypeSet.ClearAll)) {
                return SceKernelErrors.ERROR_KERNEL_ILLEGAL_MODE;
            }
            if (bits == 0)
                return SceKernelErrors.ERROR_KERNEL_EVENT_FLAG_ILLEGAL_WAIT_PATTERN;
            if (EventFlag == null)
                return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_EVENT_FLAG;
            var matched = _this.eventFlagUids.get(id).poll(bits, waitType, outBits);
            return matched ? 0 : SceKernelErrors.ERROR_KERNEL_EVENT_FLAG_POLL_FAILED;
        });
        this.sceKernelDeleteEventFlag = createNativeFunction(0xEF9E4C70, 150, 'uint', 'int', this, function (id) {
            if (!_this.eventFlagUids.has(id))
                return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_EVENT_FLAG;
            _this.eventFlagUids.remove(id);
            return 0;
        });
        this.sceKernelClearEventFlag = createNativeFunction(0x812346E4, 150, 'uint', 'int/uint', this, function (id, bitsToClear) {
            if (!_this.eventFlagUids.has(id))
                return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_EVENT_FLAG;
            _this.eventFlagUids.get(id).clearBits(bitsToClear);
            return 0;
        });
        this.sceKernelCancelEventFlag = createNativeFunction(0xCD203292, 150, 'uint', 'int/uint/void*', this, function (id, newPattern, numWaitThreadPtr) {
            if (!_this.eventFlagUids.has(id))
                return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_EVENT_FLAG;
            _this.eventFlagUids.get(id).cancel(newPattern);
            return 0;
        });
        this.sceKernelReferEventFlagStatus = createNativeFunction(0xA66B0120, 150, 'uint', 'int/void*', this, function (id, infoPtr) {
            var size = infoPtr.readUInt32();
            if (size == 0)
                return 0;
            infoPtr.position = 0;
            if (!_this.eventFlagUids.has(id))
                return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_EVENT_FLAG;
            var eventFlag = _this.eventFlagUids.get(id);
            var info = new EventFlagInfo();
            info.size = EventFlagInfo.struct.length;
            info.name = eventFlag.name;
            info.currentPattern = eventFlag.currentPattern;
            info.initialPattern = eventFlag.initialPattern;
            info.attributes = eventFlag.attributes;
            info.numberOfWaitingThreads = eventFlag.waitingThreads.length;
            EventFlagInfo.struct.write(infoPtr, info);
            console.warn('Not implemented ThreadManForUser.sceKernelReferEventFlagStatus');
            return 0;
        });
    }
    ThreadManForUser.prototype._sceKernelWaitEventFlagCB = function (id, bits, waitType, outBits, timeout, acceptCallbacks) {
        if (!this.eventFlagUids.has(id))
            return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_EVENT_FLAG;
        var eventFlag = this.eventFlagUids.get(id);
        if ((waitType & ~(EventFlagWaitTypeSet.MaskValidBits)) != 0)
            return SceKernelErrors.ERROR_KERNEL_ILLEGAL_MODE;
        if (bits == 0)
            return SceKernelErrors.ERROR_KERNEL_EVENT_FLAG_ILLEGAL_WAIT_PATTERN;
        var timedOut = false;
        var previousPattern = eventFlag.currentPattern;
        return new WaitingThreadInfo('_sceKernelWaitEventFlagCB', eventFlag, eventFlag.waitAsync(bits, waitType, outBits, timeout, acceptCallbacks).then(function () {
            if (outBits != null)
                outBits.writeUInt32(previousPattern);
            return 0;
        }), acceptCallbacks);
    };
    return ThreadManForUser;
})();
exports.ThreadManForUser = ThreadManForUser;
var EventFlagWaitingThread = (function () {
    function EventFlagWaitingThread(bitsToMatch, waitType, outBits, eventFlag, wakeUp) {
        this.bitsToMatch = bitsToMatch;
        this.waitType = waitType;
        this.outBits = outBits;
        this.eventFlag = eventFlag;
        this.wakeUp = wakeUp;
    }
    return EventFlagWaitingThread;
})();
var EventFlag = (function () {
    function EventFlag() {
        this.waitingThreads = new SortedSet();
    }
    EventFlag.prototype.waitAsync = function (bits, waitType, outBits, timeout, callbacks) {
        var _this = this;
        return new Promise2(function (resolve, reject) {
            var waitingSemaphoreThread = new EventFlagWaitingThread(bits, waitType, outBits, _this, function () {
                _this.waitingThreads.delete(waitingSemaphoreThread);
                resolve();
                throw new Error('CpuBreakException');
            });
            _this.waitingThreads.add(waitingSemaphoreThread);
        }).then(function () { return 0; });
    };
    EventFlag.prototype.poll = function (bitsToMatch, waitType, outBits) {
        if (outBits != null)
            outBits.writeInt32(this.currentPattern);
        if ((waitType & EventFlagWaitTypeSet.Or)
            ? ((this.currentPattern & bitsToMatch) != 0)
            : ((this.currentPattern & bitsToMatch) == bitsToMatch)) {
            this._doClear(bitsToMatch, waitType);
            return true;
        }
        return false;
    };
    EventFlag.prototype._doClear = function (bitsToMatch, waitType) {
        if (waitType & (EventFlagWaitTypeSet.ClearAll))
            this.clearBits(~0xFFFFFFFF, false);
        if (waitType & (EventFlagWaitTypeSet.Clear))
            this.clearBits(~bitsToMatch, false);
    };
    EventFlag.prototype.cancel = function (newPattern) {
        this.waitingThreads.forEach(function (item) {
            item.wakeUp();
        });
    };
    EventFlag.prototype.clearBits = function (bitsToClear, doUpdateWaitingThreads) {
        if (doUpdateWaitingThreads === void 0) { doUpdateWaitingThreads = true; }
        this.currentPattern &= bitsToClear;
        if (doUpdateWaitingThreads)
            this.updateWaitingThreads();
    };
    EventFlag.prototype.setBits = function (bits, doUpdateWaitingThreads) {
        if (doUpdateWaitingThreads === void 0) { doUpdateWaitingThreads = true; }
        this.currentPattern |= bits;
        if (doUpdateWaitingThreads)
            this.updateWaitingThreads();
    };
    EventFlag.prototype.updateWaitingThreads = function () {
        var _this = this;
        this.waitingThreads.forEach(function (waitingThread) {
            if (_this.poll(waitingThread.bitsToMatch, waitingThread.waitType, waitingThread.outBits)) {
                waitingThread.wakeUp();
            }
        });
    };
    return EventFlag;
})();
var EventFlagInfo = (function () {
    function EventFlagInfo() {
    }
    EventFlagInfo.struct = StructClass.create(EventFlagInfo, [
        { size: Int32 },
        { name: Stringz(32) },
        { attributes: Int32 },
        { initialPattern: UInt32 },
        { currentPattern: UInt32 },
        { numberOfWaitingThreads: Int32 },
    ]);
    return EventFlagInfo;
})();
var EventFlagWaitTypeSet;
(function (EventFlagWaitTypeSet) {
    EventFlagWaitTypeSet[EventFlagWaitTypeSet["And"] = 0] = "And";
    EventFlagWaitTypeSet[EventFlagWaitTypeSet["Or"] = 1] = "Or";
    EventFlagWaitTypeSet[EventFlagWaitTypeSet["ClearAll"] = 16] = "ClearAll";
    EventFlagWaitTypeSet[EventFlagWaitTypeSet["Clear"] = 32] = "Clear";
    EventFlagWaitTypeSet[EventFlagWaitTypeSet["MaskValidBits"] = 49] = "MaskValidBits";
})(EventFlagWaitTypeSet || (EventFlagWaitTypeSet = {}));

},
"src/hle/module/threadman/ThreadManForUser_mutex": function(module, exports, require) {
///<reference path="../../../global.d.ts" />
var _utils = require('../../utils');
var createNativeFunction = _utils.createNativeFunction;
var ThreadManForUser = (function () {
    function ThreadManForUser(context) {
        this.context = context;
        this.sceKernelCreateMutex = createNativeFunction(0xB7D098C6, 150, 'int', 'string/int/int', this, function (name, attribute, options) {
            return -1;
        });
        this.sceKernelLockMutexCB = createNativeFunction(0x5BF4DD27, 150, 'int', 'int/int/void*', this, function (mutexId, count, timeout) {
            return -1;
        });
    }
    return ThreadManForUser;
})();
exports.ThreadManForUser = ThreadManForUser;

},
"src/hle/module/threadman/ThreadManForUser_sema": function(module, exports, require) {
///<reference path="../../../global.d.ts" />
var _utils = require('../../utils');
var createNativeFunction = _utils.createNativeFunction;
var SceKernelErrors = require('../../SceKernelErrors');
var ThreadManForUser = (function () {
    function ThreadManForUser(context) {
        var _this = this;
        this.context = context;
        this.semaporesUid = new UidCollection(1);
        this.sceKernelCreateSema = createNativeFunction(0xD6DA4BA1, 150, 'int', 'string/int/int/int/void*', this, function (name, attribute, initialCount, maxCount, options) {
            var semaphore = new Semaphore(name, attribute, initialCount, maxCount);
            var id = _this.semaporesUid.allocate(semaphore);
            semaphore.id = id;
            console.warn(sprintf('Not implemented ThreadManForUser.sceKernelCreateSema("%s", %d, count=%d, maxCount=%d) -> %d', name, attribute, initialCount, maxCount, id));
            return id;
        });
        this.sceKernelDeleteSema = createNativeFunction(0x28B6489C, 150, 'int', 'int', this, function (id) {
            if (!_this.semaporesUid.has(id))
                return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_SEMAPHORE;
            var semaphore = _this.semaporesUid.get(id);
            semaphore.delete();
            _this.semaporesUid.remove(id);
            return 0;
        });
        this.sceKernelCancelSema = createNativeFunction(0x8FFDF9A2, 150, 'uint', 'uint/uint/void*', this, function (id, count, numWaitingThreadsPtr) {
            if (!_this.semaporesUid.has(id))
                return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_SEMAPHORE;
            var semaphore = _this.semaporesUid.get(id);
            if (numWaitingThreadsPtr)
                numWaitingThreadsPtr.writeInt32(semaphore.numberOfWaitingThreads);
            semaphore.cancel();
            return 0;
        });
        this.sceKernelWaitSemaCB = createNativeFunction(0x6D212BAC, 150, 'int', 'Thread/int/int/void*', this, function (currentThread, id, signal, timeout) {
            return _this._sceKernelWaitSemaCB(currentThread, id, signal, timeout, AcceptCallbacks.YES);
        });
        this.sceKernelWaitSema = createNativeFunction(0x4E3A1105, 150, 'int', 'Thread/int/int/void*', this, function (currentThread, id, signal, timeout) {
            return _this._sceKernelWaitSemaCB(currentThread, id, signal, timeout, AcceptCallbacks.NO);
        });
        this.sceKernelReferSemaStatus = createNativeFunction(0xBC6FEBC5, 150, 'int', 'int/void*', this, function (id, infoStream) {
            if (!_this.semaporesUid.has(id))
                return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_SEMAPHORE;
            var semaphore = _this.semaporesUid.get(id);
            var semaphoreInfo = new SceKernelSemaInfo();
            semaphoreInfo.size = SceKernelSemaInfo.struct.length;
            semaphoreInfo.attributes = semaphore.attributes;
            semaphoreInfo.currentCount = semaphore.currentCount;
            semaphoreInfo.initialCount = semaphore.initialCount;
            semaphoreInfo.maximumCount = semaphore.maximumCount;
            semaphoreInfo.name = semaphore.name;
            semaphoreInfo.numberOfWaitingThreads = semaphore.numberOfWaitingThreads;
            SceKernelSemaInfo.struct.write(infoStream, semaphoreInfo);
            return 0;
        });
        this.sceKernelSignalSema = createNativeFunction(0x3F53E640, 150, 'int', 'Thread/int/int', this, function (currentThread, id, signal) {
            if (!_this.semaporesUid.has(id))
                return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_SEMAPHORE;
            var semaphore = _this.semaporesUid.get(id);
            var previousCount = semaphore.currentCount;
            if (semaphore.currentCount + signal > semaphore.maximumCount)
                return SceKernelErrors.ERROR_KERNEL_SEMA_OVERFLOW;
            var awakeCount = semaphore.incrementCount(signal);
            if (awakeCount > 0) {
                return Promise2.resolve(0);
            }
            else {
                return 0;
            }
        });
        this.sceKernelPollSema = createNativeFunction(0x58B1F937, 150, 'int', 'Thread/int/int', this, function (currentThread, id, signal) {
            var semaphore = _this.semaporesUid.get(id);
            if (signal <= 0)
                return SceKernelErrors.ERROR_KERNEL_ILLEGAL_COUNT;
            if (signal > semaphore.currentCount)
                return SceKernelErrors.ERROR_KERNEL_SEMA_ZERO;
            semaphore.incrementCount(-signal);
            return 0;
        });
    }
    ThreadManForUser.prototype._sceKernelWaitSemaCB = function (currentThread, id, signal, timeout, acceptCallbacks) {
        if (!this.semaporesUid.has(id))
            return SceKernelErrors.ERROR_KERNEL_NOT_FOUND_SEMAPHORE;
        var semaphore = this.semaporesUid.get(id);
        var promise = semaphore.waitAsync(currentThread, signal);
        if (promise) {
            return new WaitingThreadInfo('sceKernelWaitSema', semaphore, promise, acceptCallbacks);
        }
        else {
            return 0;
        }
    };
    return ThreadManForUser;
})();
exports.ThreadManForUser = ThreadManForUser;
var SceKernelSemaInfo = (function () {
    function SceKernelSemaInfo() {
    }
    SceKernelSemaInfo.struct = StructClass.create(SceKernelSemaInfo, [
        { size: Int32 },
        { name: Stringz(32) },
        { attributes: Int32 },
        { initialCount: Int32 },
        { currentCount: Int32 },
        { maximumCount: Int32 },
        { numberOfWaitingThreads: Int32 },
    ]);
    return SceKernelSemaInfo;
})();
var WaitingSemaphoreThread = (function () {
    function WaitingSemaphoreThread(expectedCount, wakeUp) {
        this.expectedCount = expectedCount;
        this.wakeUp = wakeUp;
    }
    return WaitingSemaphoreThread;
})();
var Semaphore = (function () {
    function Semaphore(name, attributes, initialCount, maximumCount) {
        this.name = name;
        this.attributes = attributes;
        this.initialCount = initialCount;
        this.maximumCount = maximumCount;
        this.waitingSemaphoreThreadList = new SortedSet();
        this.currentCount = initialCount;
    }
    Object.defineProperty(Semaphore.prototype, "numberOfWaitingThreads", {
        get: function () { return this.waitingSemaphoreThreadList.length; },
        enumerable: true,
        configurable: true
    });
    Semaphore.prototype.incrementCount = function (count) {
        this.currentCount = Math.min(this.currentCount + count, this.maximumCount);
        return this.updatedCount();
    };
    Semaphore.prototype.cancel = function () {
        this.waitingSemaphoreThreadList.forEach(function (item) {
            item.wakeUp();
        });
    };
    Semaphore.prototype.updatedCount = function () {
        var _this = this;
        var awakeCount = 0;
        this.waitingSemaphoreThreadList.forEach(function (item) {
            if (_this.currentCount >= item.expectedCount) {
                _this.currentCount -= item.expectedCount;
                item.wakeUp();
                awakeCount++;
            }
        });
        return awakeCount;
    };
    Semaphore.prototype.waitAsync = function (thread, expectedCount) {
        var _this = this;
        if (this.currentCount >= expectedCount) {
            this.currentCount -= expectedCount;
            return null;
        }
        else {
            var promise = new Promise2(function (resolve, reject) {
                var waitingSemaphoreThread = new WaitingSemaphoreThread(expectedCount, function () {
                    _this.waitingSemaphoreThreadList.delete(waitingSemaphoreThread);
                    resolve();
                });
                _this.waitingSemaphoreThreadList.add(waitingSemaphoreThread);
            });
            this.updatedCount();
            return promise;
        }
    };
    Semaphore.prototype.delete = function () {
    };
    return Semaphore;
})();
var SemaphoreAttribute;
(function (SemaphoreAttribute) {
    SemaphoreAttribute[SemaphoreAttribute["FirstInFirstOut"] = 0] = "FirstInFirstOut";
    SemaphoreAttribute[SemaphoreAttribute["Priority"] = 256] = "Priority";
})(SemaphoreAttribute || (SemaphoreAttribute = {}));

},
"src/hle/module/threadman/ThreadManForUser_vpl": function(module, exports, require) {
///<reference path="../../../global.d.ts" />
var _utils = require('../../utils');
var createNativeFunction = _utils.createNativeFunction;
var SceKernelErrors = require('../../SceKernelErrors');
var _manager = require('../../manager');
var MemoryAnchor = _manager.MemoryAnchor;
var ThreadManForUser = (function () {
    function ThreadManForUser(context) {
        var _this = this;
        this.context = context;
        this.vplUid = new UidCollection(1);
        this.sceKernelCreateVpl = createNativeFunction(0x56C039B5, 150, 'int', 'string/int/int/int/void*', this, function (name, partitionId, attribute, size, optionsPtr) {
            var partition = _this.context.memoryManager.memoryPartitionsUid[partitionId];
            var allocatedPartition = partition.allocate(size, (attribute & VplAttributeFlags.PSP_VPL_ATTR_ADDR_HIGH) ? MemoryAnchor.High : MemoryAnchor.Low);
            var vpl = new Vpl(name, allocatedPartition);
            return _this.vplUid.allocate(vpl);
        });
        this.sceKernelTryAllocateVpl = createNativeFunction(0xAF36D708, 150, 'int', 'int/int/void*', this, function (vplId, size, addressPtr) {
            var vpl = _this.vplUid.get(vplId);
            try {
                var item = vpl.partition.allocateLow(size);
                console.log('-->', item.low);
                if (addressPtr)
                    addressPtr.writeInt32(item.low);
                return 0;
            }
            catch (e) {
                console.error(e);
                return SceKernelErrors.ERROR_KERNEL_NO_MEMORY;
            }
        });
    }
    return ThreadManForUser;
})();
exports.ThreadManForUser = ThreadManForUser;
var Vpl = (function () {
    function Vpl(name, partition) {
        this.name = name;
        this.partition = partition;
    }
    return Vpl;
})();
var VplAttributeFlags;
(function (VplAttributeFlags) {
    VplAttributeFlags[VplAttributeFlags["PSP_VPL_ATTR_MASK"] = 16895] = "PSP_VPL_ATTR_MASK";
    VplAttributeFlags[VplAttributeFlags["PSP_VPL_ATTR_ADDR_HIGH"] = 16384] = "PSP_VPL_ATTR_ADDR_HIGH";
    VplAttributeFlags[VplAttributeFlags["PSP_VPL_ATTR_EXT"] = 32768] = "PSP_VPL_ATTR_EXT";
})(VplAttributeFlags || (VplAttributeFlags = {}));

},
"src/hle/pspmodules": function(module, exports, require) {
///<reference path="../global.d.ts" />
var ExceptionManagerForKernel = require('./module/ExceptionManagerForKernel');
var InterruptManager = require('./module/InterruptManager');
var KDebugForKernel = require('./module/KDebugForKernel');
var Kernel_Library = require('./module/Kernel_Library');
var LoadCoreForKernel = require('./module/LoadCoreForKernel');
var LoadExecForUser = require('./module/LoadExecForUser');
var ModuleMgrForUser = require('./module/ModuleMgrForUser');
var sceAtrac3plus = require('./module/sceAtrac3plus');
var sceAudio = require('./module/sceAudio');
var sceCtrl = require('./module/sceCtrl');
var sceDisplay = require('./module/sceDisplay');
var sceDmac = require('./module/sceDmac');
var sceGe_user = require('./module/sceGe_user');
var sceHprm = require('./module/sceHprm');
var sceHttp = require('./module/sceHttp');
var sceParseHttp = require('./module/sceParseHttp');
var sceParseUri = require('./module/sceParseUri');
var sceImpose = require('./module/sceImpose');
var sceLibFont = require('./module/sceLibFont');
var sceMp3 = require('./module/sceMp3');
var sceMpeg = require('./module/sceMpeg');
var sceNet = require('./module/sceNet');
var sceNetAdhoc = require('./module/sceNetAdhoc');
var sceNetAdhocctl = require('./module/sceNetAdhocctl');
var sceNetAdhocMatching = require('./module/sceNetAdhocMatching');
var sceNetApctl = require('./module/sceNetApctl');
var sceNetInet = require('./module/sceNetInet');
var sceNetResolver = require('./module/sceNetResolver');
var sceNp = require('./module/sceNp');
var sceNpAuth = require('./module/sceNpAuth');
var sceNpService = require('./module/sceNpService');
var sceOpenPSID = require('./module/sceOpenPSID');
var scePower = require('./module/scePower');
var scePspNpDrm_user = require('./module/scePspNpDrm_user');
var sceReg = require('./module/sceReg');
var sceRtc = require('./module/sceRtc');
var sceSasCore = require('./module/sceSasCore');
var sceSsl = require('./module/sceSsl');
var sceSuspendForUser = require('./module/sceSuspendForUser');
var sceUmdUser = require('./module/sceUmdUser');
var sceUtility = require('./module/sceUtility');
var sceVaudio = require('./module/sceVaudio');
var sceWlanDrv = require('./module/sceWlanDrv');
var StdioForUser = require('./module/StdioForUser');
var SysMemUserForUser = require('./module/SysMemUserForUser');
var UtilsForKernel = require('./module/UtilsForKernel');
var UtilsForUser = require('./module/UtilsForUser');
var IoFileMgrForUser = require('./module/iofilemgr/IoFileMgrForUser');
var ThreadManForUser = require('./module/threadman/ThreadManForUser');
var ThreadManForUser_callbacks = require('./module/threadman/ThreadManForUser_callbacks');
var ThreadManForUser_sema = require('./module/threadman/ThreadManForUser_sema');
var ThreadManForUser_eventflag = require('./module/threadman/ThreadManForUser_eventflag');
var ThreadManForUser_vpl = require('./module/threadman/ThreadManForUser_vpl');
var ThreadManForUser_mutex = require('./module/threadman/ThreadManForUser_mutex');
function _registerModules(manager) {
}
function _registerSyscall(syscallManager, moduleManager, id, moduleName, functionName) {
    syscallManager.registerWithId(id, moduleManager.getByName(moduleName).getByName(functionName));
}
function registerModules(manager) {
    manager.registerModule(ExceptionManagerForKernel);
    manager.registerModule(InterruptManager);
    manager.registerModule(KDebugForKernel);
    manager.registerModule(Kernel_Library);
    manager.registerModule(LoadCoreForKernel);
    manager.registerModule(LoadExecForUser);
    manager.registerModule(ModuleMgrForUser);
    manager.registerModule(sceAtrac3plus);
    manager.registerModule(sceAudio);
    manager.registerModule(sceCtrl);
    manager.registerModule(sceDisplay);
    manager.registerModule(sceDmac);
    manager.registerModule(sceGe_user);
    manager.registerModule(sceHprm);
    manager.registerModule(sceHttp);
    manager.registerModule(sceParseHttp);
    manager.registerModule(sceParseUri);
    manager.registerModule(sceImpose);
    manager.registerModule(sceLibFont);
    manager.registerModule(sceMp3);
    manager.registerModule(sceMpeg);
    manager.registerModule(sceNet);
    manager.registerModule(sceNetAdhoc);
    manager.registerModule(sceNetAdhocctl);
    manager.registerModule(sceNetAdhocMatching);
    manager.registerModule(sceNetApctl);
    manager.registerModule(sceNetInet);
    manager.registerModule(sceNetResolver);
    manager.registerModule(sceNp);
    manager.registerModule(sceNpAuth);
    manager.registerModule(sceNpService);
    manager.registerModule(sceOpenPSID);
    manager.registerModule(scePower);
    manager.registerModule(scePspNpDrm_user);
    manager.registerModule(sceReg);
    manager.registerModule(sceRtc);
    manager.registerModule(sceSasCore);
    manager.registerModule(sceSsl);
    manager.registerModule(sceSuspendForUser);
    manager.registerModule(sceUmdUser);
    manager.registerModule(sceUtility);
    manager.registerModule(sceVaudio);
    manager.registerModule(sceWlanDrv);
    manager.registerModule(StdioForUser);
    manager.registerModule(SysMemUserForUser);
    manager.registerModule(UtilsForKernel);
    manager.registerModule(UtilsForUser);
    manager.registerModule(IoFileMgrForUser);
    manager.registerModule(ThreadManForUser);
    manager.registerModule(ThreadManForUser_callbacks);
    manager.registerModule(ThreadManForUser_sema);
    manager.registerModule(ThreadManForUser_eventflag);
    manager.registerModule(ThreadManForUser_vpl);
    manager.registerModule(ThreadManForUser_mutex);
}
function registerSyscalls(syscallManager, moduleManager) {
    _registerSyscall(syscallManager, moduleManager, 0x206D, "ThreadManForUser", "sceKernelCreateThread");
    _registerSyscall(syscallManager, moduleManager, 0x206F, "ThreadManForUser", "sceKernelStartThread");
    _registerSyscall(syscallManager, moduleManager, 0x2071, "ThreadManForUser", "sceKernelExitDeleteThread");
    _registerSyscall(syscallManager, moduleManager, 0x20BF, "UtilsForUser", "sceKernelUtilsMt19937Init");
    _registerSyscall(syscallManager, moduleManager, 0x20C0, "UtilsForUser", "sceKernelUtilsMt19937UInt");
    _registerSyscall(syscallManager, moduleManager, 0x213A, "sceDisplay", "sceDisplaySetMode");
    _registerSyscall(syscallManager, moduleManager, 0x2147, "sceDisplay", "sceDisplayWaitVblankStart");
    _registerSyscall(syscallManager, moduleManager, 0x213F, "sceDisplay", "sceDisplaySetFrameBuf");
    _registerSyscall(syscallManager, moduleManager, 0x20EB, "LoadExecForUser", "sceKernelExitGame");
    _registerSyscall(syscallManager, moduleManager, 0x2150, "sceCtrl", "sceCtrlPeekBufferPositive");
}
function registerModulesAndSyscalls(syscallManager, moduleManager) {
    registerModules(moduleManager);
    registerSyscalls(syscallManager, moduleManager);
}
exports.registerModulesAndSyscalls = registerModulesAndSyscalls;

},
"src/hle/structs": function(module, exports, require) {
(function (SeekAnchor) {
    SeekAnchor[SeekAnchor["Set"] = 0] = "Set";
    SeekAnchor[SeekAnchor["Cursor"] = 1] = "Cursor";
    SeekAnchor[SeekAnchor["End"] = 2] = "End";
})(exports.SeekAnchor || (exports.SeekAnchor = {}));
var SeekAnchor = exports.SeekAnchor;
(function (SceMode) {
})(exports.SceMode || (exports.SceMode = {}));
var SceMode = exports.SceMode;
(function (IOFileModes) {
    IOFileModes[IOFileModes["FormatMask"] = 56] = "FormatMask";
    IOFileModes[IOFileModes["SymbolicLink"] = 8] = "SymbolicLink";
    IOFileModes[IOFileModes["Directory"] = 16] = "Directory";
    IOFileModes[IOFileModes["File"] = 32] = "File";
    IOFileModes[IOFileModes["CanRead"] = 4] = "CanRead";
    IOFileModes[IOFileModes["CanWrite"] = 2] = "CanWrite";
    IOFileModes[IOFileModes["CanExecute"] = 1] = "CanExecute";
})(exports.IOFileModes || (exports.IOFileModes = {}));
var IOFileModes = exports.IOFileModes;
var ScePspDateTime = (function () {
    function ScePspDateTime() {
        this.year = 0;
        this.month = 0;
        this.day = 0;
        this.hour = 0;
        this.minute = 0;
        this.second = 0;
        this.microseconds = 0;
    }
    ScePspDateTime.fromDate = function (date) {
        if (!date)
            date = new Date();
        var pspdate = new ScePspDateTime();
        pspdate.year = date.getFullYear();
        pspdate.month = date.getMonth();
        pspdate.day = date.getDay();
        pspdate.hour = date.getHours();
        pspdate.minute = date.getMinutes();
        pspdate.second = date.getSeconds();
        pspdate.microseconds = date.getMilliseconds() * 1000;
        return pspdate;
    };
    ScePspDateTime.fromTicks = function (ticks) {
        return ScePspDateTime.fromDate(new Date(ticks.getNumber()));
    };
    ScePspDateTime.prototype.getTotalMicroseconds = function () {
        return Integer64.fromNumber((Date.UTC(this.year + 1970, this.month - 1, this.day, this.hour, this.minute, this.second, this.microseconds / 1000) * 1000));
    };
    ScePspDateTime.struct = StructClass.create(ScePspDateTime, [
        { year: Int16 },
        { month: Int16 },
        { day: Int16 },
        { hour: Int16 },
        { minute: Int16 },
        { second: Int16 },
        { microsecond: Int32 },
    ]);
    return ScePspDateTime;
})();
exports.ScePspDateTime = ScePspDateTime;
var SceIoStat = (function () {
    function SceIoStat() {
        this.mode = 0;
        this.attributes = IOFileModes.File;
        this.size = 0;
        this.timeCreation = new ScePspDateTime();
        this.timeLastAccess = new ScePspDateTime();
        this.timeLastModification = new ScePspDateTime();
        this.deviceDependentData = [0, 0, 0, 0, 0, 0];
    }
    SceIoStat.struct = StructClass.create(SceIoStat, [
        { mode: Int32 },
        { attributes: Int32 },
        { size: Int64 },
        { timeCreation: ScePspDateTime.struct },
        { timeLastAccess: ScePspDateTime.struct },
        { timeLastModification: ScePspDateTime.struct },
        { deviceDependentData: StructArray(Int32, 6) },
    ]);
    return SceIoStat;
})();
exports.SceIoStat = SceIoStat;
var HleIoDirent = (function () {
    function HleIoDirent() {
        this.stat = new SceIoStat();
        this.name = '';
        this.privateData = 0;
        this.dummy = 0;
    }
    HleIoDirent.struct = StructClass.create(HleIoDirent, [
        { stat: SceIoStat.struct },
        { name: Stringz(256) },
        { privateData: Int32 },
        { dummy: Int32 },
    ]);
    return HleIoDirent;
})();
exports.HleIoDirent = HleIoDirent;
(function (PspLanguages) {
    PspLanguages[PspLanguages["JAPANESE"] = 0] = "JAPANESE";
    PspLanguages[PspLanguages["ENGLISH"] = 1] = "ENGLISH";
    PspLanguages[PspLanguages["FRENCH"] = 2] = "FRENCH";
    PspLanguages[PspLanguages["SPANISH"] = 3] = "SPANISH";
    PspLanguages[PspLanguages["GERMAN"] = 4] = "GERMAN";
    PspLanguages[PspLanguages["ITALIAN"] = 5] = "ITALIAN";
    PspLanguages[PspLanguages["DUTCH"] = 6] = "DUTCH";
    PspLanguages[PspLanguages["PORTUGUESE"] = 7] = "PORTUGUESE";
    PspLanguages[PspLanguages["RUSSIAN"] = 8] = "RUSSIAN";
    PspLanguages[PspLanguages["KOREAN"] = 9] = "KOREAN";
    PspLanguages[PspLanguages["TRADITIONAL_CHINESE"] = 10] = "TRADITIONAL_CHINESE";
    PspLanguages[PspLanguages["SIMPLIFIED_CHINESE"] = 11] = "SIMPLIFIED_CHINESE";
})(exports.PspLanguages || (exports.PspLanguages = {}));
var PspLanguages = exports.PspLanguages;
(function (ButtonPreference) {
    ButtonPreference[ButtonPreference["JAP"] = 0] = "JAP";
    ButtonPreference[ButtonPreference["NA"] = 1] = "NA";
})(exports.ButtonPreference || (exports.ButtonPreference = {}));
var ButtonPreference = exports.ButtonPreference;

},
"src/hle/utils": function(module, exports, require) {
var _cpu = require('../core/cpu');
exports.NativeFunction = _cpu.NativeFunction;
exports.createNativeFunction = _cpu.createNativeFunction;

},
"src/hle/vfs": function(module, exports, require) {
var _vfs = require('./vfs/vfs');
_vfs.Vfs;
var _zip = require('./vfs/vfs_zip');
_zip.ZipVfs;
var _iso = require('./vfs/vfs_iso');
_iso.IsoVfs;
var _uri = require('./vfs/vfs_uri');
_uri.UriVfs;
var _ms = require('./vfs/vfs_ms');
_ms.MemoryStickVfs;
var _memory = require('./vfs/vfs_memory');
_memory.MemoryVfs;
var _mountable = require('./vfs/vfs_mountable');
_mountable.MountableVfs;
var _storage = require('./vfs/vfs_storage');
_storage.StorageVfs;
var _emulator = require('./vfs/vfs_emulator');
_emulator.EmulatorVfs;
var _dropbox = require('./vfs/vfs_dropbox');
_dropbox.DropboxVfs;
exports.FileMode = _vfs.FileMode;
exports.FileOpenFlags = _vfs.FileOpenFlags;
exports.Vfs = _vfs.Vfs;
exports.ProxyVfs = _vfs.ProxyVfs;
exports.VfsEntry = _vfs.VfsEntry;
exports.ZipVfs = _zip.ZipVfs;
exports.IsoVfs = _iso.IsoVfs;
exports.UriVfs = _uri.UriVfs;
exports.MemoryVfs = _memory.MemoryVfs;
exports.DropboxVfs = _dropbox.DropboxVfs;
exports.MountableVfs = _mountable.MountableVfs;
exports.StorageVfs = _storage.StorageVfs;
exports.EmulatorVfs = _emulator.EmulatorVfs;
exports.MemoryStickVfs = _ms.MemoryStickVfs;

},
"src/hle/vfs/indexeddb": function(module, exports, require) {
var console = logger.named('indexeddb');
var MyStorageIndexedDb = (function () {
    function MyStorageIndexedDb(db) {
        this.db = db;
    }
    MyStorageIndexedDb.openAsync = function (name) {
        console.info('MyStorageIndexedDb.openAsync("' + name + '")');
        return new Promise2(function (resolve, reject) {
            var request = indexedDB.open(name, 1);
            request.onupgradeneeded = function (e) {
                var db = request.result;
                console.log('upgrade!');
                if (db.objectStoreNames.contains('items'))
                    db.deleteObjectStore('items');
                db.createObjectStore('items', { keyPath: "key" });
            };
            request.onerror = function (event) {
                reject(new Error("Can't open indexedDB"));
            };
            request.onsuccess = function (event) {
                resolve(new MyStorageIndexedDb(request.result));
            };
        });
    };
    MyStorageIndexedDb.prototype.getItemsStore = function () {
        return this.db.transaction(['items'], "readwrite").objectStore('items');
    };
    MyStorageIndexedDb.prototype.putAsync = function (key, value) {
        console.log('putAsync', key, value);
        var store = this.getItemsStore();
        return new Promise2(function (resolve, reject) {
            var request = store.put({ key: key, value: value });
            request.onsuccess = function (e) {
                resolve();
            };
            request.onerror = function (e) {
                reject(e['value']);
            };
        });
    };
    MyStorageIndexedDb.prototype.deleteAsync = function (key) {
        console.log('deleteAsync', key);
        var store = this.getItemsStore();
        return new Promise2(function (resolve, reject) {
            var request = store.delete(key);
            request.onsuccess = function (e) {
                resolve();
            };
            request.onerror = function (e) {
                reject(e['value']);
            };
        });
    };
    MyStorageIndexedDb.prototype.hasAsync = function (key) {
        console.log('hasAsync', key);
        return this.getAsync(key).then(function () { return true; }, function () { return false; });
    };
    MyStorageIndexedDb.prototype.getAsync = function (key) {
        var store = this.getItemsStore();
        return new Promise2(function (resolve, reject) {
            //console.log('rr');
            //var keyRange = IDBKeyRange.only(key);
            //var keyRange = IDBKeyRange.lowerBound(0);
            var request = store.get(key);
            request.onsuccess = function (e) {
                var result = e.target['result'];
                if (!result) {
                    console.log('getAsync', key, undefined);
                    resolve(undefined);
                }
                else {
                    console.log('getAsync', key, result.value);
                    resolve(result.value);
                }
            };
            request.onerror = function (e) {
                console.log('getAsync', key, e);
                reject(e['value']);
            };
        });
    };
    return MyStorageIndexedDb;
})();
var MyStorageFake = (function () {
    function MyStorageFake(name) {
        this.name = name;
        this.items = {};
    }
    MyStorageFake.prototype.putAsync = function (key, value) {
        console.log('putAsync', key, value);
        this.items[key] = value;
        return Promise2.resolve();
    };
    MyStorageFake.prototype.deleteAsync = function (key) {
        console.log('deleteAsync', key);
        delete this.items[key];
        return Promise2.resolve();
    };
    MyStorageFake.prototype.hasAsync = function (key) {
        var value = this.items[key] !== undefined;
        console.log('hasAsync', key, value);
        return Promise2.resolve(value);
    };
    MyStorageFake.prototype.getAsync = function (key) {
        var result = this.items[key];
        console.log('getAsync', key, result);
        return Promise2.resolve(result);
    };
    return MyStorageFake;
})();
function openAsync(name, version, stores) {
    if (typeof indexedDB == "undefined") {
        return Promise2.resolve(new MyStorageFake(name));
    }
    else {
        return MyStorageIndexedDb.openAsync(name + '_v2');
    }
}
exports.openAsync = openAsync;

},
"src/hle/vfs/vfs": function(module, exports, require) {
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Vfs = (function () {
    function Vfs() {
    }
    Vfs.prototype.devctlAsync = function (command, input, output) {
        console.error('VfsMustOverride devctlAsync', this);
        throw (new Error("Must override devctlAsync : " + this));
        return null;
    };
    Vfs.prototype.openAsync = function (path, flags, mode) {
        console.error('VfsMustOverride openAsync', this);
        throw (new Error("Must override openAsync : " + this));
        return null;
    };
    Vfs.prototype.readAllAsync = function (path) {
        return this.openAsync(path, FileOpenFlags.Read, parseInt('0777', 8)).then(function (entry) { return entry.readAllAsync(); });
    };
    Vfs.prototype.writeAllAsync = function (path, data) {
        return this.openAsync(path, FileOpenFlags.Create | FileOpenFlags.Truncate | FileOpenFlags.Write, parseInt('0777', 8)).then(function (entry) { return entry.writeAllAsync(data); });
    };
    Vfs.prototype.openDirectoryAsync = function (path) {
        return this.openAsync(path, FileOpenFlags.Read, parseInt('0777', 8));
    };
    Vfs.prototype.getStatAsync = function (path) {
        return this.openAsync(path, FileOpenFlags.Read, parseInt('0777', 8)).then(function (entry) { return entry.stat(); });
    };
    Vfs.prototype.existsAsync = function (path) {
        return this.getStatAsync(path).then(function () { return true; }).catch(function () { return false; });
    };
    return Vfs;
})();
exports.Vfs = Vfs;
var ProxyVfs = (function (_super) {
    __extends(ProxyVfs, _super);
    function ProxyVfs(parentVfsList) {
        _super.call(this);
        this.parentVfsList = parentVfsList;
    }
    ProxyVfs.prototype._callChainWhenError = function (callback) {
        var promise = Promise2.reject(new Error());
        this.parentVfsList.forEach(function (parentVfs) {
            promise = promise.catch(function (e) {
                return callback(parentVfs, e);
            });
        });
        return promise;
    };
    ProxyVfs.prototype.devctlAsync = function (command, input, output) {
        return this._callChainWhenError(function (vfs, e) {
            return vfs.devctlAsync(command, input, output);
        });
    };
    ProxyVfs.prototype.openAsync = function (path, flags, mode) {
        return this._callChainWhenError(function (vfs, e) {
            return vfs.openAsync(path, flags, mode);
        });
    };
    ProxyVfs.prototype.openDirectoryAsync = function (path) {
        return this._callChainWhenError(function (vfs, e) {
            return vfs.openDirectoryAsync(path);
        });
    };
    ProxyVfs.prototype.getStatAsync = function (path) {
        return this._callChainWhenError(function (vfs, e) {
            return vfs.getStatAsync(path);
        });
    };
    return ProxyVfs;
})(Vfs);
exports.ProxyVfs = ProxyVfs;
var VfsEntry = (function () {
    function VfsEntry() {
    }
    Object.defineProperty(VfsEntry.prototype, "isDirectory", {
        get: function () {
            return this.stat().isDirectory;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VfsEntry.prototype, "size", {
        get: function () { return this.stat().size; },
        enumerable: true,
        configurable: true
    });
    VfsEntry.prototype.readAllAsync = function () { return this.readChunkAsync(0, this.size); };
    VfsEntry.prototype.writeAllAsync = function (data) { return this.writeChunkAsync(0, data); };
    VfsEntry.prototype.enumerateAsync = function () { throw (new Error("Must override enumerateAsync : " + this)); };
    VfsEntry.prototype.readChunkAsync = function (offset, length) { throw (new Error("Must override readChunkAsync : " + this)); };
    VfsEntry.prototype.writeChunkAsync = function (offset, data) { throw (new Error("Must override writeChunkAsync : " + this)); };
    VfsEntry.prototype.stat = function () { throw (new Error("Must override stat")); };
    VfsEntry.prototype.close = function () { };
    return VfsEntry;
})();
exports.VfsEntry = VfsEntry;
var VfsEntryStream = (function (_super) {
    __extends(VfsEntryStream, _super);
    function VfsEntryStream(asyncStream) {
        _super.call(this);
        this.asyncStream = asyncStream;
    }
    Object.defineProperty(VfsEntryStream.prototype, "size", {
        get: function () { return this.asyncStream.size; },
        enumerable: true,
        configurable: true
    });
    VfsEntryStream.prototype.readChunkAsync = function (offset, length) {
        return this.asyncStream.readChunkAsync(offset, length);
    };
    VfsEntryStream.prototype.close = function () { };
    VfsEntryStream.prototype.stat = function () {
        return {
            name: this.asyncStream.name,
            size: this.asyncStream.size,
            isDirectory: false,
            timeCreation: this.asyncStream.date,
            timeLastAccess: this.asyncStream.date,
            timeLastModification: this.asyncStream.date,
        };
    };
    return VfsEntryStream;
})(VfsEntry);
exports.VfsEntryStream = VfsEntryStream;
(function (FileOpenFlags) {
    FileOpenFlags[FileOpenFlags["Read"] = 1] = "Read";
    FileOpenFlags[FileOpenFlags["Write"] = 2] = "Write";
    FileOpenFlags[FileOpenFlags["ReadWrite"] = 3] = "ReadWrite";
    FileOpenFlags[FileOpenFlags["NoBlock"] = 4] = "NoBlock";
    FileOpenFlags[FileOpenFlags["_InternalDirOpen"] = 8] = "_InternalDirOpen";
    FileOpenFlags[FileOpenFlags["Append"] = 256] = "Append";
    FileOpenFlags[FileOpenFlags["Create"] = 512] = "Create";
    FileOpenFlags[FileOpenFlags["Truncate"] = 1024] = "Truncate";
    FileOpenFlags[FileOpenFlags["Excl"] = 2048] = "Excl";
    FileOpenFlags[FileOpenFlags["Unknown1"] = 16384] = "Unknown1";
    FileOpenFlags[FileOpenFlags["NoWait"] = 32768] = "NoWait";
    FileOpenFlags[FileOpenFlags["Unknown2"] = 983040] = "Unknown2";
    FileOpenFlags[FileOpenFlags["Unknown3"] = 33554432] = "Unknown3";
})(exports.FileOpenFlags || (exports.FileOpenFlags = {}));
var FileOpenFlags = exports.FileOpenFlags;
(function (FileMode) {
})(exports.FileMode || (exports.FileMode = {}));
var FileMode = exports.FileMode;

},
"src/hle/vfs/vfs_dropbox": function(module, exports, require) {
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var _vfs = require('./vfs');
var Vfs = _vfs.Vfs;
var VfsEntry = _vfs.VfsEntry;
var FileOpenFlags = _vfs.FileOpenFlags;
var AsyncClient = (function () {
    function AsyncClient(key) {
        this.key = key;
        this.statCacheValue = {};
        this.statCachePromise = {};
        this.readdirCacheValue = {};
        this.readdirCachePromise = {};
    }
    AsyncClient.prototype.initOnceAsync = function () {
        var _this = this;
        if (!this.initPromise) {
            this.client = new Dropbox.Client({ key: this.key });
            if (this.client.isAuthenticated()) {
                $('#dropbox').html('logged');
            }
            this.client.authDriver(new Dropbox.AuthDriver.Redirect({
                redirectUrl: (document.location.host == '127.0.0.1') ? 'http://127.0.0.1/oauth_receive.html' : "https://" + document.location.host + '/oauth_receive.html'
            }));
            this.initPromise = new Promise2(function (resolve, reject) {
                _this.client.authenticate({ interactive: true }, function (e) {
                    if (e) {
                        _this.initPromise = null;
                        reject(e);
                    }
                    else {
                        resolve();
                    }
                });
            });
        }
        return this.initPromise;
    };
    AsyncClient.prototype.writeFileAsync = function (fullpath, content) {
        var _this = this;
        var directory = getDirectoryPath(fullpath);
        var basename = getBaseName(fullpath);
        if (this.statCacheValue[basename]) {
            this.statCacheValue[basename].size = content.byteLength;
        }
        if (this.readdirCacheValue[directory]) {
            var entriesInDirectory = this.readdirCacheValue[directory];
            if (!entriesInDirectory.contains(basename)) {
                entriesInDirectory.push(basename);
            }
        }
        return this.initOnceAsync().then(function () {
            return new Promise2(function (resolve, reject) {
                _this.client.writeFile(fullpath, content, function (e, data) {
                    if (e) {
                        reject(e);
                    }
                    else {
                        resolve(data);
                    }
                });
            });
        });
    };
    AsyncClient.prototype.mkdirAsync = function (path) {
        var _this = this;
        return this.initOnceAsync().then(function () {
            return new Promise2(function (resolve, reject) {
                _this.client.mkdir(path, function (e, data) {
                    if (e) {
                        reject(e);
                    }
                    else {
                        resolve(data);
                    }
                });
            });
        });
    };
    AsyncClient.prototype.readFileAsync = function (name, offset, length) {
        var _this = this;
        if (offset === void 0) { offset = 0; }
        if (length === void 0) { length = undefined; }
        return this.initOnceAsync().then(function () {
            return new Promise2(function (resolve, reject) {
                _this.client.readFile(name, { arrayBuffer: true, start: offset, length: length }, function (e, data) {
                    if (e) {
                        reject(e);
                    }
                    else {
                        resolve(data);
                    }
                });
            });
        });
    };
    AsyncClient.prototype.statAsync = function (fullpath) {
        var _this = this;
        return this.initOnceAsync().then(function () {
            if (!_this.statCachePromise[fullpath]) {
                _this.statCachePromise[fullpath] = _this.readdirAsync(getDirectoryPath(fullpath)).then(function (files) {
                    var basename = getBaseName(fullpath);
                    if (!files.contains(basename))
                        throw (new Error("folder not contains file"));
                    return new Promise2(function (resolve, reject) {
                        _this.client.stat(fullpath, {}, function (e, data) {
                            if (e) {
                                reject(e);
                            }
                            else {
                                _this.statCacheValue[fullpath] = data;
                                resolve(data);
                            }
                        });
                    });
                });
                return _this.statCachePromise[fullpath];
            }
        });
    };
    AsyncClient.prototype.readdirAsync = function (name) {
        var _this = this;
        return this.initOnceAsync().then(function () {
            if (!_this.readdirCachePromise[name]) {
                _this.readdirCachePromise[name] = new Promise2(function (resolve, reject) {
                    _this.client.readdir(name, {}, function (e, data) {
                        if (e) {
                            reject(e);
                        }
                        else {
                            _this.readdirCacheValue[name] = data;
                            resolve(data);
                        }
                    });
                });
            }
            return _this.readdirCachePromise[name];
        });
    };
    return AsyncClient;
})();
exports.AsyncClient = AsyncClient;
function getDirectoryPath(fullpath) {
    return fullpath.split('/').slice(0, -1).join('/');
}
function getBaseName(fullpath) {
    return fullpath.split('/').pop();
}
function normalizePath(fullpath) {
    var out = [];
    var parts = fullpath.replace(/\\/g, '/').split('/');
    parts.forEach(function (part) {
        switch (part) {
            case '.': break;
            case '..':
                out.pop();
                break;
            default: out.push(part);
        }
    });
    return out.join('/');
}
var client = new AsyncClient('4mdwp62ogo4tna1');
var DropboxVfs = (function (_super) {
    __extends(DropboxVfs, _super);
    function DropboxVfs() {
        _super.call(this);
        this.enabled = true;
    }
    DropboxVfs.tryLoginAsync = function () {
        return client.initOnceAsync();
    };
    DropboxVfs.prototype.openAsync = function (path, flags, mode) {
        path = normalizePath(path);
        if (!this.enabled)
            return Promise2.reject(new Error("Not using dropbox"));
        return DropboxVfsEntry.fromPathAsync(path, flags, mode);
    };
    return DropboxVfs;
})(Vfs);
exports.DropboxVfs = DropboxVfs;
var DropboxVfsEntry = (function (_super) {
    __extends(DropboxVfsEntry, _super);
    function DropboxVfsEntry(path, name, _size, isFile, date) {
        _super.call(this);
        this.path = path;
        this.name = name;
        this._size = _size;
        this.isFile = isFile;
        this.date = date;
        this.writeTimer = -1;
    }
    DropboxVfsEntry.fromPathAsync = function (path, flags, mode) {
        function readedErrorAsync(e) {
            if (flags & FileOpenFlags.Create) {
                var entry = new DropboxVfsEntry(path, path.split('/').pop(), 0, true, new Date());
                return client.writeFileAsync(path, new ArrayBuffer(0)).then(function () {
                    return entry;
                }).catch(function (e) {
                    console.error(e);
                    throw (e);
                });
            }
            else {
                throw (e);
            }
        }
        return client.statAsync(path)
            .then(function (info) {
            if (info.isRemoved) {
                return readedErrorAsync(new Error("file not exists"));
            }
            else {
                return new DropboxVfsEntry(path, info.name, info.size, info.isFile, info.modifiedAt);
            }
        })
            .catch(function (e) {
            return readedErrorAsync(e);
        });
    };
    DropboxVfsEntry.prototype.enumerateAsync = function () {
        throw (new Error("Must implement DropboxVfsEntry.enumerateAsync"));
    };
    DropboxVfsEntry.prototype.readChunkAsync = function (offset, length) {
        //console.log('dropbox: read chunk!', this.path, offset, length);
        var _this = this;
        if (this._size < 128 * 1024 * 1024) {
            if (this.cachedContent)
                return Promise2.resolve(this.cachedContent.slice(offset, offset + length));
            return client.readFileAsync(this.path).then(function (data) {
                _this.cachedContent = data;
                return _this.cachedContent.slice(offset, offset + length);
            });
        }
        else {
            return client.readFileAsync(this.path, offset, offset + length);
        }
    };
    DropboxVfsEntry.prototype.writeChunkAsync = function (offset, dataToWrite) {
        var _this = this;
        return this.readChunkAsync(0, this._size).then(function (base) {
            var newContent = new ArrayBuffer(Math.max(base.byteLength, offset + dataToWrite.byteLength));
            var newContentArray = new Uint8Array(newContent);
            newContentArray.set(new Uint8Array(base), 0);
            newContentArray.set(new Uint8Array(dataToWrite), offset);
            _this._size = newContent.byteLength;
            _this.cachedContent = newContent;
            clearTimeout(_this.writeTimer);
            _this.writeTimer = setTimeout(function () {
                client.writeFileAsync(_this.path, newContent);
            }, 500);
            return dataToWrite.byteLength;
        });
    };
    DropboxVfsEntry.prototype.stat = function () {
        return {
            name: this.name,
            size: this._size,
            isDirectory: !this.isFile,
            timeCreation: this.date,
            timeLastAccess: this.date,
            timeLastModification: this.date,
            dependentData0: 0,
            dependentData1: 1,
        };
    };
    DropboxVfsEntry.prototype.close = function () {
    };
    return DropboxVfsEntry;
})(VfsEntry);
exports.DropboxVfsEntry = DropboxVfsEntry;

},
"src/hle/vfs/vfs_emulator": function(module, exports, require) {
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var _vfs = require('./vfs');
_vfs.Vfs;
var EmulatorVfs = (function (_super) {
    __extends(EmulatorVfs, _super);
    function EmulatorVfs(context) {
        _super.call(this);
        this.context = context;
        this.output = '';
        this.screenshot = null;
    }
    EmulatorVfs.prototype.devctlAsync = function (command, input, output) {
        switch (command) {
            case EmulatorDevclEnum.GetHasDisplay:
                if (output)
                    output.writeInt32(0);
                break;
            case EmulatorDevclEnum.SendOutput:
                var str = input.readString(input.length);
                this.output += str;
                this.context.onStdout.dispatch(str);
                return immediateAsync().then(function (_) { return 0; });
            case EmulatorDevclEnum.IsEmulator:
                return 0;
            case EmulatorDevclEnum.EmitScreenshot:
                this.screenshot = input.toUInt8Array();
                console.warn('emit screenshot!');
                return 0;
            default:
                throw (new Error("Can't handle EmulatorVfs devctlAsync. Command '" + command + "'"));
        }
        return 0;
    };
    return EmulatorVfs;
})(_vfs.Vfs);
exports.EmulatorVfs = EmulatorVfs;
(function (EmulatorDevclEnum) {
    EmulatorDevclEnum[EmulatorDevclEnum["GetHasDisplay"] = 1] = "GetHasDisplay";
    EmulatorDevclEnum[EmulatorDevclEnum["SendOutput"] = 2] = "SendOutput";
    EmulatorDevclEnum[EmulatorDevclEnum["IsEmulator"] = 3] = "IsEmulator";
    EmulatorDevclEnum[EmulatorDevclEnum["SendCtrlData"] = 16] = "SendCtrlData";
    EmulatorDevclEnum[EmulatorDevclEnum["EmitScreenshot"] = 32] = "EmitScreenshot";
})(exports.EmulatorDevclEnum || (exports.EmulatorDevclEnum = {}));
var EmulatorDevclEnum = exports.EmulatorDevclEnum;

},
"src/hle/vfs/vfs_iso": function(module, exports, require) {
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var _vfs = require('./vfs');
var Vfs = _vfs.Vfs;
var VfsEntry = _vfs.VfsEntry;
var IsoVfs = (function (_super) {
    __extends(IsoVfs, _super);
    function IsoVfs(iso) {
        _super.call(this);
        this.iso = iso;
    }
    IsoVfs.prototype.openAsync = function (path, flags, mode) {
        try {
            return Promise2.resolve(new IsoVfsFile(this.iso.get(path)));
        }
        catch (e) {
            return Promise2.reject(e);
        }
    };
    return IsoVfs;
})(Vfs);
exports.IsoVfs = IsoVfs;
var IsoVfsFile = (function (_super) {
    __extends(IsoVfsFile, _super);
    function IsoVfsFile(node) {
        _super.call(this);
        this.node = node;
    }
    Object.defineProperty(IsoVfsFile.prototype, "isDirectory", {
        get: function () { return this.node.isDirectory; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IsoVfsFile.prototype, "size", {
        get: function () { return this.node.size; },
        enumerable: true,
        configurable: true
    });
    IsoVfsFile.prototype.readChunkAsync = function (offset, length) { return this.node.readChunkAsync(offset, length); };
    IsoVfsFile.prototype.close = function () { };
    IsoVfsFile.statNode = function (node) {
        return {
            name: node.name,
            size: node.size,
            isDirectory: node.isDirectory,
            timeCreation: node.date,
            timeLastAccess: node.date,
            timeLastModification: node.date,
            dependentData0: node.extent,
        };
    };
    IsoVfsFile.prototype.stat = function () {
        return IsoVfsFile.statNode(this.node);
    };
    IsoVfsFile.prototype.enumerateAsync = function () {
        return Promise2.resolve(this.node.childs.map(function (node) { return IsoVfsFile.statNode(node); }));
    };
    return IsoVfsFile;
})(VfsEntry);

},
"src/hle/vfs/vfs_memory": function(module, exports, require) {
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var _vfs = require('./vfs');
var Vfs = _vfs.Vfs;
var VfsEntry = _vfs.VfsEntry;
var FileOpenFlags = _vfs.FileOpenFlags;
var MemoryVfs = (function (_super) {
    __extends(MemoryVfs, _super);
    function MemoryVfs() {
        _super.apply(this, arguments);
        this.files = {};
    }
    MemoryVfs.prototype.addFile = function (name, data) {
        this.files[name] = new MemoryVfsEntry(name, data);
    };
    MemoryVfs.prototype.openAsync = function (path, flags, mode) {
        if (flags & FileOpenFlags.Write) {
            if (!this.files[path]) {
                this.addFile(path, new ArrayBuffer(0));
            }
        }
        if (flags & FileOpenFlags.Truncate) {
            this.addFile(path, new ArrayBuffer(0));
        }
        var file = this.files[path];
        if (!file) {
            var error = new Error("MemoryVfs: Can't find '" + path + "'");
            console.error(error);
            console.error(error['stack']);
            return Promise2.reject(error);
        }
        else {
            return Promise2.resolve(file);
        }
    };
    return MemoryVfs;
})(Vfs);
exports.MemoryVfs = MemoryVfs;
var MemoryVfsEntry = (function (_super) {
    __extends(MemoryVfsEntry, _super);
    function MemoryVfsEntry(name, data) {
        _super.call(this);
        this.name = name;
        this.data = data;
    }
    Object.defineProperty(MemoryVfsEntry.prototype, "isDirectory", {
        get: function () { return false; },
        enumerable: true,
        configurable: true
    });
    MemoryVfsEntry.prototype.readChunkAsync = function (offset, length) {
        return Promise2.resolve(this.data.slice(offset, offset + length));
    };
    MemoryVfsEntry.prototype.writeChunkAsync = function (offset, data) {
        var newData = new ArrayBuffer(Math.max(this.data.byteLength, offset + data.byteLength));
        var newDataArray = new Uint8Array(newData);
        newDataArray.set(new Uint8Array(this.data), 0);
        newDataArray.set(new Uint8Array(data), offset);
        this.data = newData;
        return Promise2.resolve(data.byteLength);
    };
    MemoryVfsEntry.prototype.stat = function () {
        return {
            name: this.name,
            size: this.data.byteLength,
            isDirectory: false,
            timeCreation: new Date(),
            timeLastAccess: new Date(),
            timeLastModification: new Date(),
        };
    };
    MemoryVfsEntry.prototype.close = function () { };
    MemoryVfsEntry.prototype.enumerateAsync = function () {
        return Promise2.resolve([]);
    };
    return MemoryVfsEntry;
})(VfsEntry);
exports.MemoryVfsEntry = MemoryVfsEntry;

},
"src/hle/vfs/vfs_mountable": function(module, exports, require) {
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var _vfs = require('./vfs');
var _vfs_memory = require('./vfs_memory');
var MemoryVfsEntry = _vfs_memory.MemoryVfsEntry;
var Vfs = _vfs.Vfs;
var MountableVfs = (function (_super) {
    __extends(MountableVfs, _super);
    function MountableVfs() {
        _super.apply(this, arguments);
        this.mounts = [];
    }
    MountableVfs.prototype.mountVfs = function (path, vfs) {
        this.mounts.unshift(new MountableEntry(this.normalizePath(path), vfs, null));
    };
    MountableVfs.prototype.mountFileData = function (path, data) {
        this.mounts.unshift(new MountableEntry(this.normalizePath(path), null, new MemoryVfsEntry(path, data)));
    };
    MountableVfs.prototype.normalizePath = function (path) {
        return path.replace(/\\/g, '/').replace(/^\/+/, '').replace(/\/+$/, '');
    };
    MountableVfs.prototype.transformPath = function (path) {
        path = this.normalizePath(path);
        for (var n = 0; n < this.mounts.length; n++) {
            var mount = this.mounts[n];
            if (path.startsWith(mount.path)) {
                var part = path.substr(mount.path.length);
                return { mount: mount, part: part };
            }
        }
        console.info(this.mounts);
        throw (new Error("MountableVfs: Can't find file '" + path + "'"));
    };
    MountableVfs.prototype.openAsync = function (path, flags, mode) {
        var info = this.transformPath(path);
        if (info.mount.file) {
            return Promise2.resolve(info.mount.file);
        }
        else {
            return info.mount.vfs.openAsync(info.part, flags, mode);
        }
    };
    MountableVfs.prototype.openDirectoryAsync = function (path) {
        var info = this.transformPath(path);
        if (info.mount.file) {
            return Promise2.resolve(info.mount.file);
        }
        else {
            return info.mount.vfs.openDirectoryAsync(info.part);
        }
    };
    MountableVfs.prototype.getStatAsync = function (path) {
        var info = this.transformPath(path);
        if (info.mount.file) {
            return Promise2.resolve(info.mount.file.stat());
        }
        else {
            return info.mount.vfs.getStatAsync(info.part);
        }
    };
    return MountableVfs;
})(Vfs);
exports.MountableVfs = MountableVfs;
var MountableEntry = (function () {
    function MountableEntry(path, vfs, file) {
        this.path = path;
        this.vfs = vfs;
        this.file = file;
    }
    return MountableEntry;
})();

},
"src/hle/vfs/vfs_ms": function(module, exports, require) {
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var _vfs = require('./vfs');
var _manager = require('../manager');
_manager.CallbackManager;
var SceKernelErrors = require('../SceKernelErrors');
var ProxyVfs = _vfs.ProxyVfs;
var MemoryStickVfs = (function (_super) {
    __extends(MemoryStickVfs, _super);
    function MemoryStickVfs(parentVfsList, callbackManager, memory) {
        _super.call(this, parentVfsList);
        this.callbackManager = callbackManager;
        this.memory = memory;
    }
    MemoryStickVfs.prototype.devctlAsync = function (command, input, output) {
        switch (command) {
            case CommandType.CheckInserted:
                if (output == null || output.length < 4)
                    return SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;
                output.writeInt32(1);
                return 0;
            case CommandType.MScmRegisterMSInsertEjectCallback:
                if (input == null || input.length < 4)
                    return SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;
                var callbackId = input.readInt32();
                this.callbackManager.notify(callbackId, 1);
                return 0;
            case CommandType.MScmUnregisterMSInsertEjectCallback:
                return 0;
            case CommandType.GetMemoryStickCapacity:
                if (input == null || input.length < 4)
                    return SceKernelErrors.ERROR_ERRNO_INVALID_ARGUMENT;
                var structAddress = input.readInt32();
                var structStream = this.memory.getPointerStream(structAddress, SizeInfoStruct.struct.length);
                var sizeInfo = new SizeInfoStruct();
                var memoryStickSectorSize = (32 * 1024);
                var freeSpaceInBytes = 1 * 1024 * 1024 * 1024;
                sizeInfo.sectorSize = 0x200;
                sizeInfo.sectorCount = (memoryStickSectorSize / sizeInfo.sectorSize);
                sizeInfo.maxClusters = (freeSpaceInBytes * 95 / 100) / (sizeInfo.sectorSize * sizeInfo.sectorCount);
                sizeInfo.freeClusters = sizeInfo.maxClusters;
                sizeInfo.maxSectors = sizeInfo.maxClusters;
                SizeInfoStruct.struct.write(structStream, sizeInfo);
                return 0;
            case CommandType.CheckMemoryStickIsInserted:
                output.writeInt32(1);
                return 0;
            case CommandType.CheckMemoryStickStatus:
                output.writeInt32(4);
                return 0;
            default:
                throw (new Error("Invalid MemoryStick command '" + command + "'"));
                break;
        }
        return 0;
    };
    return MemoryStickVfs;
})(ProxyVfs);
exports.MemoryStickVfs = MemoryStickVfs;
(function (CommandType) {
    CommandType[CommandType["CheckInserted"] = 37902371] = "CheckInserted";
    CommandType[CommandType["MScmRegisterMSInsertEjectCallback"] = 37836833] = "MScmRegisterMSInsertEjectCallback";
    CommandType[CommandType["MScmUnregisterMSInsertEjectCallback"] = 37836834] = "MScmUnregisterMSInsertEjectCallback";
    CommandType[CommandType["GetMemoryStickCapacity"] = 37902360] = "GetMemoryStickCapacity";
    CommandType[CommandType["CheckMemoryStickIsInserted"] = 33708038] = "CheckMemoryStickIsInserted";
    CommandType[CommandType["CheckMemoryStickStatus"] = 33708033] = "CheckMemoryStickStatus";
})(exports.CommandType || (exports.CommandType = {}));
var CommandType = exports.CommandType;
var SizeInfoStruct = (function () {
    function SizeInfoStruct() {
    }
    SizeInfoStruct.struct = StructClass.create(SizeInfoStruct, [
        { maxClusters: UInt32 },
        { freeClusters: UInt32 },
        { maxSectors: UInt32 },
        { sectorSize: UInt32 },
        { sectorCount: UInt32 },
    ]);
    return SizeInfoStruct;
})();

},
"src/hle/vfs/vfs_storage": function(module, exports, require) {
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var _vfs = require('./vfs');
var Vfs = _vfs.Vfs;
var VfsEntry = _vfs.VfsEntry;
var FileOpenFlags = _vfs.FileOpenFlags;
var storage = require('./indexeddb');
var console = logger.named('vfs.storage');
var StorageVfs = (function (_super) {
    __extends(StorageVfs, _super);
    function StorageVfs(key) {
        _super.call(this);
        this.key = key;
    }
    StorageVfs.prototype.initializeOnceAsync = function () {
        var _this = this;
        if (!this.openDbPromise) {
            this.openDbPromise = storage.openAsync(this.key, 3, ['files']).then(function (db) {
                _this.db = db;
                return _this;
            });
        }
        return this.openDbPromise;
    };
    StorageVfs.prototype.openAsync = function (path, flags, mode) {
        var _this = this;
        return this.initializeOnceAsync().then(function () {
            return StorageVfsEntry.fromNameAsync(_this.db, path, flags, mode);
        });
    };
    return StorageVfs;
})(Vfs);
exports.StorageVfs = StorageVfs;
var StorageVfsEntry = (function (_super) {
    __extends(StorageVfsEntry, _super);
    function StorageVfsEntry(db, name) {
        _super.call(this);
        this.db = db;
        this.name = name;
    }
    StorageVfsEntry.prototype.initAsync = function (flags, mode) {
        var _this = this;
        return this._getFileAsync().then(function (file) {
            console.info('initAsync', file);
            if (!file.exists) {
                if (!(flags & FileOpenFlags.Create)) {
                    throw (new Error("File '" + file.name + "' doesn't exist"));
                }
            }
            if (flags & FileOpenFlags.Truncate) {
                file.content = new Uint8Array([]);
            }
            _this.file = file;
            return _this;
        });
    };
    StorageVfsEntry.fromNameAsync = function (db, name, flags, mode) {
        return (new StorageVfsEntry(db, name)).initAsync(flags, mode);
    };
    StorageVfsEntry.prototype._getFileAsync = function () {
        var _this = this;
        return this.db.getAsync(this.name).then(function (file) {
            if (!file)
                file = { name: _this.name, content: new ArrayBuffer(0), date: new Date(), exists: false };
            return file;
        });
    };
    StorageVfsEntry.prototype._getAllAsync = function () {
        return this._getFileAsync().then(function (item) { return item.content; });
    };
    StorageVfsEntry.prototype._writeAllAsync = function (data) {
        return this.db.putAsync(this.name, {
            'name': this.name,
            'content': new Uint8Array(data),
            'date': new Date(),
            'exists': true,
        });
    };
    StorageVfsEntry.prototype.enumerateAsync = function () {
        throw (new Error("Must override enumerateAsync : " + this));
    };
    StorageVfsEntry.prototype.readChunkAsync = function (offset, length) {
        return Promise2.resolve(this.file.content.buffer.slice(offset, offset + length));
    };
    StorageVfsEntry.prototype.writeChunkAsync = function (offset, data) {
        var newContent = new ArrayBuffer(Math.max(this.file.content.byteLength, offset + data.byteLength));
        var newContentArray = new Uint8Array(newContent);
        newContentArray.set(new Uint8Array(this.file.content), 0);
        newContentArray.set(new Uint8Array(data), offset);
        this.file.content = newContentArray;
        return this._writeAllAsync(newContent).then(function () { return data.byteLength; });
    };
    StorageVfsEntry.prototype.stat = function () {
        return {
            name: this.file.name,
            size: this.file.content.byteLength,
            isDirectory: false,
            timeCreation: this.file.date,
            timeLastAccess: this.file.date,
            timeLastModification: this.file.date,
            dependentData0: 0,
            dependentData1: 0,
        };
    };
    StorageVfsEntry.prototype.close = function () {
    };
    return StorageVfsEntry;
})(VfsEntry);

},
"src/hle/vfs/vfs_uri": function(module, exports, require) {
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var _vfs = require('./vfs');
var _vfs_memory = require('./vfs_memory');
var MemoryVfsEntry = _vfs_memory.MemoryVfsEntry;
var Vfs = _vfs.Vfs;
var VfsEntryStream = _vfs.VfsEntryStream;
var FileOpenFlags = _vfs.FileOpenFlags;
var UriVfs = (function (_super) {
    __extends(UriVfs, _super);
    function UriVfs(baseUri) {
        _super.call(this);
        this.baseUri = baseUri;
    }
    UriVfs.prototype.getAbsoluteUrl = function (path) {
        return this.baseUri + '/' + path;
    };
    UriVfs.prototype.openAsync = function (path, flags, mode) {
        if (flags & FileOpenFlags.Write) {
            return Promise2.resolve(new MemoryVfsEntry(path, new ArrayBuffer(0)));
        }
        var url = this.getAbsoluteUrl(path);
        return UrlAsyncStream.fromUrlAsync(url).then(function (stream) { return new VfsEntryStream(stream); });
    };
    UriVfs.prototype.openDirectoryAsync = function (path) {
        return Promise2.resolve(new MemoryVfsEntry(path, new ArrayBuffer(0)));
    };
    UriVfs.prototype.getStatAsync = function (path) {
        var url = this.getAbsoluteUrl(path);
        return statUrlAsync(url);
    };
    return UriVfs;
})(Vfs);
exports.UriVfs = UriVfs;
function urlStatToVfsStat(url, info) {
    return {
        name: url,
        size: info.size,
        isDirectory: false,
        timeCreation: info.date,
        timeLastAccess: info.date,
        timeLastModification: info.date,
    };
}
function statUrlAsync(url) {
    return statFileAsync(url).then(function (info) { return urlStatToVfsStat(url, info); });
}

},
"src/hle/vfs/vfs_zip": function(module, exports, require) {
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var _vfs = require('./vfs');
var Vfs = _vfs.Vfs;
var VfsEntry = _vfs.VfsEntry;
var ZipVfs = (function (_super) {
    __extends(ZipVfs, _super);
    function ZipVfs(zip, writeVfs) {
        _super.call(this);
        this.zip = zip;
        this.writeVfs = writeVfs;
    }
    ZipVfs.prototype.openAsync = function (path, flags, mode) {
        try {
            return Promise2.resolve(new ZipVfsFile(this.zip.get(path)));
        }
        catch (e) {
            return Promise2.reject(e);
        }
    };
    return ZipVfs;
})(Vfs);
exports.ZipVfs = ZipVfs;
var ZipVfsFile = (function (_super) {
    __extends(ZipVfsFile, _super);
    function ZipVfsFile(node) {
        _super.call(this);
        this.node = node;
    }
    Object.defineProperty(ZipVfsFile.prototype, "isDirectory", {
        get: function () { return this.node.isDirectory; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ZipVfsFile.prototype, "size", {
        get: function () { return this.node.size; },
        enumerable: true,
        configurable: true
    });
    ZipVfsFile.prototype.readChunkAsync = function (offset, length) { return this.node.readChunkAsync(offset, length); };
    ZipVfsFile.prototype.close = function () { };
    ZipVfsFile.statNode = function (node) {
        return {
            name: node.name,
            size: node.size,
            isDirectory: node.isDirectory,
            timeCreation: node.date,
            timeLastAccess: node.date,
            timeLastModification: node.date,
        };
    };
    ZipVfsFile.prototype.stat = function () {
        return ZipVfsFile.statNode(this.node);
    };
    ZipVfsFile.prototype.enumerateAsync = function () {
        return Promise2.resolve(this.node.getChildList().map(function (node) { return ZipVfsFile.statNode(node); }));
    };
    return ZipVfsFile;
})(VfsEntry);

},
"src/util/IndentStringGenerator": function(module, exports, require) {
///<reference path="../global.d.ts" />
var IndentStringGenerator = (function () {
    function IndentStringGenerator() {
        this.indentation = 0;
        this.output = '';
        this.newLine = true;
    }
    IndentStringGenerator.prototype.indent = function (callback) {
        this.indentation++;
        try {
            callback();
        }
        finally {
            this.indentation--;
        }
    };
    IndentStringGenerator.prototype.write = function (text) {
        var chunks = text.split('\n');
        for (var n = 0; n < chunks.length; n++) {
            if (n != 0)
                this.writeBreakLine();
            this.writeInline(chunks[n]);
        }
    };
    IndentStringGenerator.prototype.writeInline = function (text) {
        if (text == null || text.length == 0)
            return;
        if (this.newLine) {
            for (var n = 0; n < this.indentation; n++)
                this.output += '\t';
            this.newLine = false;
        }
        this.output += text;
    };
    IndentStringGenerator.prototype.writeBreakLine = function () {
        this.output += '\n';
        this.newLine = true;
    };
    return IndentStringGenerator;
})();
module.exports = IndentStringGenerator;

},
"src/util/difflib": function(module, exports, require) {
var __whitespace = { " ": true, "\t": true, "\n": true, "\f": true, "\r": true };
var difflib = {
    defaultJunkFunction: function (c) {
        return __whitespace.hasOwnProperty(c);
    },
    stripLinebreaks: function (str) { return str.replace(/^[\n\r]*|[\n\r]*$/g, ""); },
    stringAsLines: function (str) {
        var lfpos = str.indexOf("\n");
        var crpos = str.indexOf("\r");
        var linebreak = ((lfpos > -1 && crpos > -1) || crpos < 0) ? "\n" : "\r";
        var lines = str.split(linebreak);
        for (var i = 0; i < lines.length; i++) {
            lines[i] = difflib.stripLinebreaks(lines[i]);
        }
        return lines;
    },
    __reduce: function (func, list, initial) {
        if (initial != null) {
            var value = initial;
            var idx = 0;
        }
        else if (list) {
            var value = list[0];
            var idx = 1;
        }
        else {
            return null;
        }
        for (; idx < list.length; idx++) {
            value = func(value, list[idx]);
        }
        return value;
    },
    __ntuplecomp: function (a, b) {
        var mlen = Math.max(a.length, b.length);
        for (var i = 0; i < mlen; i++) {
            if (a[i] < b[i])
                return -1;
            if (a[i] > b[i])
                return 1;
        }
        return a.length == b.length ? 0 : (a.length < b.length ? -1 : 1);
    },
    __calculate_ratio: function (matches, length) {
        return length ? 2.0 * matches / length : 1.0;
    },
    __isindict: function (dict) {
        return function (key) { return dict.hasOwnProperty(key); };
    },
    __dictget: function (dict, key, defaultValue) {
        return dict.hasOwnProperty(key) ? dict[key] : defaultValue;
    },
    SequenceMatcher: function (a, b, isjunk) {
        if (isjunk === void 0) { isjunk = undefined; }
        this.set_seqs = function (a, b) {
            this.set_seq1(a);
            this.set_seq2(b);
        };
        this.set_seq1 = function (a) {
            if (a == this.a)
                return;
            this.a = a;
            this.matching_blocks = this.opcodes = null;
        };
        this.set_seq2 = function (b) {
            if (b == this.b)
                return;
            this.b = b;
            this.matching_blocks = this.opcodes = this.fullbcount = null;
            this.__chain_b();
        };
        this.__chain_b = function () {
            var b = this.b;
            var n = b.length;
            var b2j = this.b2j = {};
            var populardict = {};
            for (var i = 0; i < b.length; i++) {
                var elt = b[i];
                if (b2j.hasOwnProperty(elt)) {
                    var indices = b2j[elt];
                    if (n >= 200 && indices.length * 100 > n) {
                        populardict[elt] = 1;
                        delete b2j[elt];
                    }
                    else {
                        indices.push(i);
                    }
                }
                else {
                    b2j[elt] = [i];
                }
            }
            for (var elt in populardict) {
                if (populardict.hasOwnProperty(elt)) {
                    delete b2j[elt];
                }
            }
            var isjunk = this.isjunk;
            var junkdict = {};
            if (isjunk) {
                for (var elt in populardict) {
                    if (populardict.hasOwnProperty(elt) && isjunk(elt)) {
                        junkdict[elt] = 1;
                        delete populardict[elt];
                    }
                }
                for (var elt in b2j) {
                    if (b2j.hasOwnProperty(elt) && isjunk(elt)) {
                        junkdict[elt] = 1;
                        delete b2j[elt];
                    }
                }
            }
            this.isbjunk = difflib.__isindict(junkdict);
            this.isbpopular = difflib.__isindict(populardict);
        };
        this.find_longest_match = function (alo, ahi, blo, bhi) {
            var a = this.a;
            var b = this.b;
            var b2j = this.b2j;
            var isbjunk = this.isbjunk;
            var besti = alo;
            var bestj = blo;
            var bestsize = 0;
            var j = null;
            var k;
            var j2len = {};
            var nothing = [];
            for (var i = alo; i < ahi; i++) {
                var newj2len = {};
                var jdict = difflib.__dictget(b2j, a[i], nothing);
                for (var jkey in jdict) {
                    if (jdict.hasOwnProperty(jkey)) {
                        j = jdict[jkey];
                        if (j < blo)
                            continue;
                        if (j >= bhi)
                            break;
                        newj2len[j] = k = difflib.__dictget(j2len, j - 1, 0) + 1;
                        if (k > bestsize) {
                            besti = i - k + 1;
                            bestj = j - k + 1;
                            bestsize = k;
                        }
                    }
                }
                j2len = newj2len;
            }
            while (besti > alo && bestj > blo && !isbjunk(b[bestj - 1]) && a[besti - 1] == b[bestj - 1]) {
                besti--;
                bestj--;
                bestsize++;
            }
            while (besti + bestsize < ahi && bestj + bestsize < bhi &&
                !isbjunk(b[bestj + bestsize]) &&
                a[besti + bestsize] == b[bestj + bestsize]) {
                bestsize++;
            }
            while (besti > alo && bestj > blo && isbjunk(b[bestj - 1]) && a[besti - 1] == b[bestj - 1]) {
                besti--;
                bestj--;
                bestsize++;
            }
            while (besti + bestsize < ahi && bestj + bestsize < bhi && isbjunk(b[bestj + bestsize]) &&
                a[besti + bestsize] == b[bestj + bestsize]) {
                bestsize++;
            }
            return [besti, bestj, bestsize];
        };
        this.get_matching_blocks = function () {
            if (this.matching_blocks != null)
                return this.matching_blocks;
            var la = this.a.length;
            var lb = this.b.length;
            var queue = [[0, la, 0, lb]];
            var matching_blocks = [];
            var alo, ahi, blo, bhi, qi, i, j, k, x;
            while (queue.length) {
                qi = queue.pop();
                alo = qi[0];
                ahi = qi[1];
                blo = qi[2];
                bhi = qi[3];
                x = this.find_longest_match(alo, ahi, blo, bhi);
                i = x[0];
                j = x[1];
                k = x[2];
                if (k) {
                    matching_blocks.push(x);
                    if (alo < i && blo < j)
                        queue.push([alo, i, blo, j]);
                    if (i + k < ahi && j + k < bhi)
                        queue.push([i + k, ahi, j + k, bhi]);
                }
            }
            matching_blocks.sort(difflib.__ntuplecomp);
            var i1 = 0, j1 = 0, k1 = 0;
            var block = [];
            var i2, j2, k2;
            var non_adjacent = [];
            for (var idx in matching_blocks) {
                if (matching_blocks.hasOwnProperty(idx)) {
                    block = matching_blocks[idx];
                    i2 = block[0];
                    j2 = block[1];
                    k2 = block[2];
                    if (i1 + k1 == i2 && j1 + k1 == j2) {
                        k1 += k2;
                    }
                    else {
                        if (k1)
                            non_adjacent.push([i1, j1, k1]);
                        i1 = i2;
                        j1 = j2;
                        k1 = k2;
                    }
                }
            }
            if (k1)
                non_adjacent.push([i1, j1, k1]);
            non_adjacent.push([la, lb, 0]);
            this.matching_blocks = non_adjacent;
            return this.matching_blocks;
        };
        this.get_opcodes = function () {
            if (this.opcodes != null)
                return this.opcodes;
            var i = 0;
            var j = 0;
            var answer = [];
            this.opcodes = answer;
            var block, ai, bj, size, tag;
            var blocks = this.get_matching_blocks();
            for (var idx in blocks) {
                if (blocks.hasOwnProperty(idx)) {
                    block = blocks[idx];
                    ai = block[0];
                    bj = block[1];
                    size = block[2];
                    tag = '';
                    if (i < ai && j < bj) {
                        tag = 'replace';
                    }
                    else if (i < ai) {
                        tag = 'delete';
                    }
                    else if (j < bj) {
                        tag = 'insert';
                    }
                    if (tag)
                        answer.push([tag, i, ai, j, bj]);
                    i = ai + size;
                    j = bj + size;
                    if (size)
                        answer.push(['equal', ai, i, bj, j]);
                }
            }
            return answer;
        };
        this.get_grouped_opcodes = function (n) {
            if (!n)
                n = 3;
            var codes = this.get_opcodes();
            if (!codes)
                codes = [["equal", 0, 1, 0, 1]];
            var code, tag, i1, i2, j1, j2;
            if (codes[0][0] == 'equal') {
                code = codes[0];
                tag = code[0];
                i1 = code[1];
                i2 = code[2];
                j1 = code[3];
                j2 = code[4];
                codes[0] = [tag, Math.max(i1, i2 - n), i2, Math.max(j1, j2 - n), j2];
            }
            if (codes[codes.length - 1][0] == 'equal') {
                code = codes[codes.length - 1];
                tag = code[0];
                i1 = code[1];
                i2 = code[2];
                j1 = code[3];
                j2 = code[4];
                codes[codes.length - 1] = [tag, i1, Math.min(i2, i1 + n), j1, Math.min(j2, j1 + n)];
            }
            var nn = n + n;
            var group = [];
            var groups = [];
            for (var idx in codes) {
                if (codes.hasOwnProperty(idx)) {
                    code = codes[idx];
                    tag = code[0];
                    i1 = code[1];
                    i2 = code[2];
                    j1 = code[3];
                    j2 = code[4];
                    if (tag == 'equal' && i2 - i1 > nn) {
                        group.push([tag, i1, Math.min(i2, i1 + n), j1, Math.min(j2, j1 + n)]);
                        groups.push(group);
                        group = [];
                        i1 = Math.max(i1, i2 - n);
                        j1 = Math.max(j1, j2 - n);
                    }
                    group.push([tag, i1, i2, j1, j2]);
                }
            }
            if (group && !(group.length == 1 && group[0][0] == 'equal'))
                groups.push(group);
            return groups;
        };
        this.ratio = function () {
            var matches = difflib.__reduce(function (sum, triple) { return sum + triple[triple.length - 1]; }, this.get_matching_blocks(), 0);
            return difflib.__calculate_ratio(matches, this.a.length + this.b.length);
        };
        this.quick_ratio = function () {
            var fullbcount, elt;
            if (this.fullbcount == null) {
                this.fullbcount = fullbcount = {};
                for (var i = 0; i < this.b.length; i++) {
                    elt = this.b[i];
                    fullbcount[elt] = difflib.__dictget(fullbcount, elt, 0) + 1;
                }
            }
            fullbcount = this.fullbcount;
            var avail = {};
            var availhas = difflib.__isindict(avail);
            var matches = 0;
            var numb = 0;
            for (var i = 0; i < this.a.length; i++) {
                elt = this.a[i];
                if (availhas(elt)) {
                    numb = avail[elt];
                }
                else {
                    numb = difflib.__dictget(fullbcount, elt, 0);
                }
                avail[elt] = numb - 1;
                if (numb > 0)
                    matches++;
            }
            return difflib.__calculate_ratio(matches, this.a.length + this.b.length);
        };
        this.isjunk = isjunk ? isjunk : difflib.defaultJunkFunction;
        this.a = this.b = null;
        this.set_seqs(a, b);
    }
};
module.exports = difflib;

},
"test/_tests": function(module, exports, require) {
///<reference path="./global.d.ts" />
exports.promisetest = require('./promisetest');
var pspTest = require('./format/pspTest');
pspTest.ref();
var csoTest = require('./format/csoTest');
csoTest.ref();
var isoTest = require('./format/isoTest');
isoTest.ref();
var pbpTest = require('./format/pbpTest');
pbpTest.ref();
var psfTest = require('./format/psfTest');
psfTest.ref();
var zipTest = require('./format/zipTest');
zipTest.ref();
var vagTest = require('./format/vagTest');
vagTest.ref();
var memorymanagerTest = require('./hle/memorymanagerTest');
memorymanagerTest.ref();
var vfsTest = require('./hle/vfsTest');
vfsTest.ref();
var utilsTest = require('./util/utilsTest');
utilsTest.ref();
var testasm = require('./testasm');
testasm.ref();
var gpuTest = require('./gpuTest');
gpuTest.ref();
var instructionTest = require('./instructionTest');
instructionTest.ref();
var elfTest = require('./hle/elfTest');
elfTest.ref();
var pspautotests = require('./pspautotests');
pspautotests.ref();

},
"test/format/csoTest": function(module, exports, require) {
///<reference path="../global.d.ts" />
function ref() { }
exports.ref = ref;
var _cso = require('../../src/format/cso');
var _iso = require('../../src/format/iso');
describe('cso', function () {
    var testCsoArrayBuffer;
    before(function () {
        return downloadFileAsync('data/samples/test.cso').then(function (data) {
            testCsoArrayBuffer = data;
        });
    });
    it('should load fine', function () {
        return _cso.Cso.fromStreamAsync(MemoryAsyncStream.fromArrayBuffer(testCsoArrayBuffer)).then(function (cso) {
            return cso.readChunkAsync(0x10 * 0x800 - 10, 0x800).then(function (data) {
                var stream = Stream.fromArrayBuffer(data);
                stream.skip(10);
                var CD0001 = stream.readStringz(6);
                assert.equal(CD0001, '\u0001CD001');
            });
        });
    });
    it('should work with iso', function () {
        return _cso.Cso.fromStreamAsync(MemoryAsyncStream.fromArrayBuffer(testCsoArrayBuffer)).then(function (cso) {
            return _iso.Iso.fromStreamAsync(cso).then(function (iso) {
                assert.equal(JSON.stringify(iso.children.slice(0, 4).map(function (node) { return node.path; })), JSON.stringify(["path", "path/0", "path/1", "path/2"]));
            });
        });
    });
});

},
"test/format/isoTest": function(module, exports, require) {
///<reference path="../global.d.ts" />
function ref() { }
exports.ref = ref;
var _iso = require('../../src/format/iso');
describe('iso', function () {
    var isoData;
    before(function () {
        return downloadFileAsync('data/samples/cube.iso').then(function (data) {
            isoData = new Uint8Array(data);
        });
    });
    it('should load fine', function () {
        var asyncStream = new MemoryAsyncStream(ArrayBufferUtils.fromUInt8Array(isoData));
        return _iso.Iso.fromStreamAsync(asyncStream).then(function (iso) {
            assert.equal(JSON.stringify(iso.children.map(function (item) { return item.path; })), JSON.stringify(["PSP_GAME", "PSP_GAME/PARAM.SFO", "PSP_GAME/SYSDIR", "PSP_GAME/SYSDIR/BOOT.BIN", "PSP_GAME/SYSDIR/EBOOT.BIN"]));
        });
    });
});

},
"test/format/pbpTest": function(module, exports, require) {
///<reference path="../global.d.ts" />
function ref() { }
exports.ref = ref;
var _pbp = require('../../src/format/pbp');
var Pbp = _pbp.Pbp;
describe('pbp', function () {
    var rtctestPbpArrayBuffer;
    before(function () {
        return downloadFileAsync('data/samples/rtctest.pbp').then(function (data) {
            rtctestPbpArrayBuffer = data;
        });
    });
    it('should load fine', function () {
        var pbp = new Pbp();
        pbp.load(Stream.fromArrayBuffer(rtctestPbpArrayBuffer));
        var pspData = pbp.get('psp.data');
        assert.equal(pspData.length, 77550);
    });
});

},
"test/format/psfTest": function(module, exports, require) {
///<reference path="../global.d.ts" />
function ref() { }
exports.ref = ref;
var _psf = require('../../src/format/psf');
var Psf = _psf.Psf;
describe('psf', function () {
    var rtctestPsfArrayBuffer;
    before(function () {
        return downloadFileAsync('data/samples/rtctest.psf').then(function (data) {
            rtctestPsfArrayBuffer = data;
        });
    });
    it('should load fine', function () {
        var psf = new Psf();
        psf.load(Stream.fromArrayBuffer(rtctestPsfArrayBuffer));
        assert.equal(psf.entriesByName['BOOTABLE'], 1);
        assert.equal(psf.entriesByName['CATEGORY'], 'MG');
        assert.equal(psf.entriesByName['DISC_ID'], 'UCJS10041');
        assert.equal(psf.entriesByName['DISC_VERSION'], '1.00');
        assert.equal(psf.entriesByName['PARENTAL_LEVEL'], 1);
        assert.equal(psf.entriesByName['PSP_SYSTEM_VER'], '1.00');
        assert.equal(psf.entriesByName['REGION'], 32768);
        assert.equal(psf.entriesByName['TITLE'], 'rtctest');
    });
});

},
"test/format/pspTest": function(module, exports, require) {
///<reference path="../global.d.ts" />
function ref() { }
exports.ref = ref;
var elf_crypted_prx = require('../../src/hle/elf_crypted_prx');
describe('psp', function () {
    var testInputStream;
    var testExpectedStream;
    before(function () {
        return downloadFileAsync('data/samples/TEST_EBOOT.BIN').then(function (data) {
            testInputStream = Stream.fromArrayBuffer(data);
            return downloadFileAsync('data/samples/TEST_BOOT.BIN').then(function (data) {
                testExpectedStream = Stream.fromArrayBuffer(data);
            });
        });
    });
    it('should load fine', function () {
        var resultByteArray = elf_crypted_prx.decrypt(testInputStream).slice().readAllBytes();
        var expectedByteArray = testExpectedStream.slice().readAllBytes();
        assert.equal(resultByteArray.length, expectedByteArray.length);
        for (var n = 0; n < resultByteArray.length; n++) {
            if (resultByteArray[n] != expectedByteArray[n]) {
                assert.equal(resultByteArray[n], expectedByteArray[n], "failed at " + n + ' with total length ' + resultByteArray.length);
            }
        }
    });
});

},
"test/format/vagTest": function(module, exports, require) {
///<reference path="../global.d.ts" />
function ref() { }
exports.ref = ref;
var _vag = require('../../src/format/vag');
describe('vag', function () {
    var vagData;
    var vagDataExpected;
    before(function () {
        return downloadFileAsync('data/samples/sample.vag').then(function (data) {
            vagData = new Uint8Array(data);
            return downloadFileAsync('data/samples/sample.vag.expected').then(function (data) {
                vagDataExpected = new Uint8Array(data);
            });
        });
    });
    it('should load fine', function () {
        var vag = new _vag.VagSoundSource(Stream.fromUint8Array(vagData), 0);
        var expected = Stream.fromUint8Array(vagDataExpected);
        vag.reset();
        expected.position = 0;
        var resultArray = [];
        var expectedArray = [];
        while (vag.hasMore) {
            var sample = vag.getNextSample();
            var expectedLeft = expected.readInt16();
            var expectedRight = expected.readInt16();
            resultArray.push(sample.left, sample.right);
            expectedArray.push(expectedLeft, expectedRight);
        }
        assert.equal(resultArray.join(','), expectedArray.join(','));
    });
});

},
"test/format/zipTest": function(module, exports, require) {
///<reference path="../global.d.ts" />
function ref() { }
exports.ref = ref;
var _zip = require('../../src/format/zip');
var _vfs = require('../../src/hle/vfs');
describe('zip', function () {
    var arrayBuffer;
    before(function () {
        return downloadFileAsync('data/samples/TrigWars.zip').then(function (data) {
            arrayBuffer = data;
        });
    });
    it('should load fine', function () {
        return _zip.Zip.fromStreamAsync(MemoryAsyncStream.fromArrayBuffer(arrayBuffer)).then(function (zip) {
            assert.equal(27233, zip.get('/EBOOT.PBP').uncompressedSize);
            assert.equal(63548, zip.get('/Data/Sounds/bullet.wav').uncompressedSize);
            assert.equal(63548, zip.get('/DATA/SOUNDS/Bullet.Wav').uncompressedSize);
            return zip.get('/DATA/SOUNDS/Bullet.Wav').readAsync().then(function (data) {
                assert.equal(63548, data.length);
            });
        });
    });
    it('zip vfs should work', function () {
        return _zip.Zip.fromStreamAsync(MemoryAsyncStream.fromArrayBuffer(arrayBuffer)).then(function (zip) {
            var vfs = new _vfs.ZipVfs(zip);
            return vfs.getStatAsync('/Data/Sounds/bullet.wav').then(function (info) {
                assert.equal(false, info.isDirectory);
                assert.equal(63548, info.size);
            });
        });
    });
});

},
"test/gpuTest": function(module, exports, require) {
///<reference path="./global.d.ts" />
function ref() { }
exports.ref = ref;
var _state = require('../src/core/gpu/state');
var _gpu = require('../src/core/gpu');
var VertexReaderFactory = _gpu.VertexReaderFactory;
describe('gpu', function () {
    describe('vertex reading', function () {
        it('should work', function () {
            var vertexState = new _state.VertexState();
            vertexState.size = 10;
            vertexState.texture = _state.NumericEnum.Void;
            vertexState.color = _state.ColorEnum.Void;
            vertexState.normal = _state.NumericEnum.Void;
            vertexState.position = _state.NumericEnum.Short;
            vertexState.weight = _state.NumericEnum.Void;
            vertexState.index = _state.IndexEnum.Void;
            vertexState.weightCount = 1;
            vertexState.morphingVertexCount = 1;
            vertexState.transform2D = true;
            vertexState.textureComponentCount = 2;
            var vertexReader = VertexReaderFactory.get(vertexState);
            var vertexInput = new DataView(new ArrayBuffer(128));
            vertexInput.setInt16(0, 100, true);
            vertexInput.setInt16(2, 200, true);
            vertexInput.setInt16(4, 0, true);
            vertexInput.setInt16(10, 200, true);
            vertexInput.setInt16(12, 300, true);
            vertexInput.setInt16(14, 400, true);
            var vertex1 = new _state.Vertex();
            var vertex2 = new _state.Vertex();
            vertexReader.readCount([vertex1, vertex2], 0, vertexInput, null, 2, vertexState.hasIndex);
            assert.equal(vertex1.px, 100);
            assert.equal(vertex1.py, 200);
            assert.equal(vertex1.pz, 0);
            assert.equal(vertex2.px, 200);
            assert.equal(vertex2.py, 300);
            assert.equal(vertex2.pz, 400);
        });
    });
});

},
"test/hle/elfTest": function(module, exports, require) {
///<reference path="../global.d.ts" />
function ref() { }
exports.ref = ref;
var _memory = require('../../src/core/memory');
var _cpu = require('../../src/core/cpu');
var _display = require('../../src/core/display');
var _manager = require('../../src/hle/manager');
var _elf_psp = require('../../src/hle/elf_psp');
var _context = require('../../src/context');
var pspmodules = require('../../src/hle/pspmodules');
var PspElfLoader = _elf_psp.PspElfLoader;
var ModuleManager = _manager.ModuleManager;
var SyscallManager = _cpu.SyscallManager;
var DummyPspDisplay = _display.DummyPspDisplay;
var EmulatorContext = _context.EmulatorContext;
describe('elf', function () {
    var stream;
    before(function () {
        return downloadFileAsync('data/samples/counter.elf').then(function (data) {
            stream = Stream.fromArrayBuffer(data);
        });
    });
    it('load', function () {
        var memory = _memory.getInstance();
        var memoryManager = new _manager.MemoryManager();
        var display = new DummyPspDisplay();
        var syscallManager = new SyscallManager(context);
        var context = new EmulatorContext();
        var moduleManager = new ModuleManager(context);
        pspmodules.registerModulesAndSyscalls(syscallManager, moduleManager);
        context.init(null, display, null, null, memoryManager, null, null, memory, null, null, null, null, null, null, null);
        var elf = new PspElfLoader(memory, memoryManager, moduleManager, syscallManager);
        elf.load(stream);
    });
});

},
"test/hle/memorymanagerTest": function(module, exports, require) {
///<reference path="../global.d.ts" />
function ref() { }
exports.ref = ref;
var _manager = require('../../src/hle/manager');
var MemoryAnchor = _manager.MemoryAnchor;
var MemoryPartition = _manager.MemoryPartition;
describe("memorymanager", function () {
    it("low", function () {
        var partition = new MemoryPartition("test", 0, 100, false);
        assert.equal(partition.getMaxContiguousFreeMemory(), 100);
        assert.equal(partition.getTotalFreeMemory(), 100);
        var p1 = partition.allocate(25, MemoryAnchor.Low);
        var p2 = partition.allocate(25, MemoryAnchor.Low);
        var p3 = partition.allocate(25, MemoryAnchor.Low);
        assert.equal(partition.getMaxContiguousFreeMemory(), 25);
        assert.equal(partition.getTotalFreeMemory(), 25);
        p2.unallocate();
        assert.equal(partition.getMaxContiguousFreeMemory(), 25);
        assert.equal(partition.getTotalFreeMemory(), 50);
        p3.unallocate();
        assert.equal(partition.getMaxContiguousFreeMemory(), 75);
        assert.equal(partition.getTotalFreeMemory(), 75);
    });
    it("low2", function () {
        var partition = new MemoryPartition("test", 0, 100, false);
        assert.equal(partition.getMaxContiguousFreeMemory(), 100);
        assert.equal(partition.getTotalFreeMemory(), 100);
        var p1 = partition.allocateLow(25);
        var p2 = partition.allocateLow(25);
        var p3 = partition.allocateLow(25);
        assert.equal(partition.getTotalFreeMemory(), 25);
        assert.equal(partition.getMaxContiguousFreeMemory(), 25);
        p3.deallocate();
        assert.equal(partition.getTotalFreeMemory(), 50);
        assert.equal(partition.getMaxContiguousFreeMemory(), 50);
        p1.unallocate();
        assert.equal(partition.getTotalFreeMemory(), 75);
        assert.equal(partition.getMaxContiguousFreeMemory(), 50);
    });
    it("high", function () {
        var partition = new MemoryPartition("test", 0, 100, false);
        assert.equal(partition.getMaxContiguousFreeMemory(), 100);
        assert.equal(partition.getTotalFreeMemory(), 100);
        var p1 = partition.allocateHigh(25);
        var p2 = partition.allocateHigh(25);
        var p3 = partition.allocateHigh(25);
        assert.equal(partition.getTotalFreeMemory(), 25);
        assert.equal(partition.getMaxContiguousFreeMemory(), 25);
        p3.deallocate();
        assert.equal(partition.getTotalFreeMemory(), 50);
        assert.equal(partition.getMaxContiguousFreeMemory(), 50);
        p1.unallocate();
        assert.equal(partition.getTotalFreeMemory(), 75);
        assert.equal(partition.getMaxContiguousFreeMemory(), 50);
    });
});

},
"test/hle/vfsTest": function(module, exports, require) {
///<reference path="../global.d.ts" />
function ref() { }
exports.ref = ref;
var _iso = require('../../src/format/iso');
var _psf = require('../../src/format/psf');
var _vfs = require('../../src/hle/vfs');
_vfs.StorageVfs;
var StorageVfs = _vfs.StorageVfs;
var MemoryVfs = _vfs.MemoryVfs;
var MemoryStickVfs = _vfs.MemoryStickVfs;
var FileOpenFlags = _vfs.FileOpenFlags;
describe('vfs', function () {
    var isoData;
    before(function () {
        return downloadFileAsync('data/samples/cube.iso').then(function (data) {
            isoData = new Uint8Array(data);
        });
    });
    it('iso', function () {
        var asyncStream = new MemoryAsyncStream(ArrayBufferUtils.fromUInt8Array(isoData));
        return _iso.Iso.fromStreamAsync(asyncStream).then(function (iso) {
            var vfs = new _vfs.IsoVfs(iso);
            return vfs.openAsync("PSP_GAME/PARAM.SFO", _vfs.FileOpenFlags.Read, parseInt('777', 8)).then(function (file) {
                return file.readAllAsync().then(function (content) {
                    var psf = _psf.Psf.fromStream(Stream.fromArrayBuffer(content));
                    assert.equal(psf.entriesByName["DISC_ID"], "UCJS10041");
                });
            });
        });
    });
    it('storage', function () {
        var storageVfs = new StorageVfs('test');
        return Promise2.resolve(0)
            .then(function () {
            return storageVfs.writeAllAsync('simple', new Uint8Array([1, 2, 3, 4, 5]).buffer);
        })
            .then(function () {
            return storageVfs.getStatAsync('simple').then(function (stat) {
                assert.equal('simple', stat.name);
                assert.equal(5, stat.size);
            });
        })
            .then(function () {
            return storageVfs.readAllAsync('simple').then(function (data) {
                assert.equal(5, data.byteLength);
            });
        })
            .then(function () {
            return storageVfs.readAllAsync('nonExistant').then(function (data) {
                assert.fail();
            }).catch(function (e) {
                assert.equal("File 'nonExistant' doesn't exist", e.message);
            });
        })
            .then(function () {
            return storageVfs.openAsync('simple2', FileOpenFlags.Create | FileOpenFlags.Write | FileOpenFlags.Truncate, parseIntFormat('0777')).then(function (file) {
                return Promise2.resolve(0)
                    .then(function () {
                    return file.writeChunkAsync(0, new Int8Array([1, 2, 3, 4, 5]).buffer);
                })
                    .then(function () {
                    return file.writeChunkAsync(2, new Int8Array([-3, -4, -5, -6, -7]).buffer);
                })
                    .then(function () {
                    return file.readAllAsync().then(function (data) {
                        var v = new Int8Array(data);
                        assert.equal(7, v.length);
                        assert.equal(1, v[0]);
                        assert.equal(2, v[1]);
                        assert.equal(-3, v[2]);
                        assert.equal(-4, v[3]);
                        assert.equal(-5, v[4]);
                        assert.equal(-6, v[5]);
                        assert.equal(-7, v[6]);
                    });
                });
                ;
            });
        });
    });
    it('memorystick', function () {
        var storageVfs = new StorageVfs('test');
        var msVfs = new MemoryStickVfs([storageVfs], null, null);
        return Promise2.resolve(0)
            .then(function () {
            return msVfs.writeAllAsync('simple', new Uint8Array([1, 2, 3, 4, 5]).buffer);
        })
            .then(function () {
            return msVfs.getStatAsync('simple').then(function (stat) {
                assert.equal('simple', stat.name);
                assert.equal(5, stat.size);
            });
        })
            .then(function () {
            return msVfs.readAllAsync('simple').then(function (data) {
                assert.equal(5, data.byteLength);
            });
        })
            .then(function () {
            return msVfs.readAllAsync('nonExistant').then(function (data) {
                assert['fail']();
            }).catch(function (e) {
                assert.equal("File 'nonExistant' doesn't exist", e.message);
            });
        });
    });
    it('memorystick_combined', function () {
        var vfs1 = new MemoryVfs();
        var vfs2 = new MemoryVfs();
        var msVfs = new MemoryStickVfs([vfs1, vfs2], null, null);
        return Promise2.resolve(0)
            .then(function () {
            vfs1.writeAllAsync('simple1', new Uint8Array([1, 2, 3, 4, 5]).buffer);
            vfs2.writeAllAsync('simple2', new Uint8Array([1, 2, 3, 4, 5]).buffer);
        })
            .then(function () {
            return msVfs.getStatAsync('simple1').then(function (stat) {
                assert.equal('simple1', stat.name);
                assert.equal(5, stat.size);
            });
        })
            .then(function () {
            return msVfs.getStatAsync('simple2').then(function (stat) {
                assert.equal('simple2', stat.name);
                assert.equal(5, stat.size);
            });
        });
    });
});

},
"test/instructionTest": function(module, exports, require) {
///<reference path="./global.d.ts" />
function ref() { }
exports.ref = ref;
var _cpu = require('../src/core/cpu');
var Instructions = _cpu.Instructions;
describe('instruction lookup', function () {
    var instructions = Instructions.instance;
    it('should accept locate instruction by name', function () {
        assert.equal(instructions.findByName('addi').name, 'addi');
        assert.equal(instructions.findByName('lui').name, 'lui');
        assert.equal(instructions.findByName('syscall').name, 'syscall');
        assert.equal(instructions.findByName('mflo').name, 'mflo');
        assert.equal(instructions.findByName('sb').name, 'sb');
    });
    it('should accept locate instruction by data', function () {
        assert.equal(instructions.findByData(0x0C000000).name, 'jal');
        assert.equal(instructions.findByData(0x3C100890).name, 'lui');
        assert.equal(instructions.findByData(0x00081C4C).name, 'syscall');
        assert.equal(instructions.findByData(0x00001012).name, 'mflo');
        assert.equal(instructions.findByData(0xA0410004).name, 'sb');
    });
});

},
"test/promisetest": function(module, exports, require) {
///<reference path="./global.d.ts" />
function ref() { }
exports.ref = ref;
describe('promise', function () {
    it('simple', function () {
        return new Promise2(function (resolve, reject) {
            setTimeout(function () {
                resolve();
            }, 10);
        });
    });
    it('pass values', function () {
        return Promise2.resolve(10).then(function (value) {
            assert.equal(10, value);
        });
    });
    it('pass values2', function () {
        return Promise2.resolve(10).then(function (value) {
            return 11;
        }).then(function (value) {
            assert.equal(11, value);
        });
    });
    it('pipe', function () {
        return Promise2.resolve(10).then(function (value) {
            return Promise2.resolve(11);
        }).then(function (value) {
            assert.equal(11, value);
        });
    });
    it('pipe2', function () {
        return Promise2.resolve(10).then(function (value) {
            return Promise2.resolve(11).then(function () {
                return 'test';
            });
        }).then(function (value) {
            assert.equal('test', value);
        });
    });
    it('pipe3', function () {
        return Promise2.resolve(10).then(function (value) {
            return Promise2.resolve(11).then(function () {
                return Promise2.resolve('test');
            });
        }).then(function (value) {
            assert.equal('test', value);
        });
    });
    it('pipe4', function () {
        return Promise2.resolve(10).then(function (value) {
            return Promise2.resolve(11).then(function () {
                return waitAsync(10).then(function (_) { return 'test'; });
            });
        }).then(function (value) {
            assert.equal('test', value);
        }, function (error) {
            return 0;
        });
    });
    it('catch', function () {
        return Promise2.resolve(10).then(function (value) {
            return Promise2.resolve(10);
        }).catch(function (e) {
            return 7;
        }).then(function (v) {
            assert.equal(v, 10);
        });
    });
    it('catch2', function () {
        return Promise2.resolve(10).then(function (value) {
            return Promise2.reject(new Error());
        }).catch(function (e) {
            return 7;
        }).then(function (v) {
            assert.equal(v, 7);
        });
    });
});

},
"test/pspautotests": function(module, exports, require) {
///<reference path="./global.d.ts" />
function ref() { }
exports.ref = ref;
var _emulator = require('../src/emulator');
var _vfs = require('../src/hle/vfs');
var difflib = require('../src/util/difflib');
var Emulator = _emulator.Emulator;
var _console = global.console;
var console = logger.named('');
describe('pspautotests', function () {
    this.timeout(5000);
    var tests = [
        { "cpu/cpu_alu": ["cpu_alu", "cpu_branch"] },
        { "cpu/fpu": ["fpu"] },
        { "cpu/icache": ["icache"] },
        { "cpu/lsu": ["lsu"] },
        { "string": ["string"] },
    ];
    function normalizeString(string) {
        return string.replace(/(\r\n|\r)/gm, '\n').replace(/[\r\n\s]+$/gm, '');
    }
    function compareLines2(lines1, lines2) {
        return new difflib.SequenceMatcher(lines1, lines2).get_opcodes();
    }
    function compareText2(text1, text2) {
        return new difflib.SequenceMatcher(difflib.stringAsLines(text1), difflib.stringAsLines(text2)).get_opcodes();
    }
    function compareOutput(name, output, expected) {
        output = normalizeString(output);
        expected = normalizeString(expected);
        var outputLines = difflib.stringAsLines(output);
        var expectedLines = difflib.stringAsLines(expected);
        var equalLines = 0;
        var totalLines = expectedLines.length;
        console.groupCollapsed(name + ' (TEST RESULT DIFF)');
        var opcodes = compareText2(output, expected);
        for (var n = 0; n < opcodes.length; n++) {
            var opcode = (opcodes[n]);
            var start1 = (opcode[1]), end1 = (opcode[2]);
            var start2 = (opcode[3]), end2 = (opcode[4]);
            var length1 = end1 - start1;
            var length2 = end2 - start2;
            switch (opcode[0]) {
                case 'equal':
                    var showBegin = (n > 0);
                    var showEnd = (n < opcodes.length - 1);
                    var broke = false;
                    for (var m = start1; m < end1; m++) {
                        equalLines++;
                        if (!((showBegin && m < start1 + 2) || (showEnd && m > end1 - 2))) {
                            if (!broke)
                                console.log(' ...');
                            broke = true;
                            continue;
                        }
                        console.log(sprintf('\u2714%04d %s', m + 1, outputLines[m]));
                    }
                    break;
                case 'delete':
                    for (var m = start1; m < end1; m++)
                        console.warn(sprintf('\u2716%04d %s', m + 1, outputLines[m]));
                    break;
                case 'insert':
                    for (var m = start2; m < end2; m++)
                        console.info(sprintf(' %04d %s', m + 1, expectedLines[m]));
                    break;
                case 'replace':
                    if (length1 == length2) {
                        for (var m = 0; m < length1; m++) {
                            console.warn(sprintf('\u2716%04d %s', m + start1 + 1, outputLines[m + start1]));
                            console.info(sprintf(' %04d %s', m + start2 + 1, expectedLines[m + start2]));
                        }
                    }
                    else {
                        for (var m = start1; m < end1; m++)
                            console.warn(sprintf('\u2716%04d %s', m + 1, outputLines[m]));
                        for (var m = start2; m < end2; m++)
                            console.info(sprintf(' %04d %s', m + 1, expectedLines[m]));
                    }
                    break;
            }
        }
        var distinctLines = totalLines - equalLines;
        var table = [];
        for (var n = 0; n < Math.max(outputLines.length, expectedLines.length); n++) {
            table[n + 1] = { output: outputLines[n], expected: expectedLines[n] };
        }
        console.groupEnd();
        console.groupCollapsed(name + ' (TEST RESULT TABLE)');
        if (console['table']) {
            console['table'](table);
        }
        else {
            for (var n = 1; n < table.length; n++) {
                if (table[n].output != table[n].expected) {
                    _console.log('NOT EQUAL:', table[n].output, table[n].expected);
                }
            }
        }
        console.groupEnd();
        assert(output == expected, "Output not expected. " + distinctLines + "/" + totalLines + " lines didn't match. Please check console for details.");
    }
    var groupCollapsed = false;
    tests.forEach(function (testGroup) {
        _.keys(testGroup).forEach(function (testGroupName) {
            describe(testGroupName, function () {
                var testNameList = testGroup[testGroupName];
                testNameList.forEach(function (testName) {
                    it(testName, function () {
                        this.timeout(15000);
                        var emulator = new Emulator();
                        var file_base = './data/pspautotests_embed/tests/' + testGroupName + '/' + testName;
                        var file_prx = file_base + '.prx';
                        var file_expected = file_base + '.expected';
                        if (!groupCollapsed)
                            console.groupEnd();
                        groupCollapsed = false;
                        console.groupCollapsed('' + testName);
                        return downloadFileAsync(file_prx).then(function (data_prx) {
                            return downloadFileAsync(file_expected).then(function (data_expected) {
                                var string_expected = Stream.fromArrayBuffer(data_expected).readString(data_expected.byteLength);
                                return emulator.loadExecuteAndWaitAsync(MemoryAsyncStream.fromArrayBuffer(data_prx), file_prx, function () {
                                    var mount = new _vfs.MemoryVfs();
                                    emulator.fileManager.mount('disc0', mount);
                                    emulator.fileManager.mount('umd0', mount);
                                }).then(function () {
                                    groupCollapsed = true;
                                    console.groupEnd();
                                    compareOutput(testName, emulator.emulatorVfs.output, string_expected);
                                    if (emulator.emulatorVfs.screenshot != null) {
                                        throw (new Error("Not implemented screenshot comparison"));
                                    }
                                });
                            });
                        }, function (err) {
                            console.error(err);
                            assert.fail(err);
                            return err;
                        });
                    });
                });
            });
        });
    });
});

},
"test/testasm": function(module, exports, require) {
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
///<reference path="./global.d.ts" />
function ref() { }
exports.ref = ref;
var _cpu = require('../src/core/cpu');
var _memory = require('../src/core/memory');
var CpuState = _cpu.CpuState;
var assembler = new _cpu.MipsAssembler();
var disassembler = new _cpu.MipsDisassembler();
var memory = _memory.getInstance();
var TestSyscallManager = (function (_super) {
    __extends(TestSyscallManager, _super);
    function TestSyscallManager() {
        _super.call(this, null);
    }
    TestSyscallManager.prototype.call = function (state, id) {
    };
    return TestSyscallManager;
})(_cpu.SyscallManager);
function executeProgram(gprInitial, program) {
    program = program.slice(0);
    program.push('break 0');
    var result = assembler.assembleToMemory(memory, 4, program);
    var state = new CpuState(memory, new TestSyscallManager());
    for (var key in gprInitial) {
        if (key.substr(0, 1) == '$') {
            state.gpr[parseInt(key.substr(1))] = gprInitial[key];
        }
        else {
            state[key] = gprInitial[key];
        }
    }
    state.PC = result.entrypoint;
    state.SP = 0x10000;
    try {
        state.executeAtPC();
    }
    catch (e) {
        if (e.message != 'CpuBreakException')
            throw e;
    }
    return state;
}
function generateGpr3Matrix(op, vector) {
    var gprInitial = {};
    var outputMatrix = [];
    for (var n = 0; n < vector.length; n++)
        gprInitial['$' + (15 + n)] = vector[n];
    for (var n = 0; n < vector.length; n++) {
        var program = [];
        for (var m = 0; m < vector.length; m++) {
            program.push(op + " $" + (1 + m) + ", $" + (15 + n) + ", $" + (15 + m));
        }
        var state = executeProgram(gprInitial, program);
        var outputVector = [];
        for (var m = 0; m < vector.length; m++)
            outputVector.push(addressToHex2(state.gpr[1 + m]).toUpperCase());
        outputMatrix.push(outputVector);
    }
    return outputMatrix;
}
function assertProgram(description, gprInitial, program, gprAssertions) {
    var state = executeProgram(gprInitial, program);
    for (var key in gprAssertions) {
        var value = 0;
        if (key.substr(0, 1) == '$') {
            value = state.gpr[parseInt(key.substr(1))];
        }
        else {
            value = state[key];
        }
        assert.equal(addressToHex(value), addressToHex(gprAssertions[key]), description + ': ' + key + ' == ' + addressToHex(gprAssertions[key]));
    }
}
describe('testasm cpu running', function () {
    it('simple', function () {
        assertProgram("subtract 1", {}, ["li r1, 100", "addiu r1, r1, -1"], { $1: 99 });
        assertProgram("xor", { "$1": 0xFF00FF00, "$2": 0x00FFFF00 }, ["xor r3, r1, r2"], { $3: 0xFFFF0000 });
        assertProgram("some arithmetic", { $1: -1, $2: -1, $3: -1, $4: -1, $11: 11, $12: 12 }, [
            "add  r1, r0, r11",
            "add  r2, r0, r12",
            "sub  r3, r2, r1",
            "addi r4, r0, 1234",
        ], { $1: 11, $2: 12, $3: 1, $4: 1234 });
    });
    it('set less than', function () {
        assertProgram("set less than", { "$1": 0x77777777, "$10": 0, "$11": -100, "$12": +100, "$20": 0, "$21": 7, "$22": -200 }, [
            "sltu r1, r10, r20",
            "sltu r2, r10, r21",
            "sltu r3, r11, r22",
            "slt  r4, r11, r22",
        ], { "$1": 0, "$2": 1, "$3": 0, "$4": 0 });
    });
    it('divide', function () {
        assertProgram("divide", {}, ["li r10, 100", "li r11, 12", "div r10, r11"], { HI: 4, LO: 8 });
    });
    it('branch1', function () {
        assertProgram("branch beq", { "$1": 0, "$2": 0 }, [
            ":label1",
            "addi r2, r2, 1",
            "beq r1, r0, label1",
            "addi r1, r1, 1",
        ], { "$1": 2, "$2": 2 });
    });
    it('branch2', function () {
        assertProgram("branch bne", { "$1": 0, "$2": 10 }, [
            ":label1",
            "bne r1, r2, label1",
            "addi r1, r1, 1",
        ], { "$1": 11 });
    });
    it('jal', function () {
        assertProgram("jal", { "$1": 0 }, [
            "jal func1",
            "addi r1, r0, 1",
            "j end",
            "nop",
            ":func1",
            "jr r31",
            "add r1, r1, r1",
            ":end",
        ], { "$1": 2 });
    });
    it('j_inside', function () {
        assertProgram("j_inside", { "$1": 0, "$2": 20 }, [
            ":start",
            "addi r1, r1, 1",
            "beq r1, r2, end",
            "nop",
            "j start",
            "nop",
            ":end",
        ], { "$1": 20 });
    });
    it('j_inside2', function () {
        assertProgram("j_inside2", { "$1": 0, "$30": 20 }, [
            ":start",
            "addi r2, r2, 1",
            ".entrypoint",
            "addi r1, r1, 1",
            "beq r1, r30, end",
            "nop",
            "j start",
            "nop",
            ":end",
        ], { "$1": 20, "$2": 19 });
    });
    it('shift', function () {
    });
    it('load/write', function () {
        assertProgram("loadwrite", { "$1": 0x7F, "$2": 0x100 }, [
            "sb r1, 4(r2)",
            "sb r1, 5(r2)",
            "sb r1, 6(r2)",
            "sb r1, 7(r2)",
            "lw r3, 4(r2)",
            "sw r3, 8(r2)",
            "lw r5, 8(r2)",
            "addi r5, r5, 1",
        ], { "$3": 0x7F7F7F7F, "$5": 0x7F7F7F80 });
    });
    it('opcode add/addu', function () {
        var combineValues = [0x00000000, 0x00000001, 0x00000309, 0x80000000, 0x7FFFFFFF, 0xFFFFFFFF];
        var expectedMatrix = [
            ["00000000", "00000001", "00000309", "80000000", "7FFFFFFF", "FFFFFFFF"],
            ["00000001", "00000002", "0000030A", "80000001", "80000000", "00000000"],
            ["00000309", "0000030A", "00000612", "80000309", "80000308", "00000308"],
            ["80000000", "80000001", "80000309", "00000000", "FFFFFFFF", "7FFFFFFF"],
            ["7FFFFFFF", "80000000", "80000308", "FFFFFFFF", "FFFFFFFE", "7FFFFFFE"],
            ["FFFFFFFF", "00000000", "00000308", "7FFFFFFF", "7FFFFFFE", "FFFFFFFE"]
        ];
        var matrix_add = generateGpr3Matrix('add', combineValues);
        var matrix_addu = generateGpr3Matrix('addu', combineValues);
        assert.equal(JSON.stringify(expectedMatrix), JSON.stringify(matrix_add));
        assert.equal(JSON.stringify(expectedMatrix), JSON.stringify(matrix_addu));
    });
    it('opcode sub/subu', function () {
        var combineValues = [0x00000000, 0x00000001, 0x00000309, 0x80000000, 0x7FFFFFFF, 0xFFFFFFFF];
        var expectedMatrix = [
            ["00000000", "FFFFFFFF", "FFFFFCF7", "80000000", "80000001", "00000001"],
            ["00000001", "00000000", "FFFFFCF8", "80000001", "80000002", "00000002"],
            ["00000309", "00000308", "00000000", "80000309", "8000030A", "0000030A"],
            ["80000000", "7FFFFFFF", "7FFFFCF7", "00000000", "00000001", "80000001"],
            ["7FFFFFFF", "7FFFFFFE", "7FFFFCF6", "FFFFFFFF", "00000000", "80000000"],
            ["FFFFFFFF", "FFFFFFFE", "FFFFFCF6", "7FFFFFFF", "80000000", "00000000"]
        ];
        var matrix_sub = generateGpr3Matrix('sub', combineValues);
        var matrix_subu = generateGpr3Matrix('subu', combineValues);
        assert.equal(JSON.stringify(expectedMatrix), JSON.stringify(matrix_sub));
        assert.equal(JSON.stringify(expectedMatrix), JSON.stringify(matrix_subu));
    });
    it('opcode slvl', function () {
        var combineValues = [0x00000000, 0x00000001, 0x00000002, 0x0000000A, 0x0000001F, 0x00000020, 0x80000000, 0x7FFFFFFF, 0xFFFFFFFF];
        var expectedMatrix = [
            ["00000000", "00000000", "00000000", "00000000", "00000000", "00000000", "00000000", "00000000", "00000000"],
            ["00000001", "00000002", "00000004", "00000400", "80000000", "00000001", "00000001", "80000000", "80000000"],
            ["00000002", "00000004", "00000008", "00000800", "00000000", "00000002", "00000002", "00000000", "00000000"],
            ["0000000A", "00000014", "00000028", "00002800", "00000000", "0000000A", "0000000A", "00000000", "00000000"],
            ["0000001F", "0000003E", "0000007C", "00007C00", "80000000", "0000001F", "0000001F", "80000000", "80000000"],
            ["00000020", "00000040", "00000080", "00008000", "00000000", "00000020", "00000020", "00000000", "00000000"],
            ["80000000", "00000000", "00000000", "00000000", "00000000", "80000000", "80000000", "00000000", "00000000"],
            ["7FFFFFFF", "FFFFFFFE", "FFFFFFFC", "FFFFFC00", "80000000", "7FFFFFFF", "7FFFFFFF", "80000000", "80000000"],
            ["FFFFFFFF", "FFFFFFFE", "FFFFFFFC", "FFFFFC00", "80000000", "FFFFFFFF", "FFFFFFFF", "80000000", "80000000"]
        ];
        var matrix = generateGpr3Matrix('sllv', combineValues);
        assert.equal(JSON.stringify(expectedMatrix), JSON.stringify(matrix));
    });
    it('opcode mult', function () {
        assertProgram("mult", { "$1": 7, "$2": 9 }, ["mult $1, $2",], { "LO": 7 * 9, "HI": 0 });
        assertProgram("mult", { "$1": -1, "$2": 9 }, ["mult $1, $2",], { "LO": -1 * 9, "HI": -1 });
    });
});

},
"test/util/utilsTest": function(module, exports, require) {
///<reference path="../global.d.ts" />
function ref() { }
exports.ref = ref;
describe('utils', function () {
    describe('string repeat', function () {
        it('simple', function () {
            assert.equal('', String_repeat('a', 0));
            assert.equal('a', String_repeat('a', 1));
            assert.equal('aaaa', String_repeat('a', 4));
        });
    });
    describe('Binary layouts', function () {
        it('should read int32', function () {
            var stream = Stream.fromArray([0x01, 0x02, 0x03, 0x04]);
            assert.equal(Int32.read(stream), 0x04030201);
        });
        it('should read int16', function () {
            var stream = Stream.fromArray([0x01, 0x02, 0x03, 0x04]);
            assert.equal(Int16.read(stream), 0x0201);
            assert.equal(Int16.read(stream), 0x0403);
        });
    });
    describe('Binary search', function () {
        it('none', function () {
            var test = [];
            assert.equal(-1, test.binarySearchIndex(function (b) { return compareNumbers(0, b); }));
            assert.equal(-1, test.binarySearchIndex(function (b) { return compareNumbers(11, b); }));
        });
        it('one', function () {
            var test = [10];
            assert.equal(0, test.binarySearchIndex(function (b) { return compareNumbers(10, b); }));
            assert.equal(-1, test.binarySearchIndex(function (b) { return compareNumbers(0, b); }));
            assert.equal(-1, test.binarySearchIndex(function (b) { return compareNumbers(11, b); }));
        });
        it('odd', function () {
            var test = [10, 20, 30, 50, 100];
            assert.equal(0, test.binarySearchIndex(function (b) { return compareNumbers(10, b); }));
            assert.equal(1, test.binarySearchIndex(function (b) { return compareNumbers(20, b); }));
            assert.equal(2, test.binarySearchIndex(function (b) { return compareNumbers(30, b); }));
            assert.equal(3, test.binarySearchIndex(function (b) { return compareNumbers(50, b); }));
            assert.equal(4, test.binarySearchIndex(function (b) { return compareNumbers(100, b); }));
            assert.equal(-1, test.binarySearchIndex(function (b) { return compareNumbers(0, b); }));
            assert.equal(-1, test.binarySearchIndex(function (b) { return compareNumbers(11, b); }));
            assert.equal(-1, test.binarySearchIndex(function (b) { return compareNumbers(21, b); }));
            assert.equal(-1, test.binarySearchIndex(function (b) { return compareNumbers(31, b); }));
            assert.equal(-1, test.binarySearchIndex(function (b) { return compareNumbers(51, b); }));
            assert.equal(-1, test.binarySearchIndex(function (b) { return compareNumbers(101, b); }));
        });
        it('even', function () {
            var test = [10, 20, 30, 50, 100, 110];
            assert.equal(0, test.binarySearchIndex(function (b) { return compareNumbers(10, b); }));
            assert.equal(1, test.binarySearchIndex(function (b) { return compareNumbers(20, b); }));
            assert.equal(2, test.binarySearchIndex(function (b) { return compareNumbers(30, b); }));
            assert.equal(3, test.binarySearchIndex(function (b) { return compareNumbers(50, b); }));
            assert.equal(4, test.binarySearchIndex(function (b) { return compareNumbers(100, b); }));
            assert.equal(5, test.binarySearchIndex(function (b) { return compareNumbers(110, b); }));
            assert.equal(-1, test.binarySearchIndex(function (b) { return compareNumbers(0, b); }));
            assert.equal(-1, test.binarySearchIndex(function (b) { return compareNumbers(11, b); }));
            assert.equal(-1, test.binarySearchIndex(function (b) { return compareNumbers(21, b); }));
            assert.equal(-1, test.binarySearchIndex(function (b) { return compareNumbers(31, b); }));
            assert.equal(-1, test.binarySearchIndex(function (b) { return compareNumbers(51, b); }));
            assert.equal(-1, test.binarySearchIndex(function (b) { return compareNumbers(101, b); }));
            assert.equal(-1, test.binarySearchIndex(function (b) { return compareNumbers(111, b); }));
        });
    });
});

}});
})();
if (typeof exports != "undefined") exports.require2 = require;
